/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver-utils";
exports.ids = ["vendor-chunks/archiver-utils"];
exports.modules = {

/***/ "(rsc)/../node_modules/archiver-utils/file.js":
/*!**********************************************!*\
  !*** ../node_modules/archiver-utils/file.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/../node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\n\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"(rsc)/../node_modules/lodash/flatten.js\");\nvar difference = __webpack_require__(/*! lodash/difference */ \"(rsc)/../node_modules/lodash/difference.js\");\nvar union = __webpack_require__(/*! lodash/union */ \"(rsc)/../node_modules/lodash/union.js\");\nvar isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"(rsc)/../node_modules/lodash/isPlainObject.js\");\n\nvar glob = __webpack_require__(/*! glob */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/index.js\");\n\nvar file = module.exports = {};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  flatten(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = union(result, matches);\n    }\n  });\n  return result;\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function(...args) {\n  // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n  var options = isPlainObject(args[0]) ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch(e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = Object.assign({\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  }, options);\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// reusing bits of grunt's multi-task source normalization\nfile.normalizeFilesArray = function(data) {\n  var files = [];\n\n  data.forEach(function(obj) {\n    var prop;\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  files = _(files).chain().forEach(function(obj) {\n    if (!('src' in obj) || !obj.src) { return; }\n    // Normalize .src properties to flattened array.\n    if (Array.isArray(obj.src)) {\n      obj.src = flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function(obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = Object.assign({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest;\n\n    // Expand file mappings.\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\n        // Copy obj properties to result.\n        var result = Object.assign({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = Object.assign({}, obj);\n        // Set .src and .dest, processing both as templates.\n        result.src = mapObj.src;\n        result.dest = mapObj.dest;\n        // Remove unwanted properties.\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    }\n\n    // Copy obj properties to result, adding an .orig property.\n    var result = Object.assign({}, obj);\n    // Make a clone of the orig obj available.\n    result.orig = Object.assign({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n          if (!('result' in fn)) {\n            src = obj.src;\n            // If src is an array, flatten it. Otherwise, make it into an array.\n            src = Array.isArray(src) ? flatten(src) : [src];\n            // Expand src files, memoizing result.\n            fn.result = file.expand(expandOptions, src);\n          }\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n\n  return files;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMscUVBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QixjQUFjLG1CQUFPLENBQUMsK0RBQWdCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFtQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsMkRBQWM7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsMkVBQXNCOztBQUVsRCxXQUFXLG1CQUFPLENBQUMsMkZBQU07O0FBRXpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvZmlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGFyY2hpdmVyLXV0aWxzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgVGFsa2luZ3RvbiwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFLU1JVFxuICovXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoL2ZsYXR0ZW4nKTtcbnZhciBkaWZmZXJlbmNlID0gcmVxdWlyZSgnbG9kYXNoL2RpZmZlcmVuY2UnKTtcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2xvZGFzaC91bmlvbicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcblxudmFyIGZpbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgcGF0aFNlcGFyYXRvclJlID0gL1tcXC9cXFxcXS9nO1xuXG4vLyBQcm9jZXNzIHNwZWNpZmllZCB3aWxkY2FyZCBnbG9iIHBhdHRlcm5zIG9yIGZpbGVuYW1lcyBhZ2FpbnN0IGFcbi8vIGNhbGxiYWNrLCBleGNsdWRpbmcgYW5kIHVuaXF1aW5nIGZpbGVzIGluIHRoZSByZXN1bHQgc2V0LlxudmFyIHByb2Nlc3NQYXR0ZXJucyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBmbikge1xuICAvLyBGaWxlcGF0aHMgdG8gcmV0dXJuLlxuICB2YXIgcmVzdWx0ID0gW107XG4gIC8vIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgcGF0dGVybnMgYXJyYXkuXG4gIGZsYXR0ZW4ocGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24ocGF0dGVybikge1xuICAgIC8vIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgISBpdCBzaG91bGQgYmUgb21pdHRlZFxuICAgIHZhciBleGNsdXNpb24gPSBwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMDtcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBpcyBhbiBleGNsdXNpb24sIHJlbW92ZSB0aGUgIVxuICAgIGlmIChleGNsdXNpb24pIHsgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7IH1cbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyBmaWxlcyBmb3IgdGhpcyBwYXR0ZXJuLlxuICAgIHZhciBtYXRjaGVzID0gZm4ocGF0dGVybik7XG4gICAgaWYgKGV4Y2x1c2lvbikge1xuICAgICAgLy8gSWYgYW4gZXhjbHVzaW9uLCByZW1vdmUgbWF0Y2hpbmcgZmlsZXMuXG4gICAgICByZXN1bHQgPSBkaWZmZXJlbmNlKHJlc3VsdCwgbWF0Y2hlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBhZGQgbWF0Y2hpbmcgZmlsZXMuXG4gICAgICByZXN1bHQgPSB1bmlvbihyZXN1bHQsIG1hdGNoZXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUcnVlIGlmIHRoZSBmaWxlIHBhdGggZXhpc3RzLlxuZmlsZS5leGlzdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbGVwYXRoID0gcGF0aC5qb2luLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVwYXRoKTtcbn07XG5cbi8vIFJldHVybiBhbiBhcnJheSBvZiBhbGwgZmlsZSBwYXRocyB0aGF0IG1hdGNoIHRoZSBnaXZlbiB3aWxkY2FyZCBwYXR0ZXJucy5cbmZpbGUuZXhwYW5kID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9ucyBvYmplY3QsIHNhdmUgdGhvc2Ugb3B0aW9ucyB0byBwYXNzXG4gIC8vIGludG8gdGhlIEZpbGUucHJvdG90eXBlLmdsb2Iuc3luYyBtZXRob2QuXG4gIHZhciBvcHRpb25zID0gaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGFyZ3Muc2hpZnQoKSA6IHt9O1xuICAvLyBVc2UgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgYW4gQXJyYXksIG90aGVyd2lzZSBjb252ZXJ0IHRoZSBhcmd1bWVudHNcbiAgLy8gb2JqZWN0IHRvIGFuIGFycmF5IGFuZCB1c2UgdGhhdC5cbiAgdmFyIHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAvLyBSZXR1cm4gZW1wdHkgc2V0IGlmIHRoZXJlIGFyZSBubyBwYXR0ZXJucyBvciBmaWxlcGF0aHMuXG4gIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gIC8vIFJldHVybiBhbGwgbWF0Y2hpbmcgZmlsZXBhdGhzLlxuICB2YXIgbWF0Y2hlcyA9IHByb2Nlc3NQYXR0ZXJucyhwYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXG4gICAgcmV0dXJuIGdsb2Iuc3luYyhwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfSk7XG4gIC8vIEZpbHRlciByZXN1bHQgc2V0P1xuICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkIHx8ICcnLCBmaWxlcGF0aCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKGZpbGVwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBvZiB0aGUgcmlnaHQgdHlwZSBhbmQgZXhpc3RzLCB0aGlzIHNob3VsZCB3b3JrLlxuICAgICAgICAgIHJldHVybiBmcy5zdGF0U3luYyhmaWxlcGF0aClbb3B0aW9ucy5maWx0ZXJdKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgbm90IHRoZSByaWdodCB0eXBlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG4vLyBCdWlsZCBhIG11bHRpIHRhc2sgXCJmaWxlc1wiIG9iamVjdCBkeW5hbWljYWxseS5cbmZpbGUuZXhwYW5kTWFwcGluZyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBkZXN0QmFzZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcmVuYW1lOiBmdW5jdGlvbihkZXN0QmFzZSwgZGVzdFBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oZGVzdEJhc2UgfHwgJycsIGRlc3RQYXRoKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpO1xuICB2YXIgZmlsZXMgPSBbXTtcbiAgdmFyIGZpbGVCeURlc3QgPSB7fTtcbiAgLy8gRmluZCBhbGwgZmlsZXMgbWF0Y2hpbmcgcGF0dGVybiwgdXNpbmcgcGFzc2VkLWluIG9wdGlvbnMuXG4gIGZpbGUuZXhwYW5kKG9wdGlvbnMsIHBhdHRlcm5zKS5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xuICAgIHZhciBkZXN0UGF0aCA9IHNyYztcbiAgICAvLyBGbGF0dGVuP1xuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgIGRlc3RQYXRoID0gcGF0aC5iYXNlbmFtZShkZXN0UGF0aCk7XG4gICAgfVxuICAgIC8vIENoYW5nZSB0aGUgZXh0ZW5zaW9uP1xuICAgIGlmIChvcHRpb25zLmV4dCkge1xuICAgICAgZGVzdFBhdGggPSBkZXN0UGF0aC5yZXBsYWNlKC8oXFwuW15cXC9dKik/JC8sIG9wdGlvbnMuZXh0KTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgZGVzdGluYXRpb24gZmlsZW5hbWUuXG4gICAgdmFyIGRlc3QgPSBvcHRpb25zLnJlbmFtZShkZXN0QmFzZSwgZGVzdFBhdGgsIG9wdGlvbnMpO1xuICAgIC8vIFByZXBlbmQgY3dkIHRvIHNyYyBwYXRoIGlmIG5lY2Vzc2FyeS5cbiAgICBpZiAob3B0aW9ucy5jd2QpIHsgc3JjID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkLCBzcmMpOyB9XG4gICAgLy8gTm9ybWFsaXplIGZpbGVwYXRocyB0byBiZSB1bml4LXN0eWxlLlxuICAgIGRlc3QgPSBkZXN0LnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xuICAgIHNyYyA9IHNyYy5yZXBsYWNlKHBhdGhTZXBhcmF0b3JSZSwgJy8nKTtcbiAgICAvLyBNYXAgY29ycmVjdCBzcmMgcGF0aCB0byBkZXN0IHBhdGguXG4gICAgaWYgKGZpbGVCeURlc3RbZGVzdF0pIHtcbiAgICAgIC8vIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsIHB1c2ggdGhpcyBzcmMgb250byB0aGF0IGRlc3QncyBzcmMgYXJyYXkuXG4gICAgICBmaWxlQnlEZXN0W2Rlc3RdLnNyYy5wdXNoKHNyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgc3JjLWRlc3QgZmlsZSBtYXBwaW5nIG9iamVjdC5cbiAgICAgIGZpbGVzLnB1c2goe1xuICAgICAgICBzcmM6IFtzcmNdLFxuICAgICAgICBkZXN0OiBkZXN0LFxuICAgICAgfSk7XG4gICAgICAvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgZm9yIGxhdGVyIHVzZS5cbiAgICAgIGZpbGVCeURlc3RbZGVzdF0gPSBmaWxlc1tmaWxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmlsZXM7XG59O1xuXG4vLyByZXVzaW5nIGJpdHMgb2YgZ3J1bnQncyBtdWx0aS10YXNrIHNvdXJjZSBub3JtYWxpemF0aW9uXG5maWxlLm5vcm1hbGl6ZUZpbGVzQXJyYXkgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBmaWxlcyA9IFtdO1xuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcHJvcDtcbiAgICBpZiAoJ3NyYycgaW4gb2JqIHx8ICdkZXN0JyBpbiBvYmopIHtcbiAgICAgIGZpbGVzLnB1c2gob2JqKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmaWxlcyA9IF8oZmlsZXMpLmNoYWluKCkuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoISgnc3JjJyBpbiBvYmopIHx8ICFvYmouc3JjKSB7IHJldHVybjsgfVxuICAgIC8vIE5vcm1hbGl6ZSAuc3JjIHByb3BlcnRpZXMgdG8gZmxhdHRlbmVkIGFycmF5LlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5zcmMpKSB7XG4gICAgICBvYmouc3JjID0gZmxhdHRlbihvYmouc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLnNyYyA9IFtvYmouc3JjXTtcbiAgICB9XG4gIH0pLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAvLyBCdWlsZCBvcHRpb25zIG9iamVjdCwgcmVtb3ZpbmcgdW53YW50ZWQgcHJvcGVydGllcy5cbiAgICB2YXIgZXhwYW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuc3JjO1xuICAgIGRlbGV0ZSBleHBhbmRPcHRpb25zLmRlc3Q7XG5cbiAgICAvLyBFeHBhbmQgZmlsZSBtYXBwaW5ncy5cbiAgICBpZiAob2JqLmV4cGFuZCkge1xuICAgICAgcmV0dXJuIGZpbGUuZXhwYW5kTWFwcGluZyhvYmouc3JjLCBvYmouZGVzdCwgZXhwYW5kT3B0aW9ucykubWFwKGZ1bmN0aW9uKG1hcE9iaikge1xuICAgICAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdC5cbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxuICAgICAgICByZXN1bHQub3JpZyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIC8vIFNldCAuc3JjIGFuZCAuZGVzdCwgcHJvY2Vzc2luZyBib3RoIGFzIHRlbXBsYXRlcy5cbiAgICAgICAgcmVzdWx0LnNyYyA9IG1hcE9iai5zcmM7XG4gICAgICAgIHJlc3VsdC5kZXN0ID0gbWFwT2JqLmRlc3Q7XG4gICAgICAgIC8vIFJlbW92ZSB1bndhbnRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICBbJ2V4cGFuZCcsICdjd2QnLCAnZmxhdHRlbicsICdyZW5hbWUnLCAnZXh0J10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdCwgYWRkaW5nIGFuIC5vcmlnIHByb3BlcnR5LlxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxuICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmICgnc3JjJyBpbiByZXN1bHQpIHtcbiAgICAgIC8vIEV4cG9zZSBhbiBleHBhbmQtb24tZGVtYW5kIGdldHRlciBtZXRob2QgYXMgLnNyYy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdzcmMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgdmFyIHNyYztcbiAgICAgICAgICBpZiAoISgncmVzdWx0JyBpbiBmbikpIHtcbiAgICAgICAgICAgIHNyYyA9IG9iai5zcmM7XG4gICAgICAgICAgICAvLyBJZiBzcmMgaXMgYW4gYXJyYXksIGZsYXR0ZW4gaXQuIE90aGVyd2lzZSwgbWFrZSBpdCBpbnRvIGFuIGFycmF5LlxuICAgICAgICAgICAgc3JjID0gQXJyYXkuaXNBcnJheShzcmMpID8gZmxhdHRlbihzcmMpIDogW3NyY107XG4gICAgICAgICAgICAvLyBFeHBhbmQgc3JjIGZpbGVzLCBtZW1vaXppbmcgcmVzdWx0LlxuICAgICAgICAgICAgZm4ucmVzdWx0ID0gZmlsZS5leHBhbmQoZXhwYW5kT3B0aW9ucywgc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZuLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCdkZXN0JyBpbiByZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kZXN0ID0gb2JqLmRlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSkuZmxhdHRlbigpLnZhbHVlKCk7XG5cbiAgcmV0dXJuIGZpbGVzO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/index.js":
/*!***********************************************!*\
  !*** ../node_modules/archiver-utils/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2015 Chris Talkington.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/../node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(rsc)/../node_modules/is-stream/index.js\");\nvar lazystream = __webpack_require__(/*! lazystream */ \"(rsc)/../node_modules/lazystream/lib/lazystream.js\");\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(rsc)/../node_modules/archiver-utils/node_modules/normalize-path/index.js\");\nvar defaults = __webpack_require__(/*! lodash/defaults */ \"(rsc)/../node_modules/lodash/defaults.js\");\n\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/index.js\").PassThrough);\n\nvar utils = module.exports = {};\nutils.file = __webpack_require__(/*! ./file.js */ \"(rsc)/../node_modules/archiver-utils/file.js\");\n\nutils.collectStream = function(source, callback) {\n  var collection = [];\n  var size = 0;\n\n  source.on('error', callback);\n\n  source.on('data', function(chunk) {\n    collection.push(chunk);\n    size += chunk.length;\n  });\n\n  source.on('end', function() {\n    var buf = Buffer.alloc(size);\n    var offset = 0;\n\n    collection.forEach(function(data) {\n      data.copy(buf, offset);\n      offset += data.length;\n    });\n\n    callback(null, buf);\n  });\n};\n\nutils.dateify = function(dateish) {\n  dateish = dateish || new Date();\n\n  if (dateish instanceof Date) {\n    dateish = dateish;\n  } else if (typeof dateish === 'string') {\n    dateish = new Date(dateish);\n  } else {\n    dateish = new Date();\n  }\n\n  return dateish;\n};\n\n// this is slightly different from lodash version\nutils.defaults = function(object, source, guard) {\n  var args = arguments;\n  args[0] = args[0] || {};\n\n  return defaults(...args);\n};\n\nutils.isStream = function(source) {\n  return isStream(source);\n};\n\nutils.lazyReadStream = function(filepath) {\n  return new lazystream.Readable(function() {\n    return fs.createReadStream(filepath);\n  });\n};\n\nutils.normalizeInputSource = function(source) {\n  if (source === null) {\n    return Buffer.alloc(0);\n  } else if (typeof source === 'string') {\n    return Buffer.from(source);\n  } else if (utils.isStream(source)) {\n    // Always pipe through a PassThrough stream to guarantee pausing the stream if it's already flowing,\n    // since it will only be processed in a (distant) future iteration of the event loop, and will lose\n    // data if already flowing now.\n    return source.pipe(new PassThrough());\n  }\n\n  return source;\n};\n\nutils.sanitizePath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\n};\n\nutils.trailingSlashIt = function(str) {\n  return str.slice(-1) !== '/' ? str + '/' : str;\n};\n\nutils.unixifyPath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\n};\n\nutils.walkdir = function(dirpath, base, callback) {\n  var results = [];\n\n  if (typeof base === 'function') {\n    callback = base;\n    base = dirpath;\n  }\n\n  fs.readdir(dirpath, function(err, list) {\n    var i = 0;\n    var file;\n    var filepath;\n\n    if (err) {\n      return callback(err);\n    }\n\n    (function next() {\n      file = list[i++];\n\n      if (!file) {\n        return callback(null, results);\n      }\n\n      filepath = path.join(dirpath, file);\n\n      fs.stat(filepath, function(err, stats) {\n        results.push({\n          path: filepath,\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\n          stats: stats\n        });\n\n        if (stats && stats.isDirectory()) {\n          utils.walkdir(filepath, base, function(err, res) {\n\t    if(err){\n\t      return callback(err);\n\t    }\n\n            res.forEach(function(dirEntry) {\n              results.push(dirEntry);\n            });\n\t\t  \n            next();  \n          });\n        } else {\n          next();\n        }\n      });\n    })();\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLHFFQUFhO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixlQUFlLG1CQUFPLENBQUMsMkRBQVc7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVk7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsaUdBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxpRUFBaUI7O0FBRXhDLGFBQWEsb0RBQXdCO0FBQ3JDLGtCQUFrQiwrSUFBc0M7O0FBRXhEO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLCtEQUFXOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBhcmNoaXZlci11dGlsc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaHJpcyBUYWxraW5ndG9uLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvYXJjaGl2ZXItdXRpbHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbnZhciBsYXp5c3RyZWFtID0gcmVxdWlyZSgnbGF6eXN0cmVhbScpO1xudmFyIG5vcm1hbGl6ZVBhdGggPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRzJyk7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5QYXNzVGhyb3VnaDtcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnV0aWxzLmZpbGUgPSByZXF1aXJlKCcuL2ZpbGUuanMnKTtcblxudXRpbHMuY29sbGVjdFN0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcbiAgdmFyIHNpemUgPSAwO1xuXG4gIHNvdXJjZS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cbiAgc291cmNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb2xsZWN0aW9uLnB1c2goY2h1bmspO1xuICAgIHNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICB9KTtcblxuICBzb3VyY2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGF0YS5jb3B5KGJ1Ziwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBkYXRhLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XG4gIH0pO1xufTtcblxudXRpbHMuZGF0ZWlmeSA9IGZ1bmN0aW9uKGRhdGVpc2gpIHtcbiAgZGF0ZWlzaCA9IGRhdGVpc2ggfHwgbmV3IERhdGUoKTtcblxuICBpZiAoZGF0ZWlzaCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBkYXRlaXNoID0gZGF0ZWlzaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZWlzaCA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoZGF0ZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZWlzaCA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICByZXR1cm4gZGF0ZWlzaDtcbn07XG5cbi8vIHRoaXMgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gbG9kYXNoIHZlcnNpb25cbnV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBhcmdzWzBdID0gYXJnc1swXSB8fCB7fTtcblxuICByZXR1cm4gZGVmYXVsdHMoLi4uYXJncyk7XG59O1xuXG51dGlscy5pc1N0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gaXNTdHJlYW0oc291cmNlKTtcbn07XG5cbnV0aWxzLmxhenlSZWFkU3RyZWFtID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5ldyBsYXp5c3RyZWFtLlJlYWRhYmxlKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVwYXRoKTtcbiAgfSk7XG59O1xuXG51dGlscy5ub3JtYWxpemVJbnB1dFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzb3VyY2UpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyZWFtKHNvdXJjZSkpIHtcbiAgICAvLyBBbHdheXMgcGlwZSB0aHJvdWdoIGEgUGFzc1Rocm91Z2ggc3RyZWFtIHRvIGd1YXJhbnRlZSBwYXVzaW5nIHRoZSBzdHJlYW0gaWYgaXQncyBhbHJlYWR5IGZsb3dpbmcsXG4gICAgLy8gc2luY2UgaXQgd2lsbCBvbmx5IGJlIHByb2Nlc3NlZCBpbiBhIChkaXN0YW50KSBmdXR1cmUgaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wLCBhbmQgd2lsbCBsb3NlXG4gICAgLy8gZGF0YSBpZiBhbHJlYWR5IGZsb3dpbmcgbm93LlxuICAgIHJldHVybiBzb3VyY2UucGlwZShuZXcgUGFzc1Rocm91Z2goKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufTtcblxudXRpbHMuc2FuaXRpemVQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJykucmVwbGFjZSgvXihcXC5cXC5cXC98XFwvKSsvLCAnJyk7XG59O1xuXG51dGlscy50cmFpbGluZ1NsYXNoSXQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgtMSkgIT09ICcvJyA/IHN0ciArICcvJyA6IHN0cjtcbn07XG5cbnV0aWxzLnVuaXhpZnlQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJyk7XG59O1xuXG51dGlscy53YWxrZGlyID0gZnVuY3Rpb24oZGlycGF0aCwgYmFzZSwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAodHlwZW9mIGJhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJhc2U7XG4gICAgYmFzZSA9IGRpcnBhdGg7XG4gIH1cblxuICBmcy5yZWFkZGlyKGRpcnBhdGgsIGZ1bmN0aW9uKGVyciwgbGlzdCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZmlsZTtcbiAgICB2YXIgZmlsZXBhdGg7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAoZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGZpbGUgPSBsaXN0W2krK107XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICB9XG5cbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKGRpcnBhdGgsIGZpbGUpO1xuXG4gICAgICBmcy5zdGF0KGZpbGVwYXRoLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgcmVsYXRpdmU6IHBhdGgucmVsYXRpdmUoYmFzZSwgZmlsZXBhdGgpLnJlcGxhY2UoL1xcXFwvZywgJy8nKSxcbiAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICB1dGlscy53YWxrZGlyKGZpbGVwYXRoLCBiYXNlLCBmdW5jdGlvbihlcnIsIHJlcykge1xuXHQgICAgaWYoZXJyKXtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdCAgICB9XG5cbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJFbnRyeSk7XG4gICAgICAgICAgICB9KTtcblx0XHQgIFxuICAgICAgICAgICAgbmV4dCgpOyAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/brace-expansion/index.js":
/*!****************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/brace-expansion/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var balanced = __webpack_require__(/*! balanced-match */ \"(rsc)/../node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHFFQUFnQjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUFLOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsdUNBQXVDLEdBQUc7QUFDMUMsWUFBWSxHQUFHLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixLQUFLO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRTtBQUNaLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLEtBQUssUUFBUSxFQUFFLElBQUksRUFBRTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhbGFuY2VkID0gcmVxdWlyZSgnYmFsYW5jZWQtbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRUb3A7XG5cbnZhciBlc2NTbGFzaCA9ICdcXDBTTEFTSCcrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NPcGVuID0gJ1xcME9QRU4nK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ2xvc2UgPSAnXFwwQ0xPU0UnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ29tbWEgPSAnXFwwQ09NTUEnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjUGVyaW9kID0gJ1xcMFBFUklPRCcrTWF0aC5yYW5kb20oKSsnXFwwJztcblxuZnVuY3Rpb24gbnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApID09IHN0clxuICAgID8gcGFyc2VJbnQoc3RyLCAxMClcbiAgICA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxcXFxcJykuam9pbihlc2NTbGFzaClcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXHsnKS5qb2luKGVzY09wZW4pXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx9Jykuam9pbihlc2NDbG9zZSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXCwnKS5qb2luKGVzY0NvbW1hKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLicpLmpvaW4oZXNjUGVyaW9kKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZXNjU2xhc2gpLmpvaW4oJ1xcXFwnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY09wZW4pLmpvaW4oJ3snKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0Nsb3NlKS5qb2luKCd9JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDb21tYSkuam9pbignLCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjUGVyaW9kKS5qb2luKCcuJyk7XG59XG5cblxuLy8gQmFzaWNhbGx5IGp1c3Qgc3RyLnNwbGl0KFwiLFwiKSwgYnV0IGhhbmRsaW5nIGNhc2VzXG4vLyB3aGVyZSB3ZSBoYXZlIG5lc3RlZCBicmFjZWQgc2VjdGlvbnMsIHdoaWNoIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBhcyBpbmRpdmlkdWFsIG1lbWJlcnMsIGxpa2Uge2Ese2IsY30sZH1cbmZ1bmN0aW9uIHBhcnNlQ29tbWFQYXJ0cyhzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFsnJ107XG5cbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG5cbiAgaWYgKCFtKVxuICAgIHJldHVybiBzdHIuc3BsaXQoJywnKTtcblxuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBib2R5ID0gbS5ib2R5O1xuICB2YXIgcG9zdCA9IG0ucG9zdDtcbiAgdmFyIHAgPSBwcmUuc3BsaXQoJywnKTtcblxuICBwW3AubGVuZ3RoLTFdICs9ICd7JyArIGJvZHkgKyAnfSc7XG4gIHZhciBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gIGlmIChwb3N0Lmxlbmd0aCkge1xuICAgIHBbcC5sZW5ndGgtMV0gKz0gcG9zdFBhcnRzLnNoaWZ0KCk7XG4gICAgcC5wdXNoLmFwcGx5KHAsIHBvc3RQYXJ0cyk7XG4gIH1cblxuICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvcChzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgLy8gQW55dGhpbmcgc3RhcnRpbmcgd2l0aCB7fSB3aWxsIGhhdmUgdGhlIGZpcnN0IHR3byBieXRlcyBwcmVzZXJ2ZWRcbiAgLy8gYnV0ICpvbmx5KiBhdCB0aGUgdG9wIGxldmVsLCBzbyB7fSxhfWIgd2lsbCBub3QgZXhwYW5kIHRvIGFueXRoaW5nLFxuICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgLy8gT25lIGNvdWxkIGFyZ3VlIHRoYXQgdGhpcyBpcyBhIGJ1ZyBpbiBCYXNoLCBidXQgc2luY2UgdGhlIGdvYWwgb2ZcbiAgLy8gdGhpcyBtb2R1bGUgaXMgdG8gbWF0Y2ggQmFzaCdzIHJ1bGVzLCB3ZSBlc2NhcGUgYSBsZWFkaW5nIHt9XG4gIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAne30nKSB7XG4gICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnN1YnN0cigyKTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmQoZXNjYXBlQnJhY2VzKHN0ciksIHRydWUpLm1hcCh1bmVzY2FwZUJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG59XG5mdW5jdGlvbiBpc1BhZGRlZChlbCkge1xuICByZXR1cm4gL14tPzBcXGQvLnRlc3QoZWwpO1xufVxuXG5mdW5jdGlvbiBsdGUoaSwgeSkge1xuICByZXR1cm4gaSA8PSB5O1xufVxuZnVuY3Rpb24gZ3RlKGksIHkpIHtcbiAgcmV0dXJuIGkgPj0geTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0ciwgaXNUb3ApIHtcbiAgdmFyIGV4cGFuc2lvbnMgPSBbXTtcblxuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICBpZiAoIW0pIHJldHVybiBbc3RyXTtcblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgaWYgKC9cXCQkLy50ZXN0KG0ucHJlKSkgeyAgICBcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUrICd7JyArIG0uYm9keSArICd9JyArIHBvc3Rba107XG4gICAgICBleHBhbnNpb25zLnB1c2goZXhwYW5zaW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlzTnVtZXJpY1NlcXVlbmNlID0gL14tP1xcZCtcXC5cXC4tP1xcZCsoPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgICB2YXIgaXNBbHBoYVNlcXVlbmNlID0gL15bYS16QS1aXVxcLlxcLlthLXpBLVpdKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gICAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gICAgdmFyIGlzT3B0aW9ucyA9IG0uYm9keS5pbmRleE9mKCcsJykgPj0gMDtcbiAgICBpZiAoIWlzU2VxdWVuY2UgJiYgIWlzT3B0aW9ucykge1xuICAgICAgLy8ge2F9LGJ9XG4gICAgICBpZiAobS5wb3N0Lm1hdGNoKC8sLipcXH0vKSkge1xuICAgICAgICBzdHIgPSBtLnByZSArICd7JyArIG0uYm9keSArIGVzY0Nsb3NlICsgbS5wb3N0O1xuICAgICAgICByZXR1cm4gZXhwYW5kKHN0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3N0cl07XG4gICAgfVxuXG4gICAgdmFyIG47XG4gICAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICAgIG4gPSBtLmJvZHkuc3BsaXQoL1xcLlxcLi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gcGFyc2VDb21tYVBhcnRzKG0uYm9keSk7XG4gICAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8geHt7YSxifX15ID09PiB4e2F9eSB4e2J9eVxuICAgICAgICBuID0gZXhwYW5kKG5bMF0sIGZhbHNlKS5tYXAoZW1icmFjZSk7XG4gICAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwb3N0Lm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5wcmUgKyBuWzBdICsgcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIG4gaXMgdGhlIHBhcnRzLCBhbmQgd2Uga25vdyBpdCdzIG5vdCBhIGNvbW1hIHNldFxuICAgIC8vIHdpdGggYSBzaW5nbGUgZW50cnkuXG4gICAgdmFyIE47XG5cbiAgICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgICAgdmFyIHggPSBudW1lcmljKG5bMF0pO1xuICAgICAgdmFyIHkgPSBudW1lcmljKG5bMV0pO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoblswXS5sZW5ndGgsIG5bMV0ubGVuZ3RoKVxuICAgICAgdmFyIGluY3IgPSBuLmxlbmd0aCA9PSAzXG4gICAgICAgID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSlcbiAgICAgICAgOiAxO1xuICAgICAgdmFyIHRlc3QgPSBsdGU7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHkgPCB4O1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgaW5jciAqPSAtMTtcbiAgICAgICAgdGVzdCA9IGd0ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYWQgPSBuLnNvbWUoaXNQYWRkZWQpO1xuXG4gICAgICBOID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSB4OyB0ZXN0KGksIHkpOyBpICs9IGluY3IpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIGlmIChpc0FscGhhU2VxdWVuY2UpIHtcbiAgICAgICAgICBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgYyA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMgPSBTdHJpbmcoaSk7XG4gICAgICAgICAgaWYgKHBhZCkge1xuICAgICAgICAgICAgdmFyIG5lZWQgPSB3aWR0aCAtIGMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG5lZWQgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gbmV3IEFycmF5KG5lZWQgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICAgIGlmIChpIDwgMClcbiAgICAgICAgICAgICAgICBjID0gJy0nICsgeiArIGMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjID0geiArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE4ucHVzaChjKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgTi5wdXNoLmFwcGx5KE4sIGV4cGFuZChuW2pdLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb3N0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBwcmUgKyBOW2pdICsgcG9zdFtrXTtcbiAgICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbilcbiAgICAgICAgICBleHBhbnNpb25zLnB1c2goZXhwYW5zaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5zaW9ucztcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/normalize-path/index.js":
/*!***************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/normalize-path/index.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXBhdGgvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBub3JtYWxpemUtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbm9ybWFsaXplLXBhdGg+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aCwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0aCB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdcXFxcJyB8fCBwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG5cbiAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICBpZiAobGVuIDw9IDEpIHJldHVybiBwYXRoO1xuXG4gIC8vIGVuc3VyZSB0aGF0IHdpbjMyIG5hbWVzcGFjZXMgaGFzIHR3byBsZWFkaW5nIHNsYXNoZXMsIHNvIHRoYXQgdGhlIHBhdGggaXNcbiAgLy8gaGFuZGxlZCBwcm9wZXJseSBieSB0aGUgd2luMzIgdmVyc2lvbiBvZiBwYXRoLnBhcnNlKCkgYWZ0ZXIgYmVpbmcgbm9ybWFsaXplZFxuICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM2NTI0Nyh2PXZzLjg1KS5hc3B4I25hbWVzcGFjZXNcbiAgdmFyIHByZWZpeCA9ICcnO1xuICBpZiAobGVuID4gNCAmJiBwYXRoWzNdID09PSAnXFxcXCcpIHtcbiAgICB2YXIgY2ggPSBwYXRoWzJdO1xuICAgIGlmICgoY2ggPT09ICc/JyB8fCBjaCA9PT0gJy4nKSAmJiBwYXRoLnNsaWNlKDAsIDIpID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICAgIHByZWZpeCA9ICcvLyc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KC9bL1xcXFxdKy8pO1xuICBpZiAoc3RyaXBUcmFpbGluZyAhPT0gZmFsc2UgJiYgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgIHNlZ3MucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHByZWZpeCArIHNlZ3Muam9pbignLycpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/normalize-path/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst { ERR_INVALID_ARG_TYPE } = codes\nlet addAbortListener\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, 'signal')\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream)\n}\nmodule.exports.addAbortSignalNoValidate = function (signal, stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream\n  }\n  const onAbort = isNodeStream(stream)\n    ? () => {\n        stream.destroy(\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n    : () => {\n        stream[kControllerErrorFunction](\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n  if (signal.aborted) {\n    onAbort()\n  } else {\n    addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n    const disposable = addAbortListener(signal, onAbort)\n    eos(stream, disposable[SymbolDispose])\n  }\n  return stream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMseUhBQXdCO0FBQzFELFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQywrR0FBbUI7QUFDekQsUUFBUSxzREFBc0QsRUFBRSxtQkFBTyxDQUFDLGdIQUFTO0FBQ2pGLFlBQVksbUJBQU8sQ0FBQyxnSUFBaUI7QUFDckMsUUFBUSx1QkFBdUI7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLG1KQUEyQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBTeW1ib2xEaXNwb3NlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgQWJvcnRFcnJvciwgY29kZXMgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgaXNOb2RlU3RyZWFtLCBpc1dlYlN0cmVhbSwga0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFIH0gPSBjb2Rlc1xubGV0IGFkZEFib3J0TGlzdGVuZXJcblxuLy8gVGhpcyBtZXRob2QgaXMgaW5saW5lZCBoZXJlIGZvciByZWFkYWJsZS1zdHJlYW1cbi8vIEl0IGFsc28gZG9lcyBub3QgYWxsb3cgZm9yIHNpZ25hbCB0byBub3QgZXhpc3Qgb24gdGhlIHN0cmVhbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzYwNjEjZGlzY3Vzc2lvbl9yNTMzNzE4MDI5XG5jb25zdCB2YWxpZGF0ZUFib3J0U2lnbmFsID0gKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsID0gZnVuY3Rpb24gYWRkQWJvcnRTaWduYWwoc2lnbmFsLCBzdHJlYW0pIHtcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsICdzaWduYWwnKVxuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pICYmICFpc1dlYlN0cmVhbShzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdzdHJlYW0nLCBbJ1JlYWRhYmxlU3RyZWFtJywgJ1dyaXRhYmxlU3RyZWFtJywgJ1N0cmVhbSddLCBzdHJlYW0pXG4gIH1cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZShzaWduYWwsIHN0cmVhbSlcbn1cbm1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZSA9IGZ1bmN0aW9uIChzaWduYWwsIHN0cmVhbSkge1xuICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkge1xuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICBjb25zdCBvbkFib3J0ID0gaXNOb2RlU3RyZWFtKHN0cmVhbSlcbiAgICA/ICgpID0+IHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koXG4gICAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6ICgpID0+IHtcbiAgICAgICAgc3RyZWFtW2tDb250cm9sbGVyRXJyb3JGdW5jdGlvbl0oXG4gICAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgb25BYm9ydCgpXG4gIH0gZWxzZSB7XG4gICAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgb25BYm9ydClcbiAgICBlb3Moc3RyZWFtLCBkaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { inspect } = __webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUNySCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsMkdBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFN0cmluZ1Byb3RvdHlwZVNsaWNlLCBTeW1ib2xJdGVyYXRvciwgVHlwZWRBcnJheVByb3RvdHlwZVNldCwgVWludDhBcnJheSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQnVmZmVyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaCh2KSB7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBkYXRhOiB2LFxuICAgICAgbmV4dDogbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeVxuICAgIHRoaXMudGFpbCA9IGVudHJ5XG4gICAgKyt0aGlzLmxlbmd0aFxuICB9XG4gIHVuc2hpZnQodikge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgZGF0YTogdixcbiAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5XG4gICAgdGhpcy5oZWFkID0gZW50cnlcbiAgICArK3RoaXMubGVuZ3RoXG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCByZXQgPSB0aGlzLmhlYWQuZGF0YVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgICAtLXRoaXMubGVuZ3RoXG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIGxldCBwID0gdGhpcy5oZWFkXG4gICAgbGV0IHJldCA9ICcnICsgcC5kYXRhXG4gICAgd2hpbGUgKChwID0gcC5uZXh0KSAhPT0gbnVsbCkgcmV0ICs9IHMgKyBwLmRhdGFcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICBjb25zdCByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMClcbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChwKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgcC5kYXRhLCBpKVxuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoXG4gICAgICBwID0gcC5uZXh0XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmhlYWQuZGF0YVxuICAgIGlmIChuIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICBjb25zdCBzbGljZSA9IGRhdGEuc2xpY2UoMCwgbilcbiAgICAgIHRoaXMuaGVhZC5kYXRhID0gZGF0YS5zbGljZShuKVxuICAgICAgcmV0dXJuIHNsaWNlXG4gICAgfVxuICAgIGlmIChuID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgcmV0dXJuIHRoaXMuc2hpZnQoKVxuICAgIH1cbiAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgcmV0dXJuIGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobilcbiAgfVxuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGFcbiAgfVxuICAqW1N5bWJvbEl0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGxldCBwID0gdGhpcy5oZWFkOyBwOyBwID0gcC5uZXh0KSB7XG4gICAgICB5aWVsZCBwLmRhdGFcbiAgICB9XG4gIH1cblxuICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICBfZ2V0U3RyaW5nKG4pIHtcbiAgICBsZXQgcmV0ID0gJydcbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBjID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ciA9IHAuZGF0YVxuICAgICAgaWYgKG4gPiBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldCArPSBzdHJcbiAgICAgICAgbiAtPSBzdHIubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgIHJldCArPSBzdHJcbiAgICAgICAgICArK2NcbiAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHRcbiAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCAwLCBuKVxuICAgICAgICAgIHRoaXMuaGVhZCA9IHBcbiAgICAgICAgICBwLmRhdGEgPSBTdHJpbmdQcm90b3R5cGVTbGljZShzdHIsIG4pXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgICsrY1xuICAgIH0gd2hpbGUgKChwID0gcC5uZXh0KSAhPT0gbnVsbClcbiAgICB0aGlzLmxlbmd0aCAtPSBjXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIF9nZXRCdWZmZXIobikge1xuICAgIGNvbnN0IHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKVxuICAgIGNvbnN0IHJldExlbiA9IG5cbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBjID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHAuZGF0YVxuICAgICAgaWYgKG4gPiBidWYubGVuZ3RoKSB7XG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBidWYsIHJldExlbiAtIG4pXG4gICAgICAgIG4gLT0gYnVmLmxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgYnVmLCByZXRMZW4gLSBuKVxuICAgICAgICAgICsrY1xuICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dFxuICAgICAgICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIHJldExlbiAtIG4pXG4gICAgICAgICAgdGhpcy5oZWFkID0gcFxuICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICArK2NcbiAgICB9IHdoaWxlICgocCA9IHAubmV4dCkgIT09IG51bGwpXG4gICAgdGhpcy5sZW5ndGggLT0gY1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXShfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3BlY3QodGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICBkZXB0aDogMCxcbiAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/compose.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/compose.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { pipeline } = __webpack_require__(/*! ./pipeline */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvY29tcG9zZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHNIQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxrSEFBVTtBQUNqQyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLG9IQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxnSEFBUztBQUNyQjtBQUNBO0FBQ0EsV0FBVztBQUNYLEVBQUUsRUFBRSxtQkFBTyxDQUFDLCtHQUFtQjtBQUMvQixZQUFZLG1CQUFPLENBQUMsZ0lBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJy4vcGlwZWxpbmUnKVxuY29uc3QgRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXgnKVxuY29uc3QgeyBkZXN0cm95ZXIgfSA9IHJlcXVpcmUoJy4vZGVzdHJveScpXG5jb25zdCB7XG4gIGlzTm9kZVN0cmVhbSxcbiAgaXNSZWFkYWJsZSxcbiAgaXNXcml0YWJsZSxcbiAgaXNXZWJTdHJlYW0sXG4gIGlzVHJhbnNmb3JtU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCB7XG4gIEFib3J0RXJyb3IsXG4gIGNvZGVzOiB7IEVSUl9JTlZBTElEX0FSR19WQUxVRSwgRVJSX01JU1NJTkdfQVJHUyB9XG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcG9zZSguLi5zdHJlYW1zKSB7XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJylcbiAgfVxuICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gRHVwbGV4LmZyb20oc3RyZWFtc1swXSlcbiAgfVxuICBjb25zdCBvcmdTdHJlYW1zID0gWy4uLnN0cmVhbXNdXG4gIGlmICh0eXBlb2Ygc3RyZWFtc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbXNbMF0gPSBEdXBsZXguZnJvbShzdHJlYW1zWzBdKVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgaWR4ID0gc3RyZWFtcy5sZW5ndGggLSAxXG4gICAgc3RyZWFtc1tpZHhdID0gRHVwbGV4LmZyb20oc3RyZWFtc1tpZHhdKVxuICB9XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgc3RyZWFtcy5sZW5ndGg7ICsrbikge1xuICAgIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbXNbbl0pICYmICFpc1dlYlN0cmVhbShzdHJlYW1zW25dKSkge1xuICAgICAgLy8gVE9ETyhyb25hZyk6IEFkZCBjaGVja3MgZm9yIG5vbiBzdHJlYW1zLlxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgbiA8IHN0cmVhbXMubGVuZ3RoIC0gMSAmJlxuICAgICAgIShpc1JlYWRhYmxlKHN0cmVhbXNbbl0pIHx8IGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtc1tuXSkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtc1tuXSkpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKGBzdHJlYW1zWyR7bn1dYCwgb3JnU3RyZWFtc1tuXSwgJ211c3QgYmUgcmVhZGFibGUnKVxuICAgIH1cbiAgICBpZiAobiA+IDAgJiYgIShpc1dyaXRhYmxlKHN0cmVhbXNbbl0pIHx8IGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtc1tuXSkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtc1tuXSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKGBzdHJlYW1zWyR7bn1dYCwgb3JnU3RyZWFtc1tuXSwgJ211c3QgYmUgd3JpdGFibGUnKVxuICAgIH1cbiAgfVxuICBsZXQgb25kcmFpblxuICBsZXQgb25maW5pc2hcbiAgbGV0IG9ucmVhZGFibGVcbiAgbGV0IG9uY2xvc2VcbiAgbGV0IGRcbiAgZnVuY3Rpb24gb25maW5pc2hlZChlcnIpIHtcbiAgICBjb25zdCBjYiA9IG9uY2xvc2VcbiAgICBvbmNsb3NlID0gbnVsbFxuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBkLmRlc3Ryb3koZXJyKVxuICAgIH0gZWxzZSBpZiAoIXJlYWRhYmxlICYmICF3cml0YWJsZSkge1xuICAgICAgZC5kZXN0cm95KClcbiAgICB9XG4gIH1cbiAgY29uc3QgaGVhZCA9IHN0cmVhbXNbMF1cbiAgY29uc3QgdGFpbCA9IHBpcGVsaW5lKHN0cmVhbXMsIG9uZmluaXNoZWQpXG4gIGNvbnN0IHdyaXRhYmxlID0gISEoaXNXcml0YWJsZShoZWFkKSB8fCBpc1dyaXRhYmxlU3RyZWFtKGhlYWQpIHx8IGlzVHJhbnNmb3JtU3RyZWFtKGhlYWQpKVxuICBjb25zdCByZWFkYWJsZSA9ICEhKGlzUmVhZGFibGUodGFpbCkgfHwgaXNSZWFkYWJsZVN0cmVhbSh0YWlsKSB8fCBpc1RyYW5zZm9ybVN0cmVhbSh0YWlsKSlcblxuICAvLyBUT0RPKHJvbmFnKTogQXZvaWQgZG91YmxlIGJ1ZmZlcmluZy5cbiAgLy8gSW1wbGVtZW50IFdyaXRhYmxlL1JlYWRhYmxlL0R1cGxleCB0cmFpdHMuXG4gIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzM1MTUuXG4gIGQgPSBuZXcgRHVwbGV4KHtcbiAgICAvLyBUT0RPIChyb25hZyk6IGhpZ2hXYXRlck1hcms/XG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiAhIShoZWFkICE9PSBudWxsICYmIGhlYWQgIT09IHVuZGVmaW5lZCAmJiBoZWFkLndyaXRhYmxlT2JqZWN0TW9kZSksXG4gICAgcmVhZGFibGVPYmplY3RNb2RlOiAhISh0YWlsICE9PSBudWxsICYmIHRhaWwgIT09IHVuZGVmaW5lZCAmJiB0YWlsLnJlYWRhYmxlT2JqZWN0TW9kZSksXG4gICAgd3JpdGFibGUsXG4gICAgcmVhZGFibGVcbiAgfSlcbiAgaWYgKHdyaXRhYmxlKSB7XG4gICAgaWYgKGlzTm9kZVN0cmVhbShoZWFkKSkge1xuICAgICAgZC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaGVhZC53cml0ZShjaHVuaywgZW5jb2RpbmcpKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uZHJhaW4gPSBjYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkLl9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBoZWFkLmVuZCgpXG4gICAgICAgIG9uZmluaXNoID0gY2FsbGJhY2tcbiAgICAgIH1cbiAgICAgIGhlYWQub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob25kcmFpbikge1xuICAgICAgICAgIGNvbnN0IGNiID0gb25kcmFpblxuICAgICAgICAgIG9uZHJhaW4gPSBudWxsXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoaXNXZWJTdHJlYW0oaGVhZCkpIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlID0gaXNUcmFuc2Zvcm1TdHJlYW0oaGVhZCkgPyBoZWFkLndyaXRhYmxlIDogaGVhZFxuICAgICAgY29uc3Qgd3JpdGVyID0gd3JpdGFibGUuZ2V0V3JpdGVyKClcbiAgICAgIGQuX3dyaXRlID0gYXN5bmMgZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHlcbiAgICAgICAgICB3cml0ZXIud3JpdGUoY2h1bmspLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkLl9maW5hbCA9IGFzeW5jIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgICAgICAgIHdyaXRlci5jbG9zZSgpLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICAgIG9uZmluaXNoID0gY2FsbGJhY2tcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvUmVhZCA9IGlzVHJhbnNmb3JtU3RyZWFtKHRhaWwpID8gdGFpbC5yZWFkYWJsZSA6IHRhaWxcbiAgICBlb3ModG9SZWFkLCAoKSA9PiB7XG4gICAgICBpZiAob25maW5pc2gpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvbmZpbmlzaFxuICAgICAgICBvbmZpbmlzaCA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgaWYgKHJlYWRhYmxlKSB7XG4gICAgaWYgKGlzTm9kZVN0cmVhbSh0YWlsKSkge1xuICAgICAgdGFpbC5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvbnJlYWRhYmxlKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBvbnJlYWRhYmxlXG4gICAgICAgICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0YWlsLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIGQuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gdGFpbC5yZWFkKClcbiAgICAgICAgICBpZiAoYnVmID09PSBudWxsKSB7XG4gICAgICAgICAgICBvbnJlYWRhYmxlID0gZC5fcmVhZFxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZC5wdXNoKGJ1ZikpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNXZWJTdHJlYW0odGFpbCkpIHtcbiAgICAgIGNvbnN0IHJlYWRhYmxlID0gaXNUcmFuc2Zvcm1TdHJlYW0odGFpbCkgPyB0YWlsLnJlYWRhYmxlIDogdGFpbFxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUuZ2V0UmVhZGVyKClcbiAgICAgIGQuX3JlYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgICAgIGlmICghZC5wdXNoKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGQucHVzaChudWxsKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVyciAmJiBvbmNsb3NlICE9PSBudWxsKSB7XG4gICAgICBlcnIgPSBuZXcgQWJvcnRFcnJvcigpXG4gICAgfVxuICAgIG9ucmVhZGFibGUgPSBudWxsXG4gICAgb25kcmFpbiA9IG51bGxcbiAgICBvbmZpbmlzaCA9IG51bGxcbiAgICBpZiAob25jbG9zZSA9PT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbmNsb3NlID0gY2FsbGJhY2tcbiAgICAgIGlmIChpc05vZGVTdHJlYW0odGFpbCkpIHtcbiAgICAgICAgZGVzdHJveWVyKHRhaWwsIGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/compose.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n\nconst {\n  aggregateTwoErrors,\n  codes: { ERR_MULTIPLE_CALLBACK },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst kDestroy = Symbol('kDestroy')\nconst kConstruct = Symbol('kConstruct')\nfunction checkError(err, w, r) {\n  if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n  const r = this._readableState\n  const w = this._writableState\n  // With duplex streams we use the writable side for state.\n  const s = w || r\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb()\n    }\n    return this\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err, w, r)\n  if (w) {\n    w.destroyed = true\n  }\n  if (r) {\n    r.destroyed = true\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy, function (er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb)\n    })\n  } else {\n    _destroy(this, err, cb)\n  }\n  return this\n}\nfunction _destroy(self, err, cb) {\n  let called = false\n  function onDestroy(err) {\n    if (called) {\n      return\n    }\n    called = true\n    const r = self._readableState\n    const w = self._writableState\n    checkError(err, w, r)\n    if (w) {\n      w.closed = true\n    }\n    if (r) {\n      r.closed = true\n    }\n    if (typeof cb === 'function') {\n      cb(err)\n    }\n    if (err) {\n      process.nextTick(emitErrorCloseNT, self, err)\n    } else {\n      process.nextTick(emitCloseNT, self)\n    }\n  }\n  try {\n    self._destroy(err || null, onDestroy)\n  } catch (err) {\n    onDestroy(err)\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err)\n  emitCloseNT(self)\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState\n  const w = self._writableState\n  if (w) {\n    w.closeEmitted = true\n  }\n  if (r) {\n    r.closeEmitted = true\n  }\n  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {\n    self.emit('close')\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState\n  const w = self._writableState\n  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {\n    return\n  }\n  if (w) {\n    w.errorEmitted = true\n  }\n  if (r) {\n    r.errorEmitted = true\n  }\n  self.emit('error', err)\n}\nfunction undestroy() {\n  const r = this._readableState\n  const w = this._writableState\n  if (r) {\n    r.constructed = true\n    r.closed = false\n    r.closeEmitted = false\n    r.destroyed = false\n    r.errored = null\n    r.errorEmitted = false\n    r.reading = false\n    r.ended = r.readable === false\n    r.endEmitted = r.readable === false\n  }\n  if (w) {\n    w.constructed = true\n    w.destroyed = false\n    w.closed = false\n    w.closeEmitted = false\n    w.errored = null\n    w.errorEmitted = false\n    w.finalCalled = false\n    w.prefinished = false\n    w.ended = w.writable === false\n    w.ending = w.writable === false\n    w.finished = w.writable === false\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState\n  const w = stream._writableState\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    return this\n  }\n  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))\n    stream.destroy(err)\n  else if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err)\n    } else {\n      emitErrorNT(stream, err)\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== 'function') {\n    return\n  }\n  const r = stream._readableState\n  const w = stream._writableState\n  if (r) {\n    r.constructed = false\n  }\n  if (w) {\n    w.constructed = false\n  }\n  stream.once(kConstruct, cb)\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return\n  }\n  process.nextTick(constructNT, stream)\n}\nfunction constructNT(stream) {\n  let called = false\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    const r = stream._readableState\n    const w = stream._writableState\n    const s = w || r\n    if (r) {\n      r.constructed = true\n    }\n    if (w) {\n      w.constructed = true\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err)\n    } else if (err) {\n      errorOrDestroy(stream, err, true)\n    } else {\n      process.nextTick(emitConstructNT, stream)\n    }\n  }\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct, err)\n    })\n  } catch (err) {\n    process.nextTick(onConstruct, err)\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct)\n}\nfunction isRequest(stream) {\n  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit('close')\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit('error', err)\n  process.nextTick(emitCloseLegacy, stream)\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError()\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null\n    stream.destroy(err)\n  } else if (isRequest(stream)) {\n    stream.abort()\n  } else if (isRequest(stream.req)) {\n    stream.req.abort()\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err)\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close()\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream, err)\n  } else {\n    process.nextTick(emitCloseLegacy, stream)\n  }\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVTs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsK0dBQW1CO0FBQy9CLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMseUhBQXdCO0FBQ25ELFFBQVEseURBQXlELEVBQUUsbUJBQU8sQ0FBQyxnSEFBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuXG5jb25zdCB7XG4gIGFnZ3JlZ2F0ZVR3b0Vycm9ycyxcbiAgY29kZXM6IHsgRVJSX01VTFRJUExFX0NBTExCQUNLIH0sXG4gIEFib3J0RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IFN5bWJvbCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IGtJc0Rlc3Ryb3llZCwgaXNEZXN0cm95ZWQsIGlzRmluaXNoZWQsIGlzU2VydmVyUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBrRGVzdHJveSA9IFN5bWJvbCgna0Rlc3Ryb3knKVxuY29uc3Qga0NvbnN0cnVjdCA9IFN5bWJvbCgna0NvbnN0cnVjdCcpXG5mdW5jdGlvbiBjaGVja0Vycm9yKGVyciwgdywgcikge1xuICBpZiAoZXJyKSB7XG4gICAgLy8gQXZvaWQgVjggbGVhaywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzQxMDMjaXNzdWVjb21tZW50LTY1MjAwMjM2NFxuICAgIGVyci5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgaWYgKHcgJiYgIXcuZXJyb3JlZCkge1xuICAgICAgdy5lcnJvcmVkID0gZXJyXG4gICAgfVxuICAgIGlmIChyICYmICFyLmVycm9yZWQpIHtcbiAgICAgIHIuZXJyb3JlZCA9IGVyclxuICAgIH1cbiAgfVxufVxuXG4vLyBCYWNrd2FyZHMgY29tcGF0LiBjYigpIGlzIHVuZG9jdW1lbnRlZCBhbmQgdW51c2VkIGluIGNvcmUgYnV0XG4vLyB1bmZvcnR1bmF0ZWx5IG1pZ2h0IGJlIHVzZWQgYnkgbW9kdWxlcy5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICBjb25zdCByID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICAvLyBXaXRoIGR1cGxleCBzdHJlYW1zIHdlIHVzZSB0aGUgd3JpdGFibGUgc2lkZSBmb3Igc3RhdGUuXG4gIGNvbnN0IHMgPSB3IHx8IHJcbiAgaWYgKCh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LmRlc3Ryb3llZCkgfHwgKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIuZGVzdHJveWVkKSkge1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcbiAgY2hlY2tFcnJvcihlcnIsIHcsIHIpXG4gIGlmICh3KSB7XG4gICAgdy5kZXN0cm95ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKHIpIHtcbiAgICByLmRlc3Ryb3llZCA9IHRydWVcbiAgfVxuXG4gIC8vIElmIHN0aWxsIGNvbnN0cnVjdGluZyB0aGVuIGRlZmVyIGNhbGxpbmcgX2Rlc3Ryb3kuXG4gIGlmICghcy5jb25zdHJ1Y3RlZCkge1xuICAgIHRoaXMub25jZShrRGVzdHJveSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICBfZGVzdHJveSh0aGlzLCBhZ2dyZWdhdGVUd29FcnJvcnMoZXIsIGVyciksIGNiKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgX2Rlc3Ryb3kodGhpcywgZXJyLCBjYilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gX2Rlc3Ryb3koc2VsZiwgZXJyLCBjYikge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gb25EZXN0cm95KGVycikge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgY29uc3QgciA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgICBjb25zdCB3ID0gc2VsZi5fd3JpdGFibGVTdGF0ZVxuICAgIGNoZWNrRXJyb3IoZXJyLCB3LCByKVxuICAgIGlmICh3KSB7XG4gICAgICB3LmNsb3NlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgIHIuY2xvc2VkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICAgIGlmIChlcnIpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQ2xvc2VOVCwgc2VsZiwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBzZWxmKVxuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHNlbGYuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIG9uRGVzdHJveSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25EZXN0cm95KGVycilcbiAgfVxufVxuZnVuY3Rpb24gZW1pdEVycm9yQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKVxuICBlbWl0Q2xvc2VOVChzZWxmKVxufVxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBjb25zdCByID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc2VsZi5fd3JpdGFibGVTdGF0ZVxuICBpZiAodykge1xuICAgIHcuY2xvc2VFbWl0dGVkID0gdHJ1ZVxuICB9XG4gIGlmIChyKSB7XG4gICAgci5jbG9zZUVtaXR0ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKCh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LmVtaXRDbG9zZSkgfHwgKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIuZW1pdENsb3NlKSkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgY29uc3QgciA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHNlbGYuX3dyaXRhYmxlU3RhdGVcbiAgaWYgKCh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LmVycm9yRW1pdHRlZCkgfHwgKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIuZXJyb3JFbWl0dGVkKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh3KSB7XG4gICAgdy5lcnJvckVtaXR0ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKHIpIHtcbiAgICByLmVycm9yRW1pdHRlZCA9IHRydWVcbiAgfVxuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxufVxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBjb25zdCByID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBpZiAocikge1xuICAgIHIuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgci5jbG9zZWQgPSBmYWxzZVxuICAgIHIuY2xvc2VFbWl0dGVkID0gZmFsc2VcbiAgICByLmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgci5lcnJvcmVkID0gbnVsbFxuICAgIHIuZXJyb3JFbWl0dGVkID0gZmFsc2VcbiAgICByLnJlYWRpbmcgPSBmYWxzZVxuICAgIHIuZW5kZWQgPSByLnJlYWRhYmxlID09PSBmYWxzZVxuICAgIHIuZW5kRW1pdHRlZCA9IHIucmVhZGFibGUgPT09IGZhbHNlXG4gIH1cbiAgaWYgKHcpIHtcbiAgICB3LmNvbnN0cnVjdGVkID0gdHJ1ZVxuICAgIHcuZGVzdHJveWVkID0gZmFsc2VcbiAgICB3LmNsb3NlZCA9IGZhbHNlXG4gICAgdy5jbG9zZUVtaXR0ZWQgPSBmYWxzZVxuICAgIHcuZXJyb3JlZCA9IG51bGxcbiAgICB3LmVycm9yRW1pdHRlZCA9IGZhbHNlXG4gICAgdy5maW5hbENhbGxlZCA9IGZhbHNlXG4gICAgdy5wcmVmaW5pc2hlZCA9IGZhbHNlXG4gICAgdy5lbmRlZCA9IHcud3JpdGFibGUgPT09IGZhbHNlXG4gICAgdy5lbmRpbmcgPSB3LndyaXRhYmxlID09PSBmYWxzZVxuICAgIHcuZmluaXNoZWQgPSB3LndyaXRhYmxlID09PSBmYWxzZVxuICB9XG59XG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciwgc3luYykge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuXG4gIGNvbnN0IHIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZGVzdHJveWVkKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5kZXN0cm95ZWQpKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAoKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIuYXV0b0Rlc3Ryb3kpIHx8ICh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LmF1dG9EZXN0cm95KSlcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIGVsc2UgaWYgKGVycikge1xuICAgIC8vIEF2b2lkIFY4IGxlYWssIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM0MTAzI2lzc3VlY29tbWVudC02NTIwMDIzNjRcbiAgICBlcnIuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIGlmICh3ICYmICF3LmVycm9yZWQpIHtcbiAgICAgIHcuZXJyb3JlZCA9IGVyclxuICAgIH1cbiAgICBpZiAociAmJiAhci5lcnJvcmVkKSB7XG4gICAgICByLmVycm9yZWQgPSBlcnJcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHN0cmVhbSwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0RXJyb3JOVChzdHJlYW0sIGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdChzdHJlYW0sIGNiKSB7XG4gIGlmICh0eXBlb2Ygc3RyZWFtLl9jb25zdHJ1Y3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCByID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHIpIHtcbiAgICByLmNvbnN0cnVjdGVkID0gZmFsc2VcbiAgfVxuICBpZiAodykge1xuICAgIHcuY29uc3RydWN0ZWQgPSBmYWxzZVxuICB9XG4gIHN0cmVhbS5vbmNlKGtDb25zdHJ1Y3QsIGNiKVxuICBpZiAoc3RyZWFtLmxpc3RlbmVyQ291bnQoa0NvbnN0cnVjdCkgPiAxKSB7XG4gICAgLy8gRHVwbGV4XG4gICAgcmV0dXJuXG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhjb25zdHJ1Y3ROVCwgc3RyZWFtKVxufVxuZnVuY3Rpb24gY29uc3RydWN0TlQoc3RyZWFtKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbkNvbnN0cnVjdChlcnIpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCA/IGVyciA6IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgY29uc3QgciA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICAgIGNvbnN0IHcgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgICBjb25zdCBzID0gdyB8fCByXG4gICAgaWYgKHIpIHtcbiAgICAgIHIuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmICh3KSB7XG4gICAgICB3LmNvbnN0cnVjdGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAocy5kZXN0cm95ZWQpIHtcbiAgICAgIHN0cmVhbS5lbWl0KGtEZXN0cm95LCBlcnIpXG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDb25zdHJ1Y3ROVCwgc3RyZWFtKVxuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHN0cmVhbS5fY29uc3RydWN0KChlcnIpID0+IHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sob25Db25zdHJ1Y3QsIGVycilcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uQ29uc3RydWN0LCBlcnIpXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRDb25zdHJ1Y3ROVChzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoa0NvbnN0cnVjdClcbn1cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIChzdHJlYW0gPT09IG51bGwgfHwgc3RyZWFtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzdHJlYW0uc2V0SGVhZGVyKSAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nXG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VMZWdhY3koc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpXG59XG5mdW5jdGlvbiBlbWl0RXJyb3JDbG9zZUxlZ2FjeShzdHJlYW0sIGVycikge1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTGVnYWN5LCBzdHJlYW0pXG59XG5cbi8vIE5vcm1hbGl6ZSBkZXN0cm95IGZvciBsZWdhY3kuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCBlcnIpIHtcbiAgaWYgKCFzdHJlYW0gfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghZXJyICYmICFpc0ZpbmlzaGVkKHN0cmVhbSkpIHtcbiAgICBlcnIgPSBuZXcgQWJvcnRFcnJvcigpXG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgaXNSZXF1ZXN0IGJyYW5jaGVzLlxuICBpZiAoaXNTZXJ2ZXJSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5hYm9ydCgpXG4gIH0gZWxzZSBpZiAoaXNSZXF1ZXN0KHN0cmVhbS5yZXEpKSB7XG4gICAgc3RyZWFtLnJlcS5hYm9ydCgpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPOiBEb24ndCBsb3NlIGVycj9cbiAgICBzdHJlYW0uY2xvc2UoKVxuICB9IGVsc2UgaWYgKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQ2xvc2VMZWdhY3ksIHN0cmVhbSwgZXJyKVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTGVnYWN5LCBzdHJlYW0pXG4gIH1cbiAgaWYgKCFzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgc3RyZWFtW2tJc0Rlc3Ryb3llZF0gPSB0cnVlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdHJ1Y3QsXG4gIGRlc3Ryb3llcixcbiAgZGVzdHJveSxcbiAgdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\n\n\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Duplex\nconst Readable = __webpack_require__(/*! ./readable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js\")\nconst Writable = __webpack_require__(/*! ./writable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js\")\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)\nObjectSetPrototypeOf(Duplex, Readable)\n{\n  const keys = ObjectKeys(Writable.prototype)\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i]\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options)\n  Readable.call(this, options)\n  Writable.call(this, options)\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false\n    if (options.readable === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  } else {\n    this.allowHalfOpen = true\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')\n  },\n  writableObjectMode: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')\n  },\n  writableBuffer: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')\n  },\n  writableLength: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')\n  },\n  writableFinished: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')\n  },\n  writableCorked: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')\n  },\n  writableEnded: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false\n      }\n      return this._readableState.destroyed && this._writableState.destroyed\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value\n        this._writableState.destroyed = value\n      }\n    }\n  }\n})\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nDuplex.fromWeb = function (pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)\n}\nDuplex.toWeb = function (duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)\n}\nlet duplexify\nDuplex.from = function (body) {\n  if (!duplexify) {\n    duplexify = __webpack_require__(/*! ./duplexify */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplexify.js\")\n  }\n  return duplexify(body, 'body')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZHVwbGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUNwQztBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFZO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0hBQWE7QUFDckM7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZHVwbGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwZSBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBpY2FsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBPYmplY3RLZXlzLFxuICBPYmplY3RTZXRQcm90b3R5cGVPZlxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXhcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoRHVwbGV4LnByb3RvdHlwZSwgUmVhZGFibGUucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoRHVwbGV4LCBSZWFkYWJsZSlcbntcbiAgY29uc3Qga2V5cyA9IE9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKVxuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0aG9kID0ga2V5c1tpXVxuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXVxuICB9XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucylcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKVxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gb3B0aW9ucy5hbGxvd0hhbGZPcGVuICE9PSBmYWxzZVxuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUud3JpdGFibGUgPSBmYWxzZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSB0cnVlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZVxuICB9XG59XG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKER1cGxleC5wcm90b3R5cGUsIHtcbiAgd3JpdGFibGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlJylcbiAgfSxcbiAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnKVxuICB9LFxuICB3cml0YWJsZU9iamVjdE1vZGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlT2JqZWN0TW9kZScpXG4gIH0sXG4gIHdyaXRhYmxlQnVmZmVyOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicpXG4gIH0sXG4gIHdyaXRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcpXG4gIH0sXG4gIHdyaXRhYmxlRmluaXNoZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlRmluaXNoZWQnKVxuICB9LFxuICB3cml0YWJsZUNvcmtlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVDb3JrZWQnKVxuICB9LFxuICB3cml0YWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUVuZGVkJylcbiAgfSxcbiAgd3JpdGFibGVOZWVkRHJhaW46IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTmVlZERyYWluJylcbiAgfSxcbiAgZGVzdHJveWVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZC5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZVxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cbkR1cGxleC5mcm9tV2ViID0gZnVuY3Rpb24gKHBhaXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtRHVwbGV4RnJvbVJlYWRhYmxlV3JpdGFibGVQYWlyKHBhaXIsIG9wdGlvbnMpXG59XG5EdXBsZXgudG9XZWIgPSBmdW5jdGlvbiAoZHVwbGV4KSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1JlYWRhYmxlV3JpdGFibGVQYWlyRnJvbUR1cGxleChkdXBsZXgpXG59XG5sZXQgZHVwbGV4aWZ5XG5EdXBsZXguZnJvbSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIGlmICghZHVwbGV4aWZ5KSB7XG4gICAgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnLi9kdXBsZXhpZnknKVxuICB9XG4gIHJldHVybiBkdXBsZXhpZnkoYm9keSwgJ2JvZHknKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplexify.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplexify.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n\n;('use strict')\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\")\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst Readable = __webpack_require__(/*! ./readable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js\")\nconst Writable = __webpack_require__(/*! ./writable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js\")\nconst { createDeferredPromise } = __webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst from = __webpack_require__(/*! ./from */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/from.js\")\nconst Blob = globalThis.Blob || bufferModule.Blob\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(rsc)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst { FunctionPrototypeCall } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options)\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    })\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    })\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    })\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    })\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    })\n  }\n  if (typeof body === 'function') {\n    const { value, write, final, destroy } = fromAsyncGen(body)\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      })\n    }\n    const then = value === null || value === undefined ? undefined : value.then\n    if (typeof then === 'function') {\n      let d\n      const promise = FunctionPrototypeCall(\n        then,\n        value,\n        (val) => {\n          if (val != null) {\n            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)\n          }\n        },\n        (err) => {\n          destroyer(d, err)\n        }\n      )\n      return (d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise\n              process.nextTick(cb, null)\n            } catch (err) {\n              process.nextTick(cb, err)\n            }\n          })\n        },\n        destroy\n      }))\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer())\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    })\n  }\n  if (\n    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&\n    isWritableStream(body === null || body === undefined ? undefined : body.writable)\n  ) {\n    return Duplexify.fromWeb(body)\n  }\n  if (\n    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||\n    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'\n  ) {\n    const readable =\n      body !== null && body !== undefined && body.readable\n        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.readable\n          : duplexify(body.readable)\n        : undefined\n    const writable =\n      body !== null && body !== undefined && body.writable\n        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.writable\n          : duplexify(body.writable)\n        : undefined\n    return _duplexify({\n      readable,\n      writable\n    })\n  }\n  const then = body === null || body === undefined ? undefined : body.then\n  if (typeof then === 'function') {\n    let d\n    FunctionPrototypeCall(\n      then,\n      body,\n      (val) => {\n        if (val != null) {\n          d.push(val)\n        }\n        d.push(null)\n      },\n      (err) => {\n        destroyer(d, err)\n      }\n    )\n    return (d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    }))\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    [\n      'Blob',\n      'ReadableStream',\n      'WritableStream',\n      'Stream',\n      'Iterable',\n      'AsyncIterable',\n      'Function',\n      '{ readable, writable } pair',\n      'Promise'\n    ],\n    body\n  )\n}\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise()\n  const ac = new AbortController()\n  const signal = ac.signal\n  const value = fn(\n    (async function* () {\n      while (true) {\n        const _promise = promise\n        promise = null\n        const { chunk, done, cb } = await _promise\n        process.nextTick(cb)\n        if (done) return\n        if (signal.aborted)\n          throw new AbortError(undefined, {\n            cause: signal.reason\n          })\n        ;({ promise, resolve } = createDeferredPromise())\n        yield chunk\n      }\n    })(),\n    {\n      signal\n    }\n  )\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      })\n    },\n    final(cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        done: true,\n        cb\n      })\n    },\n    destroy(err, cb) {\n      ac.abort()\n      cb(err)\n    }\n  }\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable\n  const w = pair.writable\n  let readable = !!isReadable(r)\n  let writable = !!isWritable(w)\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  })\n  if (writable) {\n    eos(w, (err) => {\n      writable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback()\n      } else {\n        ondrain = callback\n      }\n    }\n    d._final = function (callback) {\n      w.end()\n      onfinish = callback\n    }\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb()\n      }\n    })\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable\n        onreadable = null\n        cb()\n      }\n    })\n    r.on('end', function () {\n      d.push(null)\n    })\n    d._read = function () {\n      while (true) {\n        const buf = r.read()\n        if (buf === null) {\n          onreadable = d._read\n          return\n        }\n        if (!d.push(buf)) {\n          return\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      destroyer(w, err)\n      destroyer(r, err)\n    }\n  }\n  return d\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZHVwbGV4aWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFVOztBQUVsQzs7QUFFQSxDQUFDO0FBQ0QscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxnSEFBUztBQUNyQixZQUFZLG1CQUFPLENBQUMsZ0lBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsRUFBRSxFQUFFLG1CQUFPLENBQUMsK0dBQW1CO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsb0hBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtIQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFZO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLHNIQUFZO0FBQ3JDLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQywyR0FBaUI7QUFDM0QsYUFBYSxtQkFBTyxDQUFDLDhHQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnSUFBMkM7QUFDakcsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLHlIQUF3Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVMsR0FBRyxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXhpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3QgYnVmZmVyTW9kdWxlID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHtcbiAgaXNSZWFkYWJsZSxcbiAgaXNXcml0YWJsZSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlTm9kZVN0cmVhbSxcbiAgaXNXcml0YWJsZU5vZGVTdHJlYW0sXG4gIGlzRHVwbGV4Tm9kZVN0cmVhbSxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNXcml0YWJsZVN0cmVhbVxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IHtcbiAgQWJvcnRFcnJvcixcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSB9XG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyBkZXN0cm95ZXIgfSA9IHJlcXVpcmUoJy4vZGVzdHJveScpXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3QgV3JpdGFibGUgPSByZXF1aXJlKCcuL3dyaXRhYmxlJylcbmNvbnN0IHsgY3JlYXRlRGVmZXJyZWRQcm9taXNlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxuY29uc3QgZnJvbSA9IHJlcXVpcmUoJy4vZnJvbScpXG5jb25zdCBCbG9iID0gZ2xvYmFsVGhpcy5CbG9iIHx8IGJ1ZmZlck1vZHVsZS5CbG9iXG5jb25zdCBpc0Jsb2IgPVxuICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGZ1bmN0aW9uIGlzQmxvYihiKSB7XG4gICAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgQmxvYlxuICAgICAgfVxuICAgIDogZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCByZXF1aXJlKCdhYm9ydC1jb250cm9sbGVyJykuQWJvcnRDb250cm9sbGVyXG5jb25zdCB7IEZ1bmN0aW9uUHJvdG90eXBlQ2FsbCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5cbi8vIFRoaXMgaXMgbmVlZGVkIGZvciBwcmUgbm9kZSAxNy5cbmNsYXNzIER1cGxleGlmeSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzQzODVcblxuICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnJlYWRhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGFibGUgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMud3JpdGFibGUpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSB0cnVlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkdXBsZXhpZnkoYm9keSwgbmFtZSkge1xuICBpZiAoaXNEdXBsZXhOb2RlU3RyZWFtKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHlcbiAgfVxuICBpZiAoaXNSZWFkYWJsZU5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICByZWFkYWJsZTogYm9keVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzV3JpdGFibGVOb2RlU3RyZWFtKGJvZHkpKSB7XG4gICAgcmV0dXJuIF9kdXBsZXhpZnkoe1xuICAgICAgd3JpdGFibGU6IGJvZHlcbiAgICB9KVxuICB9XG4gIGlmIChpc05vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICByZWFkYWJsZTogZmFsc2VcbiAgICB9KVxuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGJvZHkpKSB7XG4gICAgcmV0dXJuIF9kdXBsZXhpZnkoe1xuICAgICAgcmVhZGFibGU6IFJlYWRhYmxlLmZyb21XZWIoYm9keSlcbiAgICB9KVxuICB9XG4gIGlmIChpc1dyaXRhYmxlU3RyZWFtKGJvZHkpKSB7XG4gICAgcmV0dXJuIF9kdXBsZXhpZnkoe1xuICAgICAgd3JpdGFibGU6IFdyaXRhYmxlLmZyb21XZWIoYm9keSlcbiAgICB9KVxuICB9XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHsgdmFsdWUsIHdyaXRlLCBmaW5hbCwgZGVzdHJveSB9ID0gZnJvbUFzeW5jR2VuKGJvZHkpXG4gICAgaWYgKGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZnJvbShEdXBsZXhpZnksIHZhbHVlLCB7XG4gICAgICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgd3JpdGUsXG4gICAgICAgIGZpbmFsLFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KVxuICAgIH1cbiAgICBjb25zdCB0aGVuID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHZhbHVlLnRoZW5cbiAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxldCBkXG4gICAgICBjb25zdCBwcm9taXNlID0gRnVuY3Rpb25Qcm90b3R5cGVDYWxsKFxuICAgICAgICB0aGVuLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgKHZhbCkgPT4ge1xuICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnbnVsbHknLCAnYm9keScsIHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBkZXN0cm95ZXIoZCwgZXJyKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICByZXR1cm4gKGQgPSBuZXcgRHVwbGV4aWZ5KHtcbiAgICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICByZWFkYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRlLFxuICAgICAgICBmaW5hbChjYikge1xuICAgICAgICAgIGZpbmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb21pc2VcbiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfSkpXG4gICAgfVxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ0l0ZXJhYmxlLCBBc3luY0l0ZXJhYmxlIG9yIEFzeW5jRnVuY3Rpb24nLCBuYW1lLCB2YWx1ZSlcbiAgfVxuICBpZiAoaXNCbG9iKGJvZHkpKSB7XG4gICAgcmV0dXJuIGR1cGxleGlmeShib2R5LmFycmF5QnVmZmVyKCkpXG4gIH1cbiAgaWYgKGlzSXRlcmFibGUoYm9keSkpIHtcbiAgICByZXR1cm4gZnJvbShEdXBsZXhpZnksIGJvZHksIHtcbiAgICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KVxuICB9XG4gIGlmIChcbiAgICBpc1JlYWRhYmxlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS5yZWFkYWJsZSkgJiZcbiAgICBpc1dyaXRhYmxlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS53cml0YWJsZSlcbiAgKSB7XG4gICAgcmV0dXJuIER1cGxleGlmeS5mcm9tV2ViKGJvZHkpXG4gIH1cbiAgaWYgKFxuICAgIHR5cGVvZiAoYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKSA9PT0gJ29iamVjdCcgfHxcbiAgICB0eXBlb2YgKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS5yZWFkYWJsZSkgPT09ICdvYmplY3QnXG4gICkge1xuICAgIGNvbnN0IHJlYWRhYmxlID1cbiAgICAgIGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdW5kZWZpbmVkICYmIGJvZHkucmVhZGFibGVcbiAgICAgICAgPyBpc1JlYWRhYmxlTm9kZVN0cmVhbShib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkucmVhZGFibGUpXG4gICAgICAgICAgPyBib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogYm9keS5yZWFkYWJsZVxuICAgICAgICAgIDogZHVwbGV4aWZ5KGJvZHkucmVhZGFibGUpXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgY29uc3Qgd3JpdGFibGUgPVxuICAgICAgYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQgJiYgYm9keS53cml0YWJsZVxuICAgICAgICA/IGlzV3JpdGFibGVOb2RlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS53cml0YWJsZSlcbiAgICAgICAgICA/IGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBib2R5LndyaXRhYmxlXG4gICAgICAgICAgOiBkdXBsZXhpZnkoYm9keS53cml0YWJsZSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICByZWFkYWJsZSxcbiAgICAgIHdyaXRhYmxlXG4gICAgfSlcbiAgfVxuICBjb25zdCB0aGVuID0gYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnRoZW5cbiAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGV0IGRcbiAgICBGdW5jdGlvblByb3RvdHlwZUNhbGwoXG4gICAgICB0aGVuLFxuICAgICAgYm9keSxcbiAgICAgICh2YWwpID0+IHtcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgZC5wdXNoKHZhbClcbiAgICAgICAgfVxuICAgICAgICBkLnB1c2gobnVsbClcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIGRlc3Ryb3llcihkLCBlcnIpXG4gICAgICB9XG4gICAgKVxuICAgIHJldHVybiAoZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHJlYWQoKSB7fVxuICAgIH0pKVxuICB9XG4gIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICBuYW1lLFxuICAgIFtcbiAgICAgICdCbG9iJyxcbiAgICAgICdSZWFkYWJsZVN0cmVhbScsXG4gICAgICAnV3JpdGFibGVTdHJlYW0nLFxuICAgICAgJ1N0cmVhbScsXG4gICAgICAnSXRlcmFibGUnLFxuICAgICAgJ0FzeW5jSXRlcmFibGUnLFxuICAgICAgJ0Z1bmN0aW9uJyxcbiAgICAgICd7IHJlYWRhYmxlLCB3cml0YWJsZSB9IHBhaXInLFxuICAgICAgJ1Byb21pc2UnXG4gICAgXSxcbiAgICBib2R5XG4gIClcbn1cbmZ1bmN0aW9uIGZyb21Bc3luY0dlbihmbikge1xuICBsZXQgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBzaWduYWwgPSBhYy5zaWduYWxcbiAgY29uc3QgdmFsdWUgPSBmbihcbiAgICAoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IF9wcm9taXNlID0gcHJvbWlzZVxuICAgICAgICBwcm9taXNlID0gbnVsbFxuICAgICAgICBjb25zdCB7IGNodW5rLCBkb25lLCBjYiB9ID0gYXdhaXQgX3Byb21pc2VcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICAgICAgaWYgKGRvbmUpIHJldHVyblxuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgIH0pXG4gICAgICAgIDsoeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKSlcbiAgICAgICAgeWllbGQgY2h1bmtcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIHtcbiAgICAgIHNpZ25hbFxuICAgIH1cbiAgKVxuICByZXR1cm4ge1xuICAgIHZhbHVlLFxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgcmVzb2x2ZSA9IG51bGxcbiAgICAgIF9yZXNvbHZlKHtcbiAgICAgICAgY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICBjYlxuICAgICAgfSlcbiAgICB9LFxuICAgIGZpbmFsKGNiKSB7XG4gICAgICBjb25zdCBfcmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIHJlc29sdmUgPSBudWxsXG4gICAgICBfcmVzb2x2ZSh7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIGNiXG4gICAgICB9KVxuICAgIH0sXG4gICAgZGVzdHJveShlcnIsIGNiKSB7XG4gICAgICBhYy5hYm9ydCgpXG4gICAgICBjYihlcnIpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZHVwbGV4aWZ5KHBhaXIpIHtcbiAgY29uc3QgciA9IHBhaXIucmVhZGFibGUgJiYgdHlwZW9mIHBhaXIucmVhZGFibGUucmVhZCAhPT0gJ2Z1bmN0aW9uJyA/IFJlYWRhYmxlLndyYXAocGFpci5yZWFkYWJsZSkgOiBwYWlyLnJlYWRhYmxlXG4gIGNvbnN0IHcgPSBwYWlyLndyaXRhYmxlXG4gIGxldCByZWFkYWJsZSA9ICEhaXNSZWFkYWJsZShyKVxuICBsZXQgd3JpdGFibGUgPSAhIWlzV3JpdGFibGUodylcbiAgbGV0IG9uZHJhaW5cbiAgbGV0IG9uZmluaXNoXG4gIGxldCBvbnJlYWRhYmxlXG4gIGxldCBvbmNsb3NlXG4gIGxldCBkXG4gIGZ1bmN0aW9uIG9uZmluaXNoZWQoZXJyKSB7XG4gICAgY29uc3QgY2IgPSBvbmNsb3NlXG4gICAgb25jbG9zZSA9IG51bGxcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgZC5kZXN0cm95KGVycilcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPKHJvbmFnKTogQXZvaWQgZG91YmxlIGJ1ZmZlcmluZy5cbiAgLy8gSW1wbGVtZW50IFdyaXRhYmxlL1JlYWRhYmxlL0R1cGxleCB0cmFpdHMuXG4gIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzM1MTUuXG4gIGQgPSBuZXcgRHVwbGV4aWZ5KHtcbiAgICAvLyBUT0RPIChyb25hZyk6IGhpZ2hXYXRlck1hcms/XG4gICAgcmVhZGFibGVPYmplY3RNb2RlOiAhIShyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLnJlYWRhYmxlT2JqZWN0TW9kZSksXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiAhISh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LndyaXRhYmxlT2JqZWN0TW9kZSksXG4gICAgcmVhZGFibGUsXG4gICAgd3JpdGFibGVcbiAgfSlcbiAgaWYgKHdyaXRhYmxlKSB7XG4gICAgZW9zKHcsIChlcnIpID0+IHtcbiAgICAgIHdyaXRhYmxlID0gZmFsc2VcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVzdHJveWVyKHIsIGVycilcbiAgICAgIH1cbiAgICAgIG9uZmluaXNoZWQoZXJyKVxuICAgIH0pXG4gICAgZC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHcud3JpdGUoY2h1bmssIGVuY29kaW5nKSkge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbmRyYWluID0gY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gICAgZC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHcuZW5kKClcbiAgICAgIG9uZmluaXNoID0gY2FsbGJhY2tcbiAgICB9XG4gICAgdy5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25kcmFpbikge1xuICAgICAgICBjb25zdCBjYiA9IG9uZHJhaW5cbiAgICAgICAgb25kcmFpbiA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdy5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9uZmluaXNoKSB7XG4gICAgICAgIGNvbnN0IGNiID0gb25maW5pc2hcbiAgICAgICAgb25maW5pc2ggPSBudWxsXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChyZWFkYWJsZSkge1xuICAgIGVvcyhyLCAoZXJyKSA9PiB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlc3Ryb3llcihyLCBlcnIpXG4gICAgICB9XG4gICAgICBvbmZpbmlzaGVkKGVycilcbiAgICB9KVxuICAgIHIub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9ucmVhZGFibGUpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvbnJlYWRhYmxlXG4gICAgICAgIG9ucmVhZGFibGUgPSBudWxsXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGQucHVzaChudWxsKVxuICAgIH0pXG4gICAgZC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHIucmVhZCgpXG4gICAgICAgIGlmIChidWYgPT09IG51bGwpIHtcbiAgICAgICAgICBvbnJlYWRhYmxlID0gZC5fcmVhZFxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICghZC5wdXNoKGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVyciAmJiBvbmNsb3NlICE9PSBudWxsKSB7XG4gICAgICBlcnIgPSBuZXcgQWJvcnRFcnJvcigpXG4gICAgfVxuICAgIG9ucmVhZGFibGUgPSBudWxsXG4gICAgb25kcmFpbiA9IG51bGxcbiAgICBvbmZpbmlzaCA9IG51bGxcbiAgICBpZiAob25jbG9zZSA9PT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbmNsb3NlID0gY2FsbGJhY2tcbiAgICAgIGRlc3Ryb3llcih3LCBlcnIpXG4gICAgICBkZXN0cm95ZXIociwgZXJyKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplexify.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = __webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = __webpack_require__(/*! ../validators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\")\nconst { Promise, PromisePrototypeThen, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVTs7QUFFbEM7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsK0dBQW1CO0FBQ3pELFFBQVEsbURBQW1EO0FBQzNELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQywyR0FBaUI7QUFDeEQsUUFBUSx5RUFBeUUsRUFBRSxtQkFBTyxDQUFDLG1IQUFlO0FBQzFHLFFBQVEsK0NBQStDLEVBQUUsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0hBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QyxtSkFBMkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QyxtSkFBMkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG4vLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3QgeyBBYm9ydEVycm9yLCBjb2RlcyB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgfSA9IGNvZGVzXG5jb25zdCB7IGtFbXB0eU9iamVjdCwgb25jZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbmNvbnN0IHsgdmFsaWRhdGVBYm9ydFNpZ25hbCwgdmFsaWRhdGVGdW5jdGlvbiwgdmFsaWRhdGVPYmplY3QsIHZhbGlkYXRlQm9vbGVhbiB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCB7IFByb21pc2UsIFByb21pc2VQcm90b3R5cGVUaGVuLCBTeW1ib2xEaXNwb3NlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHtcbiAgaXNDbG9zZWQsXG4gIGlzUmVhZGFibGUsXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlYWRhYmxlRmluaXNoZWQsXG4gIGlzUmVhZGFibGVFcnJvcmVkLFxuICBpc1dyaXRhYmxlLFxuICBpc1dyaXRhYmxlTm9kZVN0cmVhbSxcbiAgaXNXcml0YWJsZVN0cmVhbSxcbiAgaXNXcml0YWJsZUZpbmlzaGVkLFxuICBpc1dyaXRhYmxlRXJyb3JlZCxcbiAgaXNOb2RlU3RyZWFtLFxuICB3aWxsRW1pdENsb3NlOiBfd2lsbEVtaXRDbG9zZSxcbiAga0lzQ2xvc2VkUHJvbWlzZVxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxubGV0IGFkZEFib3J0TGlzdGVuZXJcbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJ1xufVxuY29uc3Qgbm9wID0gKCkgPT4ge31cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBfb3B0aW9ucyRyZWFkYWJsZSwgX29wdGlvbnMkd3JpdGFibGVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ga0VtcHR5T2JqZWN0XG4gIH0gZWxzZSBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IGtFbXB0eU9iamVjdFxuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICB2YWxpZGF0ZUZ1bmN0aW9uKGNhbGxiYWNrLCAnY2FsbGJhY2snKVxuICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkgfHwgaXNXcml0YWJsZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIGVvc1dlYihzdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrKVxuICB9XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3N0cmVhbScsIFsnUmVhZGFibGVTdHJlYW0nLCAnV3JpdGFibGVTdHJlYW0nLCAnU3RyZWFtJ10sIHN0cmVhbSlcbiAgfVxuICBjb25zdCByZWFkYWJsZSA9XG4gICAgKF9vcHRpb25zJHJlYWRhYmxlID0gb3B0aW9ucy5yZWFkYWJsZSkgIT09IG51bGwgJiYgX29wdGlvbnMkcmVhZGFibGUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfb3B0aW9ucyRyZWFkYWJsZVxuICAgICAgOiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pXG4gIGNvbnN0IHdyaXRhYmxlID1cbiAgICAoX29wdGlvbnMkd3JpdGFibGUgPSBvcHRpb25zLndyaXRhYmxlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyR3cml0YWJsZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IF9vcHRpb25zJHdyaXRhYmxlXG4gICAgICA6IGlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSlcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCBvbmxlZ2FjeWZpbmlzaCA9ICgpID0+IHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkge1xuICAgICAgb25maW5pc2goKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8gKHJvbmFnKTogSW1wcm92ZSBzb2Z0IGRldGVjdGlvbiB0byBpbmNsdWRlIGNvcmUgbW9kdWxlcyBhbmRcbiAgLy8gY29tbW9uIGVjb3N5c3RlbSBtb2R1bGVzIHRoYXQgZG8gcHJvcGVybHkgZW1pdCAnY2xvc2UnIGJ1dCBmYWlsXG4gIC8vIHRoaXMgZ2VuZXJpYyBjaGVjay5cbiAgbGV0IHdpbGxFbWl0Q2xvc2UgPVxuICAgIF93aWxsRW1pdENsb3NlKHN0cmVhbSkgJiYgaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKSA9PT0gcmVhZGFibGUgJiYgaXNXcml0YWJsZU5vZGVTdHJlYW0oc3RyZWFtKSA9PT0gd3JpdGFibGVcbiAgbGV0IHdyaXRhYmxlRmluaXNoZWQgPSBpc1dyaXRhYmxlRmluaXNoZWQoc3RyZWFtLCBmYWxzZSlcbiAgY29uc3Qgb25maW5pc2ggPSAoKSA9PiB7XG4gICAgd3JpdGFibGVGaW5pc2hlZCA9IHRydWVcbiAgICAvLyBTdHJlYW0gc2hvdWxkIG5vdCBiZSBkZXN0cm95ZWQgaGVyZS4gSWYgaXQgaXMgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgdXNlciBzcGFjZSBpcyBkb2luZyBzb21ldGhpbmcgZGlmZmVyZW50bHkgYW5kXG4gICAgLy8gd2UgY2Fubm90IHRydXN0IHdpbGxFbWl0Q2xvc2UuXG4gICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgIHdpbGxFbWl0Q2xvc2UgPSBmYWxzZVxuICAgIH1cbiAgICBpZiAod2lsbEVtaXRDbG9zZSAmJiAoIXN0cmVhbS5yZWFkYWJsZSB8fCByZWFkYWJsZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXJlYWRhYmxlIHx8IHJlYWRhYmxlRmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKVxuICAgIH1cbiAgfVxuICBsZXQgcmVhZGFibGVGaW5pc2hlZCA9IGlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKVxuICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICByZWFkYWJsZUZpbmlzaGVkID0gdHJ1ZVxuICAgIC8vIFN0cmVhbSBzaG91bGQgbm90IGJlIGRlc3Ryb3llZCBoZXJlLiBJZiBpdCBpcyB0aGF0XG4gICAgLy8gbWVhbnMgdGhhdCB1c2VyIHNwYWNlIGlzIGRvaW5nIHNvbWV0aGluZyBkaWZmZXJlbnRseSBhbmRcbiAgICAvLyB3ZSBjYW5ub3QgdHJ1c3Qgd2lsbEVtaXRDbG9zZS5cbiAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgd2lsbEVtaXRDbG9zZSA9IGZhbHNlXG4gICAgfVxuICAgIGlmICh3aWxsRW1pdENsb3NlICYmICghc3RyZWFtLndyaXRhYmxlIHx8IHdyaXRhYmxlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghd3JpdGFibGUgfHwgd3JpdGFibGVGaW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycilcbiAgfVxuICBsZXQgY2xvc2VkID0gaXNDbG9zZWQoc3RyZWFtKVxuICBjb25zdCBvbmNsb3NlID0gKCkgPT4ge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjb25zdCBlcnJvcmVkID0gaXNXcml0YWJsZUVycm9yZWQoc3RyZWFtKSB8fCBpc1JlYWRhYmxlRXJyb3JlZChzdHJlYW0pXG4gICAgaWYgKGVycm9yZWQgJiYgdHlwZW9mIGVycm9yZWQgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnJvcmVkKVxuICAgIH1cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRmluaXNoZWQgJiYgaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtLCB0cnVlKSkge1xuICAgICAgaWYgKCFpc1JlYWRhYmxlRmluaXNoZWQoc3RyZWFtLCBmYWxzZSkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCkpXG4gICAgfVxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVGaW5pc2hlZCkge1xuICAgICAgaWYgKCFpc1dyaXRhYmxlRmluaXNoZWQoc3RyZWFtLCBmYWxzZSkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCkpXG4gICAgfVxuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKVxuICB9XG4gIGNvbnN0IG9uY2xvc2VkID0gKCkgPT4ge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjb25zdCBlcnJvcmVkID0gaXNXcml0YWJsZUVycm9yZWQoc3RyZWFtKSB8fCBpc1JlYWRhYmxlRXJyb3JlZChzdHJlYW0pXG4gICAgaWYgKGVycm9yZWQgJiYgdHlwZW9mIGVycm9yZWQgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnJvcmVkKVxuICAgIH1cbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSlcbiAgfVxuICBjb25zdCBvbnJlcXVlc3QgPSAoKSA9PiB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpXG4gIH1cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKVxuICAgIGlmICghd2lsbEVtaXRDbG9zZSkge1xuICAgICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpXG4gICAgfVxuICAgIGlmIChzdHJlYW0ucmVxKSB7XG4gICAgICBvbnJlcXVlc3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpXG4gICAgfVxuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3U3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKVxuICB9XG5cbiAgLy8gTm90IGFsbCBzdHJlYW1zIHdpbGwgZW1pdCAnY2xvc2UnIGFmdGVyICdhYm9ydGVkJy5cbiAgaWYgKCF3aWxsRW1pdENsb3NlICYmIHR5cGVvZiBzdHJlYW0uYWJvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc3RyZWFtLm9uKCdhYm9ydGVkJywgb25jbG9zZSlcbiAgfVxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKVxuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICBpZiAob3B0aW9ucy5lcnJvciAhPT0gZmFsc2UpIHtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcilcbiAgfVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSlcbiAgaWYgKGNsb3NlZCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZSlcbiAgfSBlbHNlIGlmIChcbiAgICAod1N0YXRlICE9PSBudWxsICYmIHdTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHdTdGF0ZS5lcnJvckVtaXR0ZWQpIHx8XG4gICAgKHJTdGF0ZSAhPT0gbnVsbCAmJiByU3RhdGUgIT09IHVuZGVmaW5lZCAmJiByU3RhdGUuZXJyb3JFbWl0dGVkKVxuICApIHtcbiAgICBpZiAoIXdpbGxFbWl0Q2xvc2UpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZWQpXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgICFyZWFkYWJsZSAmJlxuICAgICghd2lsbEVtaXRDbG9zZSB8fCBpc1JlYWRhYmxlKHN0cmVhbSkpICYmXG4gICAgKHdyaXRhYmxlRmluaXNoZWQgfHwgaXNXcml0YWJsZShzdHJlYW0pID09PSBmYWxzZSlcbiAgKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgfSBlbHNlIGlmIChcbiAgICAhd3JpdGFibGUgJiZcbiAgICAoIXdpbGxFbWl0Q2xvc2UgfHwgaXNXcml0YWJsZShzdHJlYW0pKSAmJlxuICAgIChyZWFkYWJsZUZpbmlzaGVkIHx8IGlzUmVhZGFibGUoc3RyZWFtKSA9PT0gZmFsc2UpXG4gICkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZWQpXG4gIH0gZWxzZSBpZiAoclN0YXRlICYmIHN0cmVhbS5yZXEgJiYgc3RyZWFtLmFib3J0ZWQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VkKVxuICB9XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgY2FsbGJhY2sgPSBub3BcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0ZWQnLCBvbmNsb3NlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSlcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpXG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgfVxuICBpZiAob3B0aW9ucy5zaWduYWwgJiYgIWNsb3NlZCkge1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgLy8gS2VlcCBpdCBiZWNhdXNlIGNsZWFudXAgcmVtb3ZlcyBpdC5cbiAgICAgIGNvbnN0IGVuZENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgIGNsZWFudXAoKVxuICAgICAgZW5kQ2FsbGJhY2suY2FsbChcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFib3J0KVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRBYm9ydExpc3RlbmVyID0gYWRkQWJvcnRMaXN0ZW5lciB8fCByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5hZGRBYm9ydExpc3RlbmVyXG4gICAgICBjb25zdCBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihvcHRpb25zLnNpZ25hbCwgYWJvcnQpXG4gICAgICBjb25zdCBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gb25jZSgoLi4uYXJncykgPT4ge1xuICAgICAgICBkaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKClcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5hcHBseShzdHJlYW0sIGFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2xlYW51cFxufVxuZnVuY3Rpb24gZW9zV2ViKHN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgbGV0IGlzQWJvcnRlZCA9IGZhbHNlXG4gIGxldCBhYm9ydCA9IG5vcFxuICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICBhYm9ydCA9ICgpID0+IHtcbiAgICAgIGlzQWJvcnRlZCA9IHRydWVcbiAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhYm9ydClcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IGFkZEFib3J0TGlzdGVuZXIob3B0aW9ucy5zaWduYWwsIGFib3J0KVxuICAgICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG9uY2UoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgZGlzcG9zYWJsZVtTeW1ib2xEaXNwb3NlXSgpXG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suYXBwbHkoc3RyZWFtLCBhcmdzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzb2x2ZXJGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCFpc0Fib3J0ZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gY2FsbGJhY2suYXBwbHkoc3RyZWFtLCBhcmdzKSlcbiAgICB9XG4gIH1cbiAgUHJvbWlzZVByb3RvdHlwZVRoZW4oc3RyZWFtW2tJc0Nsb3NlZFByb21pc2VdLnByb21pc2UsIHJlc29sdmVyRm4sIHJlc29sdmVyRm4pXG4gIHJldHVybiBub3Bcbn1cbmZ1bmN0aW9uIGZpbmlzaGVkKHN0cmVhbSwgb3B0cykge1xuICB2YXIgX29wdHNcbiAgbGV0IGF1dG9DbGVhbnVwID0gZmFsc2VcbiAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICBvcHRzID0ga0VtcHR5T2JqZWN0XG4gIH1cbiAgaWYgKChfb3B0cyA9IG9wdHMpICE9PSBudWxsICYmIF9vcHRzICE9PSB1bmRlZmluZWQgJiYgX29wdHMuY2xlYW51cCkge1xuICAgIHZhbGlkYXRlQm9vbGVhbihvcHRzLmNsZWFudXAsICdjbGVhbnVwJylcbiAgICBhdXRvQ2xlYW51cCA9IG9wdHMuY2xlYW51cFxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2xlYW51cCA9IGVvcyhzdHJlYW0sIG9wdHMsIChlcnIpID0+IHtcbiAgICAgIGlmIChhdXRvQ2xlYW51cCkge1xuICAgICAgICBjbGVhbnVwKClcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IGVvc1xubW9kdWxlLmV4cG9ydHMuZmluaXNoZWQgPSBmaW5pc2hlZFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/from.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n\nconst { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = (__webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\").codes)\nfunction from(Readable, iterable, opts) {\n  let iterator\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable)\n        this.push(null)\n      }\n    })\n  }\n  let isAsync\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true\n    iterator = iterable[SymbolAsyncIterator]()\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false\n    iterator = iterable[SymbolIterator]()\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    // TODO(ronag): What options should be allowed?\n    ...opts\n  })\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false\n  readable._read = function () {\n    if (!reading) {\n      reading = true\n      next()\n    }\n  }\n  readable._destroy = function (error, cb) {\n    PromisePrototypeThen(\n      close(error),\n      () => process.nextTick(cb, error),\n      // nextTick is here in case cb throws\n      (e) => process.nextTick(cb, e || error)\n    )\n  }\n  async function close(error) {\n    const hadError = error !== undefined && error !== null\n    const hasThrow = typeof iterator.throw === 'function'\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error)\n      await value\n      if (done) {\n        return\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return()\n      await value\n    }\n  }\n  async function next() {\n    for (;;) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next()\n        if (done) {\n          readable.push(null)\n        } else {\n          const res = value && typeof value.then === 'function' ? await value : value\n          if (res === null) {\n            reading = false\n            throw new ERR_STREAM_NULL_VALUES()\n          } else if (readable.push(res)) {\n            continue\n          } else {\n            reading = false\n          }\n        }\n      } catch (err) {\n        readable.destroy(err)\n      }\n      break\n    }\n  }\n  return readable\n}\nmodule.exports = from\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBVTs7QUFFbEM7O0FBRUEsUUFBUSw0REFBNEQsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUN0RyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLFFBQVEsK0NBQStDLEVBQUUsNElBQWtDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuY29uc3QgeyBQcm9taXNlUHJvdG90eXBlVGhlbiwgU3ltYm9sQXN5bmNJdGVyYXRvciwgU3ltYm9sSXRlcmF0b3IgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfU1RSRUFNX05VTExfVkFMVUVTIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5mdW5jdGlvbiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cykge1xuICBsZXQgaXRlcmF0b3JcbiAgaWYgKHR5cGVvZiBpdGVyYWJsZSA9PT0gJ3N0cmluZycgfHwgaXRlcmFibGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGl0ZXJhYmxlKVxuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGxldCBpc0FzeW5jXG4gIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2xBc3luY0l0ZXJhdG9yXSkge1xuICAgIGlzQXN5bmMgPSB0cnVlXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2xBc3luY0l0ZXJhdG9yXSgpXG4gIH0gZWxzZSBpZiAoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sSXRlcmF0b3JdKSB7XG4gICAgaXNBc3luYyA9IGZhbHNlXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2xJdGVyYXRvcl0oKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnaXRlcmFibGUnLCBbJ0l0ZXJhYmxlJ10sIGl0ZXJhYmxlKVxuICB9XG4gIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlKHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIGhpZ2hXYXRlck1hcms6IDEsXG4gICAgLy8gVE9ETyhyb25hZyk6IFdoYXQgb3B0aW9ucyBzaG91bGQgYmUgYWxsb3dlZD9cbiAgICAuLi5vcHRzXG4gIH0pXG5cbiAgLy8gRmxhZyB0byBwcm90ZWN0IGFnYWluc3QgX3JlYWRcbiAgLy8gYmVpbmcgY2FsbGVkIGJlZm9yZSBsYXN0IGl0ZXJhdGlvbiBjb21wbGV0aW9uLlxuICBsZXQgcmVhZGluZyA9IGZhbHNlXG4gIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVhZGluZykge1xuICAgICAgcmVhZGluZyA9IHRydWVcbiAgICAgIG5leHQoKVxuICAgIH1cbiAgfVxuICByZWFkYWJsZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnJvciwgY2IpIHtcbiAgICBQcm9taXNlUHJvdG90eXBlVGhlbihcbiAgICAgIGNsb3NlKGVycm9yKSxcbiAgICAgICgpID0+IHByb2Nlc3MubmV4dFRpY2soY2IsIGVycm9yKSxcbiAgICAgIC8vIG5leHRUaWNrIGlzIGhlcmUgaW4gY2FzZSBjYiB0aHJvd3NcbiAgICAgIChlKSA9PiBwcm9jZXNzLm5leHRUaWNrKGNiLCBlIHx8IGVycm9yKVxuICAgIClcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjbG9zZShlcnJvcikge1xuICAgIGNvbnN0IGhhZEVycm9yID0gZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBlcnJvciAhPT0gbnVsbFxuICAgIGNvbnN0IGhhc1Rocm93ID0gdHlwZW9mIGl0ZXJhdG9yLnRocm93ID09PSAnZnVuY3Rpb24nXG4gICAgaWYgKGhhZEVycm9yICYmIGhhc1Rocm93KSB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci50aHJvdyhlcnJvcilcbiAgICAgIGF3YWl0IHZhbHVlXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICBhd2FpdCB2YWx1ZVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlzQXN5bmMgPyBhd2FpdCBpdGVyYXRvci5uZXh0KCkgOiBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICByZWFkYWJsZS5wdXNoKG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgPyBhd2FpdCB2YWx1ZSA6IHZhbHVlXG4gICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkYWJsZS5wdXNoKHJlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlYWRhYmxlLmRlc3Ryb3koZXJyKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlYWRhYmxlXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZyb21cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/from.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvbGVnYWN5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDL0UsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBBcnJheUlzQXJyYXksIE9iamVjdFNldFByb3RvdHlwZU9mIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmZ1bmN0aW9uIFN0cmVhbShvcHRzKSB7XG4gIEVFLmNhbGwodGhpcywgb3B0cylcbn1cbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbS5wcm90b3R5cGUsIEVFLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbSwgRUUpXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2UgPSB0aGlzXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlICYmIGRlc3Qud3JpdGUoY2h1bmspID09PSBmYWxzZSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgfVxuICB9XG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSlcbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pXG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSlcbiAgfVxuICBsZXQgZGlkT25FbmQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVyblxuICAgIGRpZE9uRW5kID0gdHJ1ZVxuICAgIGRlc3QuZW5kKClcbiAgfVxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuXG4gICAgZGlkT25FbmQgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpXG4gIH1cblxuICAvLyBEb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKClcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuICBwcmVwZW5kTGlzdGVuZXIoc291cmNlLCAnZXJyb3InLCBvbmVycm9yKVxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBSZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKVxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cClcbiAgfVxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApXG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKVxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSlcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbilcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKVxuICBlbHNlIGlmIChBcnJheUlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbilcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0cmVhbSxcbiAgcHJlcGVuZExpc3RlbmVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/operators.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/operators.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(rsc)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateAbortSignal, validateInteger, validateObject } = __webpack_require__(/*! ../validators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\")\nconst kWeakHandler = (__webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\").Symbol)('kWeak')\nconst kResistStopPropagation = (__webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\").Symbol)('kResistStopPropagation')\nconst { finished } = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst staticCompose = __webpack_require__(/*! ./compose */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/compose.js\")\nconst { addAbortSignalNoValidate } = __webpack_require__(/*! ./add-abort-signal */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst { isWritable, isNodeStream } = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst { deprecate } = __webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").AbortSignalAny)(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvb3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHNEQUFzRCxnSUFBMkM7QUFDakc7QUFDQSxXQUFXLGlGQUFpRjtBQUM1RjtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLCtHQUFtQjtBQUMvQixRQUFRLHVEQUF1RCxFQUFFLG1CQUFPLENBQUMsbUhBQWU7QUFDeEYscUJBQXFCLHVKQUF3QztBQUM3RCwrQkFBK0IsdUpBQXdDO0FBQ3ZFLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0lBQWlCO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLG9IQUFXO0FBQ3pDLFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxzSUFBb0I7QUFDakUsUUFBUSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLGdIQUFTO0FBQ3RELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsMkdBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpSkFBeUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvb3BlcmF0b3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCByZXF1aXJlKCdhYm9ydC1jb250cm9sbGVyJykuQWJvcnRDb250cm9sbGVyXG5jb25zdCB7XG4gIGNvZGVzOiB7IEVSUl9JTlZBTElEX0FSR19WQUxVRSwgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9NSVNTSU5HX0FSR1MsIEVSUl9PVVRfT0ZfUkFOR0UgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgdmFsaWRhdGVBYm9ydFNpZ25hbCwgdmFsaWRhdGVJbnRlZ2VyLCB2YWxpZGF0ZU9iamVjdCB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCBrV2Vha0hhbmRsZXIgPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJykuU3ltYm9sKCdrV2VhaycpXG5jb25zdCBrUmVzaXN0U3RvcFByb3BhZ2F0aW9uID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpLlN5bWJvbCgna1Jlc2lzdFN0b3BQcm9wYWdhdGlvbicpXG5jb25zdCB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3Qgc3RhdGljQ29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZSB9ID0gcmVxdWlyZSgnLi9hZGQtYWJvcnQtc2lnbmFsJylcbmNvbnN0IHsgaXNXcml0YWJsZSwgaXNOb2RlU3RyZWFtIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHsgZGVwcmVjYXRlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxuY29uc3Qge1xuICBBcnJheVByb3RvdHlwZVB1c2gsXG4gIEJvb2xlYW4sXG4gIE1hdGhGbG9vcixcbiAgTnVtYmVyLFxuICBOdW1iZXJJc05hTixcbiAgUHJvbWlzZSxcbiAgUHJvbWlzZVJlamVjdCxcbiAgUHJvbWlzZVJlc29sdmUsXG4gIFByb21pc2VQcm90b3R5cGVUaGVuLFxuICBTeW1ib2xcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IGtFbXB0eSA9IFN5bWJvbCgna0VtcHR5JylcbmNvbnN0IGtFb2YgPSBTeW1ib2woJ2tFb2YnKVxuZnVuY3Rpb24gY29tcG9zZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIGlmIChpc05vZGVTdHJlYW0oc3RyZWFtKSAmJiAhaXNXcml0YWJsZShzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnc3RyZWFtJywgc3RyZWFtLCAnbXVzdCBiZSB3cml0YWJsZScpXG4gIH1cbiAgY29uc3QgY29tcG9zZWRTdHJlYW0gPSBzdGF0aWNDb21wb3NlKHRoaXMsIHN0cmVhbSlcbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgLy8gTm90IHZhbGlkYXRpbmcgYXMgd2UgYWxyZWFkeSB2YWxpZGF0ZWQgYmVmb3JlXG4gICAgYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlKG9wdGlvbnMuc2lnbmFsLCBjb21wb3NlZFN0cmVhbSlcbiAgfVxuICByZXR1cm4gY29tcG9zZWRTdHJlYW1cbn1cbmZ1bmN0aW9uIG1hcChmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCBmbilcbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgbGV0IGNvbmN1cnJlbmN5ID0gMVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5jb25jdXJyZW5jeSkgIT0gbnVsbCkge1xuICAgIGNvbmN1cnJlbmN5ID0gTWF0aEZsb29yKG9wdGlvbnMuY29uY3VycmVuY3kpXG4gIH1cbiAgbGV0IGhpZ2hXYXRlck1hcmsgPSBjb25jdXJyZW5jeSAtIDFcbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuaGlnaFdhdGVyTWFyaykgIT0gbnVsbCkge1xuICAgIGhpZ2hXYXRlck1hcmsgPSBNYXRoRmxvb3Iob3B0aW9ucy5oaWdoV2F0ZXJNYXJrKVxuICB9XG4gIHZhbGlkYXRlSW50ZWdlcihjb25jdXJyZW5jeSwgJ29wdGlvbnMuY29uY3VycmVuY3knLCAxKVxuICB2YWxpZGF0ZUludGVnZXIoaGlnaFdhdGVyTWFyaywgJ29wdGlvbnMuaGlnaFdhdGVyTWFyaycsIDApXG4gIGhpZ2hXYXRlck1hcmsgKz0gY29uY3VycmVuY3lcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiBtYXAoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuQWJvcnRTaWduYWxBbnkoXG4gICAgICBbb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbF0uZmlsdGVyKEJvb2xlYW4pXG4gICAgKVxuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXNcbiAgICBjb25zdCBxdWV1ZSA9IFtdXG4gICAgY29uc3Qgc2lnbmFsT3B0ID0ge1xuICAgICAgc2lnbmFsXG4gICAgfVxuICAgIGxldCBuZXh0XG4gICAgbGV0IHJlc3VtZVxuICAgIGxldCBkb25lID0gZmFsc2VcbiAgICBsZXQgY250ID0gMFxuICAgIGZ1bmN0aW9uIG9uQ2F0Y2goKSB7XG4gICAgICBkb25lID0gdHJ1ZVxuICAgICAgYWZ0ZXJJdGVtUHJvY2Vzc2VkKClcbiAgICB9XG4gICAgZnVuY3Rpb24gYWZ0ZXJJdGVtUHJvY2Vzc2VkKCkge1xuICAgICAgY250IC09IDFcbiAgICAgIG1heWJlUmVzdW1lKClcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF5YmVSZXN1bWUoKSB7XG4gICAgICBpZiAocmVzdW1lICYmICFkb25lICYmIGNudCA8IGNvbmN1cnJlbmN5ICYmIHF1ZXVlLmxlbmd0aCA8IGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgcmVzdW1lKClcbiAgICAgICAgcmVzdW1lID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChsZXQgdmFsIG9mIHN0cmVhbSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWwgPSBmbih2YWwsIHNpZ25hbE9wdClcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGtFbXB0eSkge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsID0gUHJvbWlzZVJlc29sdmUodmFsKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFsID0gUHJvbWlzZVJlamVjdChlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNudCArPSAxXG4gICAgICAgICAgUHJvbWlzZVByb3RvdHlwZVRoZW4odmFsLCBhZnRlckl0ZW1Qcm9jZXNzZWQsIG9uQ2F0Y2gpXG4gICAgICAgICAgcXVldWUucHVzaCh2YWwpXG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgICAgbmV4dCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkb25lICYmIChxdWV1ZS5sZW5ndGggPj0gaGlnaFdhdGVyTWFyayB8fCBjbnQgPj0gY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZXN1bWUgPSByZXNvbHZlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5wdXNoKGtFb2YpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgdmFsID0gUHJvbWlzZVJlamVjdChlcnIpXG4gICAgICAgIFByb21pc2VQcm90b3R5cGVUaGVuKHZhbCwgYWZ0ZXJJdGVtUHJvY2Vzc2VkLCBvbkNhdGNoKVxuICAgICAgICBxdWV1ZS5wdXNoKHZhbClcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dCgpXG4gICAgICAgICAgbmV4dCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwdW1wKClcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB2YWwgPSBhd2FpdCBxdWV1ZVswXVxuICAgICAgICAgIGlmICh2YWwgPT09IGtFb2YpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbCAhPT0ga0VtcHR5KSB7XG4gICAgICAgICAgICB5aWVsZCB2YWxcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWUuc2hpZnQoKVxuICAgICAgICAgIG1heWJlUmVzdW1lKClcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIG5leHQgPSByZXNvbHZlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBpZiAocmVzdW1lKSB7XG4gICAgICAgIHJlc3VtZSgpXG4gICAgICAgIHJlc3VtZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxuZnVuY3Rpb24gYXNJbmRleGVkUGFpcnMob3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiBhc0luZGV4ZWRQYWlycygpIHtcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgICAgdmFyIF9vcHRpb25zJHNpZ25hbFxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoX29wdGlvbnMkc2lnbmFsID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbC5hYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3Ioe1xuICAgICAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtpbmRleCsrLCB2YWxdXG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbmFzeW5jIGZ1bmN0aW9uIHNvbWUoZm4sIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgZm9yIGF3YWl0IChjb25zdCB1bnVzZWQgb2YgZmlsdGVyLmNhbGwodGhpcywgZm4sIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cbmFzeW5jIGZ1bmN0aW9uIGV2ZXJ5KGZuLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIGZuKVxuICB9XG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlX01vcmdhbiUyN3NfbGF3c1xuICByZXR1cm4gIShhd2FpdCBzb21lLmNhbGwoXG4gICAgdGhpcyxcbiAgICBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuICEoYXdhaXQgZm4oLi4uYXJncykpXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICkpXG59XG5hc3luYyBmdW5jdGlvbiBmaW5kKGZuLCBvcHRpb25zKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIGZpbHRlci5jYWxsKHRoaXMsIGZuLCBvcHRpb25zKSkge1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5hc3luYyBmdW5jdGlvbiBmb3JFYWNoKGZuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIGZuKVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZvckVhY2hGbih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGF3YWl0IGZuKHZhbHVlLCBvcHRpb25zKVxuICAgIHJldHVybiBrRW1wdHlcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZm9yIGF3YWl0IChjb25zdCB1bnVzZWQgb2YgbWFwLmNhbGwodGhpcywgZm9yRWFjaEZuLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBmaWx0ZXIoZm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmlsdGVyRm4odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXdhaXQgZm4odmFsdWUsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIGtFbXB0eVxuICB9XG4gIHJldHVybiBtYXAuY2FsbCh0aGlzLCBmaWx0ZXJGbiwgb3B0aW9ucylcbn1cblxuLy8gU3BlY2lmaWMgdG8gcHJvdmlkZSBiZXR0ZXIgZXJyb3IgdG8gcmVkdWNlIHNpbmNlIHRoZSBhcmd1bWVudCBpcyBvbmx5XG4vLyBtaXNzaW5nIGlmIHRoZSBzdHJlYW0gaGFzIG5vIGl0ZW1zIGluIGl0IC0gYnV0IHRoZSBjb2RlIGlzIHN0aWxsIGFwcHJvcHJpYXRlXG5jbGFzcyBSZWR1Y2VBd2FyZUVyck1pc3NpbmdBcmdzIGV4dGVuZHMgRVJSX01JU1NJTkdfQVJHUyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdyZWR1Y2UnKVxuICAgIHRoaXMubWVzc2FnZSA9ICdSZWR1Y2Ugb2YgYW4gZW1wdHkgc3RyZWFtIHJlcXVpcmVzIGFuIGluaXRpYWwgdmFsdWUnXG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlZHVjZShyZWR1Y2VyLCBpbml0aWFsVmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJHNpZ25hbDJcbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdyZWR1Y2VyJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIHJlZHVjZXIpXG4gIH1cbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIGxldCBoYXNJbml0aWFsVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMVxuICBpZiAoXG4gICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgIChfb3B0aW9ucyRzaWduYWwyID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgX29wdGlvbnMkc2lnbmFsMiAhPT0gdW5kZWZpbmVkICYmXG4gICAgX29wdGlvbnMkc2lnbmFsMi5hYm9ydGVkXG4gICkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgIH0pXG4gICAgdGhpcy5vbmNlKCdlcnJvcicsICgpID0+IHt9KSAvLyBUaGUgZXJyb3IgaXMgYWxyZWFkeSBwcm9wYWdhdGVkXG4gICAgYXdhaXQgZmluaXNoZWQodGhpcy5kZXN0cm95KGVycikpXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgY29uc3Qgc2lnbmFsID0gYWMuc2lnbmFsXG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgW2tXZWFrSGFuZGxlcl06IHRoaXMsXG4gICAgICBba1Jlc2lzdFN0b3BQcm9wYWdhdGlvbl06IHRydWVcbiAgICB9XG4gICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYy5hYm9ydCgpLCBvcHRzKVxuICB9XG4gIGxldCBnb3RBbnlJdGVtRnJvbVN0cmVhbSA9IGZhbHNlXG4gIHRyeSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsM1xuICAgICAgZ290QW55SXRlbUZyb21TdHJlYW0gPSB0cnVlXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChfb3B0aW9ucyRzaWduYWwzID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWwzLmFib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgICB9XG4gICAgICBpZiAoIWhhc0luaXRpYWxWYWx1ZSkge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSB2YWx1ZVxuICAgICAgICBoYXNJbml0aWFsVmFsdWUgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBhd2FpdCByZWR1Y2VyKGluaXRpYWxWYWx1ZSwgdmFsdWUsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnb3RBbnlJdGVtRnJvbVN0cmVhbSAmJiAhaGFzSW5pdGlhbFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgUmVkdWNlQXdhcmVFcnJNaXNzaW5nQXJncygpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGFjLmFib3J0KClcbiAgfVxuICByZXR1cm4gaW5pdGlhbFZhbHVlXG59XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICB2YXIgX29wdGlvbnMkc2lnbmFsNFxuICAgIGlmIChcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKF9vcHRpb25zJHNpZ25hbDQgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNC5hYm9ydGVkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgICAgfSlcbiAgICB9XG4gICAgQXJyYXlQcm90b3R5cGVQdXNoKHJlc3VsdCwgdmFsKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoZm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgdmFsdWVzID0gbWFwLmNhbGwodGhpcywgZm4sIG9wdGlvbnMpXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogZmxhdE1hcCgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB2YWx1ZXMpIHtcbiAgICAgIHlpZWxkKiB2YWxcbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxuZnVuY3Rpb24gdG9JbnRlZ2VyT3JJbmZpbml0eShudW1iZXIpIHtcbiAgLy8gV2UgY29lcmNlIGhlcmUgdG8gYWxpZ24gd2l0aCB0aGUgc3BlY1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pdGVyYXRvci1oZWxwZXJzL2lzc3Vlcy8xNjlcbiAgbnVtYmVyID0gTnVtYmVyKG51bWJlcilcbiAgaWYgKE51bWJlcklzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmIChudW1iZXIgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoJ251bWJlcicsICc+PSAwJywgbnVtYmVyKVxuICB9XG4gIHJldHVybiBudW1iZXJcbn1cbmZ1bmN0aW9uIGRyb3AobnVtYmVyLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5KG51bWJlcilcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiBkcm9wKCkge1xuICAgIHZhciBfb3B0aW9ucyRzaWduYWw1XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX29wdGlvbnMkc2lnbmFsNSA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw1LmFib3J0ZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgICAgdmFyIF9vcHRpb25zJHNpZ25hbDZcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbDYgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsNiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDYuYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXItLSA8PSAwKSB7XG4gICAgICAgIHlpZWxkIHZhbFxuICAgICAgfVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5mdW5jdGlvbiB0YWtlKG51bWJlciwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgbnVtYmVyID0gdG9JbnRlZ2VyT3JJbmZpbml0eShudW1iZXIpXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogdGFrZSgpIHtcbiAgICB2YXIgX29wdGlvbnMkc2lnbmFsN1xuICAgIGlmIChcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKF9vcHRpb25zJHNpZ25hbDcgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNy5hYm9ydGVkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgfVxuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaWduYWw4XG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChfb3B0aW9ucyRzaWduYWw4ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWw4LmFib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyLS0gPiAwKSB7XG4gICAgICAgIHlpZWxkIHZhbFxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBnZXQgYW5vdGhlciBpdGVtIGZyb20gaXRlcmF0b3IgaW4gY2FzZSB3ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgIGlmIChudW1iZXIgPD0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtUmV0dXJuaW5nT3BlcmF0b3JzID0ge1xuICBhc0luZGV4ZWRQYWlyczogZGVwcmVjYXRlKGFzSW5kZXhlZFBhaXJzLCAncmVhZGFibGUuYXNJbmRleGVkUGFpcnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uJyksXG4gIGRyb3AsXG4gIGZpbHRlcixcbiAgZmxhdE1hcCxcbiAgbWFwLFxuICB0YWtlLFxuICBjb21wb3NlXG59XG5tb2R1bGUuZXhwb3J0cy5wcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzID0ge1xuICBldmVyeSxcbiAgZm9yRWFjaCxcbiAgcmVkdWNlLFxuICB0b0FycmF5LFxuICBzb21lLFxuICBmaW5kXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/operators.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/passthrough.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/passthrough.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nconst { ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = PassThrough\nconst Transform = __webpack_require__(/*! ./transform */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/transform.js\")\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)\nObjectSetPrototypeOf(PassThrough, Transform)\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options)\n  Transform.call(this, options)\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGFzc3Rocm91Z2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUNqRTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdIQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgT2JqZWN0U2V0UHJvdG90eXBlT2YgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaFxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0nKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUGFzc1Rocm91Z2gucHJvdG90eXBlLCBUcmFuc2Zvcm0ucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKVxufVxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuaylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/passthrough.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst { once } = __webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateFunction, validateAbortSignal } = __webpack_require__(/*! ../validators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\")\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = __webpack_require__(/*! ./utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(rsc)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = __webpack_require__(/*! ./readable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js\")\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").addAbortListener)\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = __webpack_require__(/*! ./passthrough */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/passthrough.js\")\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVU7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFBUSw0REFBNEQsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUN0RyxZQUFZLG1CQUFPLENBQUMsZ0lBQWlCO0FBQ3JDLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsMkdBQWlCO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLG9IQUFXO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxrSEFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsK0dBQW1CO0FBQy9CLFFBQVEsd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyxtSEFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxnSEFBUztBQUNyQixzREFBc0QsZ0lBQTJDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNIQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUpBQTJDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDRIQUFlO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7IEFycmF5SXNBcnJheSwgUHJvbWlzZSwgU3ltYm9sQXN5bmNJdGVyYXRvciwgU3ltYm9sRGlzcG9zZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3QgeyBvbmNlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxuY29uc3QgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3QgRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXgnKVxuY29uc3Qge1xuICBhZ2dyZWdhdGVUd29FcnJvcnMsXG4gIGNvZGVzOiB7XG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcbiAgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgdmFsaWRhdGVGdW5jdGlvbiwgdmFsaWRhdGVBYm9ydFNpZ25hbCB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCB7XG4gIGlzSXRlcmFibGUsXG4gIGlzUmVhZGFibGUsXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc05vZGVTdHJlYW0sXG4gIGlzVHJhbnNmb3JtU3RyZWFtLFxuICBpc1dlYlN0cmVhbSxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZWFkYWJsZUZpbmlzaGVkXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCByZXF1aXJlKCdhYm9ydC1jb250cm9sbGVyJykuQWJvcnRDb250cm9sbGVyXG5sZXQgUGFzc1Rocm91Z2hcbmxldCBSZWFkYWJsZVxubGV0IGFkZEFib3J0TGlzdGVuZXJcbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcpIHtcbiAgbGV0IGZpbmlzaGVkID0gZmFsc2VcbiAgc3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBmaW5pc2hlZCA9IHRydWVcbiAgfSlcbiAgY29uc3QgY2xlYW51cCA9IGVvcyhcbiAgICBzdHJlYW0sXG4gICAge1xuICAgICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgICB3cml0YWJsZTogd3JpdGluZ1xuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgZmluaXNoZWQgPSAhZXJyXG4gICAgfVxuICApXG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogKGVycikgPT4ge1xuICAgICAgaWYgKGZpbmlzaGVkKSByZXR1cm5cbiAgICAgIGZpbmlzaGVkID0gdHJ1ZVxuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHN0cmVhbSwgZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKVxuICAgIH0sXG4gICAgY2xlYW51cFxuICB9XG59XG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIC8vIFN0cmVhbXMgc2hvdWxkIG5ldmVyIGJlIGFuIGVtcHR5IGFycmF5LiBJdCBzaG91bGQgYWx3YXlzIGNvbnRhaW4gYXQgbGVhc3RcbiAgLy8gYSBzaW5nbGUgc3RyZWFtLiBUaGVyZWZvcmUgb3B0aW1pemUgZm9yIHRoZSBhdmVyYWdlIGNhc2UgaW5zdGVhZCBvZlxuICAvLyBjaGVja2luZyBmb3IgbGVuZ3RoID09PSAwIGFzIHdlbGwuXG4gIHZhbGlkYXRlRnVuY3Rpb24oc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdLCAnc3RyZWFtc1tzdHJlYW0ubGVuZ3RoIC0gMV0nKVxuICByZXR1cm4gc3RyZWFtcy5wb3AoKVxufVxuZnVuY3Rpb24gbWFrZUFzeW5jSXRlcmFibGUodmFsKSB7XG4gIGlmIChpc0l0ZXJhYmxlKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsXG4gIH0gZWxzZSBpZiAoaXNSZWFkYWJsZU5vZGVTdHJlYW0odmFsKSkge1xuICAgIC8vIExlZ2FjeSBzdHJlYW1zIGFyZSBub3QgSXRlcmFibGUuXG4gICAgcmV0dXJuIGZyb21SZWFkYWJsZSh2YWwpXG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCd2YWwnLCBbJ1JlYWRhYmxlJywgJ0l0ZXJhYmxlJywgJ0FzeW5jSXRlcmFibGUnXSwgdmFsKVxufVxuYXN5bmMgZnVuY3Rpb24qIGZyb21SZWFkYWJsZSh2YWwpIHtcbiAgaWYgKCFSZWFkYWJsZSkge1xuICAgIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG4gIH1cbiAgeWllbGQqIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2xBc3luY0l0ZXJhdG9yXS5jYWxsKHZhbClcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1bXBUb05vZGUoaXRlcmFibGUsIHdyaXRhYmxlLCBmaW5pc2gsIHsgZW5kIH0pIHtcbiAgbGV0IGVycm9yXG4gIGxldCBvbnJlc29sdmUgPSBudWxsXG4gIGNvbnN0IHJlc3VtZSA9IChlcnIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgIH1cbiAgICBpZiAob25yZXNvbHZlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IG9ucmVzb2x2ZVxuICAgICAgb25yZXNvbHZlID0gbnVsbFxuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuICBjb25zdCB3YWl0ID0gKCkgPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25yZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB3cml0YWJsZS5vbignZHJhaW4nLCByZXN1bWUpXG4gIGNvbnN0IGNsZWFudXAgPSBlb3MoXG4gICAgd3JpdGFibGUsXG4gICAge1xuICAgICAgcmVhZGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICByZXN1bWVcbiAgKVxuICB0cnkge1xuICAgIGlmICh3cml0YWJsZS53cml0YWJsZU5lZWREcmFpbikge1xuICAgICAgYXdhaXQgd2FpdCgpXG4gICAgfVxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcmFibGUpIHtcbiAgICAgIGlmICghd3JpdGFibGUud3JpdGUoY2h1bmspKSB7XG4gICAgICAgIGF3YWl0IHdhaXQoKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB3cml0YWJsZS5lbmQoKVxuICAgICAgYXdhaXQgd2FpdCgpXG4gICAgfVxuICAgIGZpbmlzaCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZpbmlzaChlcnJvciAhPT0gZXJyID8gYWdncmVnYXRlVHdvRXJyb3JzKGVycm9yLCBlcnIpIDogZXJyKVxuICB9IGZpbmFsbHkge1xuICAgIGNsZWFudXAoKVxuICAgIHdyaXRhYmxlLm9mZignZHJhaW4nLCByZXN1bWUpXG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHB1bXBUb1dlYihyZWFkYWJsZSwgd3JpdGFibGUsIGZpbmlzaCwgeyBlbmQgfSkge1xuICBpZiAoaXNUcmFuc2Zvcm1TdHJlYW0od3JpdGFibGUpKSB7XG4gICAgd3JpdGFibGUgPSB3cml0YWJsZS53cml0YWJsZVxuICB9XG4gIC8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI2V4YW1wbGUtbWFudWFsLXdyaXRlLXdpdGgtYmFja3ByZXNzdXJlXG4gIGNvbnN0IHdyaXRlciA9IHdyaXRhYmxlLmdldFdyaXRlcigpXG4gIHRyeSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkYWJsZSkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgICB3cml0ZXIud3JpdGUoY2h1bmspLmNhdGNoKCgpID0+IHt9KVxuICAgIH1cbiAgICBhd2FpdCB3cml0ZXIucmVhZHlcbiAgICBpZiAoZW5kKSB7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKVxuICAgIH1cbiAgICBmaW5pc2goKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgd3JpdGVyLmFib3J0KGVycilcbiAgICAgIGZpbmlzaChlcnIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBmaW5pc2goZXJyKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGlwZWxpbmUoLi4uc3RyZWFtcykge1xuICByZXR1cm4gcGlwZWxpbmVJbXBsKHN0cmVhbXMsIG9uY2UocG9wQ2FsbGJhY2soc3RyZWFtcykpKVxufVxuZnVuY3Rpb24gcGlwZWxpbmVJbXBsKHN0cmVhbXMsIGNhbGxiYWNrLCBvcHRzKSB7XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMSAmJiBBcnJheUlzQXJyYXkoc3RyZWFtc1swXSkpIHtcbiAgICBzdHJlYW1zID0gc3RyZWFtc1swXVxuICB9XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpXG4gIH1cbiAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgY29uc3Qgc2lnbmFsID0gYWMuc2lnbmFsXG4gIGNvbnN0IG91dGVyU2lnbmFsID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLnNpZ25hbFxuXG4gIC8vIE5lZWQgdG8gY2xlYW51cCBldmVudCBsaXN0ZW5lcnMgaWYgbGFzdCBzdHJlYW0gaXMgcmVhZGFibGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNTQ1MlxuICBjb25zdCBsYXN0U3RyZWFtQ2xlYW51cCA9IFtdXG4gIHZhbGlkYXRlQWJvcnRTaWduYWwob3V0ZXJTaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGZpbmlzaEltcGwobmV3IEFib3J0RXJyb3IoKSlcbiAgfVxuICBhZGRBYm9ydExpc3RlbmVyID0gYWRkQWJvcnRMaXN0ZW5lciB8fCByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5hZGRBYm9ydExpc3RlbmVyXG4gIGxldCBkaXNwb3NhYmxlXG4gIGlmIChvdXRlclNpZ25hbCkge1xuICAgIGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKG91dGVyU2lnbmFsLCBhYm9ydClcbiAgfVxuICBsZXQgZXJyb3JcbiAgbGV0IHZhbHVlXG4gIGNvbnN0IGRlc3Ryb3lzID0gW11cbiAgbGV0IGZpbmlzaENvdW50ID0gMFxuICBmdW5jdGlvbiBmaW5pc2goZXJyKSB7XG4gICAgZmluaXNoSW1wbChlcnIsIC0tZmluaXNoQ291bnQgPT09IDApXG4gIH1cbiAgZnVuY3Rpb24gZmluaXNoSW1wbChlcnIsIGZpbmFsKSB7XG4gICAgdmFyIF9kaXNwb3NhYmxlXG4gICAgaWYgKGVyciAmJiAoIWVycm9yIHx8IGVycm9yLmNvZGUgPT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgIH1cbiAgICBpZiAoIWVycm9yICYmICFmaW5hbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdoaWxlIChkZXN0cm95cy5sZW5ndGgpIHtcbiAgICAgIGRlc3Ryb3lzLnNoaWZ0KCkoZXJyb3IpXG4gICAgfVxuICAgIDsoX2Rpc3Bvc2FibGUgPSBkaXNwb3NhYmxlKSA9PT0gbnVsbCB8fCBfZGlzcG9zYWJsZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2Rpc3Bvc2FibGVbU3ltYm9sRGlzcG9zZV0oKVxuICAgIGFjLmFib3J0KClcbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAuZm9yRWFjaCgoZm4pID0+IGZuKCkpXG4gICAgICB9XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpXG4gICAgfVxuICB9XG4gIGxldCByZXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gc3RyZWFtc1tpXVxuICAgIGNvbnN0IHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxXG4gICAgY29uc3Qgd3JpdGluZyA9IGkgPiAwXG4gICAgY29uc3QgZW5kID0gcmVhZGluZyB8fCAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLmVuZCkgIT09IGZhbHNlXG4gICAgY29uc3QgaXNMYXN0U3RyZWFtID0gaSA9PT0gc3RyZWFtcy5sZW5ndGggLSAxXG4gICAgaWYgKGlzTm9kZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGNvbnN0IHsgZGVzdHJveSwgY2xlYW51cCB9ID0gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZylcbiAgICAgICAgZGVzdHJveXMucHVzaChkZXN0cm95KVxuICAgICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pICYmIGlzTGFzdFN0cmVhbSkge1xuICAgICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLnB1c2goY2xlYW51cClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYXRjaCBzdHJlYW0gZXJyb3JzIHRoYXQgb2NjdXIgYWZ0ZXIgcGlwZS9wdW1wIGhhcyBjb21wbGV0ZWQuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5uYW1lICE9PSAnQWJvcnRFcnJvcicgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgICAgICBmaW5pc2goZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcilcbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkgJiYgaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLnB1c2goKCkgPT4ge1xuICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0ID0gc3RyZWFtKHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKCFpc0l0ZXJhYmxlKHJldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdJdGVyYWJsZSwgQXN5bmNJdGVyYWJsZSBvciBTdHJlYW0nLCAnc291cmNlJywgcmV0KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzSXRlcmFibGUoc3RyZWFtKSB8fCBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgICAgcmV0ID0gc3RyZWFtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBEdXBsZXguZnJvbShzdHJlYW0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNUcmFuc2Zvcm1TdHJlYW0ocmV0KSkge1xuICAgICAgICB2YXIgX3JldFxuICAgICAgICByZXQgPSBtYWtlQXN5bmNJdGVyYWJsZSgoX3JldCA9IHJldCkgPT09IG51bGwgfHwgX3JldCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3JldC5yZWFkYWJsZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG1ha2VBc3luY0l0ZXJhYmxlKHJldClcbiAgICAgIH1cbiAgICAgIHJldCA9IHN0cmVhbShyZXQsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KVxuICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgaWYgKCFpc0l0ZXJhYmxlKHJldCwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdBc3luY0l0ZXJhYmxlJywgYHRyYW5zZm9ybVske2kgLSAxfV1gLCByZXQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmV0MlxuICAgICAgICBpZiAoIVBhc3NUaHJvdWdoKSB7XG4gICAgICAgICAgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL3Bhc3N0aHJvdWdoJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGFyZ3VtZW50IHRvIHBpcGVsaW5lIGlzIG5vdCBhIHN0cmVhbVxuICAgICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBhIHByb3h5IHN0cmVhbSBzbyB0aGF0IHBpcGVsaW5lKC4uLilcbiAgICAgICAgLy8gYWx3YXlzIHJldHVybnMgYSBzdHJlYW0gd2hpY2ggY2FuIGJlIGZ1cnRoZXJcbiAgICAgICAgLy8gY29tcG9zZWQgdGhyb3VnaCBgLnBpcGUoc3RyZWFtKWAuXG5cbiAgICAgICAgY29uc3QgcHQgPSBuZXcgUGFzc1Rocm91Z2goe1xuICAgICAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBIYW5kbGUgUHJvbWlzZXMvQSsgc3BlYywgYHRoZW5gIGNvdWxkIGJlIGEgZ2V0dGVyIHRoYXQgdGhyb3dzIG9uXG4gICAgICAgIC8vIHNlY29uZCB1c2UuXG4gICAgICAgIGNvbnN0IHRoZW4gPSAoX3JldDIgPSByZXQpID09PSBudWxsIHx8IF9yZXQyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmV0Mi50aGVuXG4gICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICAodmFsKSA9PiB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsXG4gICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHB0LndyaXRlKHZhbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgcHQuZW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHB0LmRlc3Ryb3koZXJyKVxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaCwgZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKHJldCwgdHJ1ZSkpIHtcbiAgICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgICAgcHVtcFRvTm9kZShyZXQsIHB0LCBmaW5pc2gsIHtcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWFkYWJsZVN0cmVhbShyZXQpIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHJldCkpIHtcbiAgICAgICAgICBjb25zdCB0b1JlYWQgPSByZXQucmVhZGFibGUgfHwgcmV0XG4gICAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICAgIHB1bXBUb05vZGUodG9SZWFkLCBwdCwgZmluaXNoLCB7XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ0FzeW5jSXRlcmFibGUgb3IgUHJvbWlzZScsICdkZXN0aW5hdGlvbicsIHJldClcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBwdFxuICAgICAgICBjb25zdCB7IGRlc3Ryb3ksIGNsZWFudXAgfSA9IGRlc3Ryb3llcihyZXQsIGZhbHNlLCB0cnVlKVxuICAgICAgICBkZXN0cm95cy5wdXNoKGRlc3Ryb3kpXG4gICAgICAgIGlmIChpc0xhc3RTdHJlYW0pIHtcbiAgICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKGNsZWFudXApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTm9kZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgICBpZiAoaXNSZWFkYWJsZU5vZGVTdHJlYW0ocmV0KSkge1xuICAgICAgICBmaW5pc2hDb3VudCArPSAyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBwaXBlKHJldCwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSAmJiBpc0xhc3RTdHJlYW0pIHtcbiAgICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKGNsZWFudXApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNUcmFuc2Zvcm1TdHJlYW0ocmV0KSB8fCBpc1JlYWRhYmxlU3RyZWFtKHJldCkpIHtcbiAgICAgICAgY29uc3QgdG9SZWFkID0gcmV0LnJlYWRhYmxlIHx8IHJldFxuICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgIHB1bXBUb05vZGUodG9SZWFkLCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9Ob2RlKHJldCwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAndmFsJyxcbiAgICAgICAgICBbJ1JlYWRhYmxlJywgJ0l0ZXJhYmxlJywgJ0FzeW5jSXRlcmFibGUnLCAnUmVhZGFibGVTdHJlYW0nLCAnVHJhbnNmb3JtU3RyZWFtJ10sXG4gICAgICAgICAgcmV0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldCA9IHN0cmVhbVxuICAgIH0gZWxzZSBpZiAoaXNXZWJTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgaWYgKGlzUmVhZGFibGVOb2RlU3RyZWFtKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9XZWIobWFrZUFzeW5jSXRlcmFibGUocmV0KSwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkYWJsZVN0cmVhbShyZXQpIHx8IGlzSXRlcmFibGUocmV0KSkge1xuICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgIHB1bXBUb1dlYihyZXQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9XZWIocmV0LnJlYWRhYmxlLCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICAgICd2YWwnLFxuICAgICAgICAgIFsnUmVhZGFibGUnLCAnSXRlcmFibGUnLCAnQXN5bmNJdGVyYWJsZScsICdSZWFkYWJsZVN0cmVhbScsICdUcmFuc2Zvcm1TdHJlYW0nXSxcbiAgICAgICAgICByZXRcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0ID0gc3RyZWFtXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IER1cGxleC5mcm9tKHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgaWYgKFxuICAgIChzaWduYWwgIT09IG51bGwgJiYgc2lnbmFsICE9PSB1bmRlZmluZWQgJiYgc2lnbmFsLmFib3J0ZWQpIHx8XG4gICAgKG91dGVyU2lnbmFsICE9PSBudWxsICYmIG91dGVyU2lnbmFsICE9PSB1bmRlZmluZWQgJiYgb3V0ZXJTaWduYWwuYWJvcnRlZClcbiAgKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhhYm9ydClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBwaXBlKHNyYywgZHN0LCBmaW5pc2gsIHsgZW5kIH0pIHtcbiAgbGV0IGVuZGVkID0gZmFsc2VcbiAgZHN0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBpZiAoIWVuZGVkKSB7XG4gICAgICAvLyBGaW5pc2ggaWYgdGhlIGRlc3RpbmF0aW9uIGNsb3NlcyBiZWZvcmUgdGhlIHNvdXJjZSBoYXMgY29tcGxldGVkLlxuICAgICAgZmluaXNoKG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpKVxuICAgIH1cbiAgfSlcbiAgc3JjLnBpcGUoZHN0LCB7XG4gICAgZW5kOiBmYWxzZVxuICB9KSAvLyBJZiBlbmQgaXMgdHJ1ZSB3ZSBhbHJlYWR5IHdpbGwgaGF2ZSBhIGxpc3RlbmVyIHRvIGVuZCBkc3QuXG5cbiAgaWYgKGVuZCkge1xuICAgIC8vIENvbXBhdC4gQmVmb3JlIG5vZGUgdjEwLjEyLjAgc3RkaW8gdXNlZCB0byB0aHJvdyBhbiBlcnJvciBzb1xuICAgIC8vIHBpcGUoKSBkaWQvZG9lcyBub3QgZW5kKCkgc3RkaW8gZGVzdGluYXRpb25zLlxuICAgIC8vIE5vdyB0aGV5IGFsbG93IGl0IGJ1dCBcInNlY3JldGx5XCIgZG9uJ3QgY2xvc2UgdGhlIHVuZGVybHlpbmcgZmQuXG5cbiAgICBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgIGVuZGVkID0gdHJ1ZVxuICAgICAgZHN0LmVuZCgpXG4gICAgfVxuICAgIGlmIChpc1JlYWRhYmxlRmluaXNoZWQoc3JjKSkge1xuICAgICAgLy8gRW5kIHRoZSBkZXN0aW5hdGlvbiBpZiB0aGUgc291cmNlIGhhcyBhbHJlYWR5IGVuZGVkLlxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbilcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5pc2goKVxuICB9XG4gIGVvcyhcbiAgICBzcmMsXG4gICAge1xuICAgICAgcmVhZGFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIGNvbnN0IHJTdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZVxuICAgICAgaWYgKFxuICAgICAgICBlcnIgJiZcbiAgICAgICAgZXJyLmNvZGUgPT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScgJiZcbiAgICAgICAgclN0YXRlICYmXG4gICAgICAgIHJTdGF0ZS5lbmRlZCAmJlxuICAgICAgICAhclN0YXRlLmVycm9yZWQgJiZcbiAgICAgICAgIXJTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICAvLyBTb21lIHJlYWRhYmxlIHN0cmVhbXMgd2lsbCBlbWl0ICdjbG9zZScgYmVmb3JlICdlbmQnLiBIb3dldmVyLCBzaW5jZVxuICAgICAgICAvLyB0aGlzIGlzIG9uIHRoZSByZWFkYWJsZSBzaWRlICdlbmQnIHNob3VsZCBzdGlsbCBiZSBlbWl0dGVkIGlmIHRoZVxuICAgICAgICAvLyBzdHJlYW0gaGFzIGJlZW4gZW5kZWQgYW5kIG5vIGVycm9yIGVtaXR0ZWQuIFRoaXMgc2hvdWxkIGJlIGFsbG93ZWQgaW5cbiAgICAgICAgLy8gZmF2b3Igb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFNpbmNlIHRoZSBzdHJlYW0gaXMgcGlwZWQgdG8gYVxuICAgICAgICAvLyBkZXN0aW5hdGlvbiB0aGlzIHNob3VsZCBub3QgcmVzdWx0IGluIGFueSBvYnNlcnZhYmxlIGRpZmZlcmVuY2UuXG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgaWYgdGhpcyBpcyBhIHdyaXRhYmxlIHByZW1hdHVyZSBjbG9zZSBzaW5jZVxuICAgICAgICAvLyBlb3Mgd2lsbCBvbmx5IGZhaWwgd2l0aCBwcmVtYXR1cmUgY2xvc2Ugb24gdGhlIHJlYWRpbmcgc2lkZSBmb3JcbiAgICAgICAgLy8gZHVwbGV4IHN0cmVhbXMuXG4gICAgICAgIHNyYy5vbmNlKCdlbmQnLCBmaW5pc2gpLm9uY2UoJ2Vycm9yJywgZmluaXNoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoKGVycilcbiAgICAgIH1cbiAgICB9XG4gIClcbiAgcmV0dXJuIGVvcyhcbiAgICBkc3QsXG4gICAge1xuICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIGZpbmlzaFxuICApXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGlwZWxpbmVJbXBsLFxuICBwaXBlbGluZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nconst { Stream, prependListener } = __webpack_require__(/*! ./legacy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nlet debug = (__webpack_require__(/*! ../../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").debuglog)('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = __webpack_require__(/*! ./buffer_list */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/buffer_list.js\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js\")\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = __webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { validateObject } = __webpack_require__(/*! ../validators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\")\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst from = __webpack_require__(/*! ./from */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/from.js\")\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVU7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDcEM7QUFDQTtBQUNBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsa0hBQVU7QUFDdEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsc0lBQW9CO0FBQ3ZELFlBQVksbUJBQU8sQ0FBQyxnSUFBaUI7QUFDckMsWUFBWSwySUFBbUM7QUFDL0M7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsNEhBQWU7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsb0hBQVc7QUFDdkMsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLGdIQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywrR0FBbUI7QUFDL0IsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLG1IQUFlO0FBQ2xEO0FBQ0EsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsOEdBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsbUJBQU8sQ0FBQyxrSEFBVTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFPLENBQUMsa0hBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG47KCd1c2Ugc3RyaWN0JylcbmNvbnN0IHtcbiAgQXJyYXlQcm90b3R5cGVJbmRleE9mLFxuICBOdW1iZXJJc0ludGVnZXIsXG4gIE51bWJlcklzTmFOLFxuICBOdW1iZXJQYXJzZUludCxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0S2V5cyxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YsXG4gIFByb21pc2UsXG4gIFNhZmVTZXQsXG4gIFN5bWJvbEFzeW5jRGlzcG9zZSxcbiAgU3ltYm9sQXN5bmNJdGVyYXRvcixcbiAgU3ltYm9sXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgeyBTdHJlYW0sIHByZXBlbmRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2FkZC1hYm9ydC1zaWduYWwnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmxldCBkZWJ1ZyA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmRlYnVnbG9nKCdzdHJlYW0nLCAoZm4pID0+IHtcbiAgZGVidWcgPSBmblxufSlcbmNvbnN0IEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2J1ZmZlcl9saXN0JylcbmNvbnN0IGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IHsgZ2V0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuY29uc3Qge1xuICBhZ2dyZWdhdGVUd29FcnJvcnMsXG4gIGNvZGVzOiB7XG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX09VVF9PRl9SQU5HRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlRcbiAgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgdmFsaWRhdGVPYmplY3QgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3Qga1BhdXNlZCA9IFN5bWJvbCgna1BhdXNlZCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IGZyb20gPSByZXF1aXJlKCcuL2Zyb20nKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUucHJvdG90eXBlLCBTdHJlYW0ucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUsIFN0cmVhbSlcbmNvbnN0IG5vcCA9ICgpID0+IHt9XG5jb25zdCB7IGVycm9yT3JEZXN0cm95IH0gPSBkZXN0cm95SW1wbFxuY29uc3Qga09iamVjdE1vZGUgPSAxIDw8IDBcbmNvbnN0IGtFbmRlZCA9IDEgPDwgMVxuY29uc3Qga0VuZEVtaXR0ZWQgPSAxIDw8IDJcbmNvbnN0IGtSZWFkaW5nID0gMSA8PCAzXG5jb25zdCBrQ29uc3RydWN0ZWQgPSAxIDw8IDRcbmNvbnN0IGtTeW5jID0gMSA8PCA1XG5jb25zdCBrTmVlZFJlYWRhYmxlID0gMSA8PCA2XG5jb25zdCBrRW1pdHRlZFJlYWRhYmxlID0gMSA8PCA3XG5jb25zdCBrUmVhZGFibGVMaXN0ZW5pbmcgPSAxIDw8IDhcbmNvbnN0IGtSZXN1bWVTY2hlZHVsZWQgPSAxIDw8IDlcbmNvbnN0IGtFcnJvckVtaXR0ZWQgPSAxIDw8IDEwXG5jb25zdCBrRW1pdENsb3NlID0gMSA8PCAxMVxuY29uc3Qga0F1dG9EZXN0cm95ID0gMSA8PCAxMlxuY29uc3Qga0Rlc3Ryb3llZCA9IDEgPDwgMTNcbmNvbnN0IGtDbG9zZWQgPSAxIDw8IDE0XG5jb25zdCBrQ2xvc2VFbWl0dGVkID0gMSA8PCAxNVxuY29uc3Qga011bHRpQXdhaXREcmFpbiA9IDEgPDwgMTZcbmNvbnN0IGtSZWFkaW5nTW9yZSA9IDEgPDwgMTdcbmNvbnN0IGtEYXRhRW1pdHRlZCA9IDEgPDwgMThcblxuLy8gVE9ETyhiZW5qYW1pbmdyKSBpdCBpcyBsaWtlbHkgc2xvd2VyIHRvIGRvIGl0IHRoaXMgd2F5IHRoYW4gd2l0aCBmcmVlIGZ1bmN0aW9uc1xuZnVuY3Rpb24gbWFrZUJpdE1hcERlc2NyaXB0b3IoYml0KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLnN0YXRlICYgYml0KSAhPT0gMFxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHRoaXMuc3RhdGUgfD0gYml0XG4gICAgICBlbHNlIHRoaXMuc3RhdGUgJj0gfmJpdFxuICAgIH1cbiAgfVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0YXRlLnByb3RvdHlwZSwge1xuICBvYmplY3RNb2RlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrT2JqZWN0TW9kZSksXG4gIGVuZGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kZWQpLFxuICBlbmRFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kRW1pdHRlZCksXG4gIHJlYWRpbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nKSxcbiAgLy8gU3RyZWFtIGlzIHN0aWxsIGJlaW5nIGNvbnN0cnVjdGVkIGFuZCBjYW5ub3QgYmVcbiAgLy8gZGVzdHJveWVkIHVudGlsIGNvbnN0cnVjdGlvbiBmaW5pc2hlZCBvciBmYWlsZWQuXG4gIC8vIEFzeW5jIGNvbnN0cnVjdGlvbiBpcyBvcHQgaW4sIHRoZXJlZm9yZSB3ZSBzdGFydCBhc1xuICAvLyBjb25zdHJ1Y3RlZC5cbiAgY29uc3RydWN0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDb25zdHJ1Y3RlZCksXG4gIC8vIEEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgc3luYzogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1N5bmMpLFxuICAvLyBXaGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgbmVlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTmVlZFJlYWRhYmxlKSxcbiAgZW1pdHRlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW1pdHRlZFJlYWRhYmxlKSxcbiAgcmVhZGFibGVMaXN0ZW5pbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkYWJsZUxpc3RlbmluZyksXG4gIHJlc3VtZVNjaGVkdWxlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1Jlc3VtZVNjaGVkdWxlZCksXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluLlxuICBlcnJvckVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFcnJvckVtaXR0ZWQpLFxuICBlbWl0Q2xvc2U6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbWl0Q2xvc2UpLFxuICBhdXRvRGVzdHJveTogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0F1dG9EZXN0cm95KSxcbiAgLy8gSGFzIGl0IGJlZW4gZGVzdHJveWVkLlxuICBkZXN0cm95ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtEZXN0cm95ZWQpLFxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBmaW5pc2hlZCBkZXN0cm95aW5nLlxuICBjbG9zZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDbG9zZWQpLFxuICAvLyBUcnVlIGlmIGNsb3NlIGhhcyBiZWVuIGVtaXR0ZWQgb3Igd291bGQgaGF2ZSBiZWVuIGVtaXR0ZWRcbiAgLy8gZGVwZW5kaW5nIG9uIGVtaXRDbG9zZS5cbiAgY2xvc2VFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrQ2xvc2VFbWl0dGVkKSxcbiAgbXVsdGlBd2FpdERyYWluOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTXVsdGlBd2FpdERyYWluKSxcbiAgLy8gSWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZC5cbiAgcmVhZGluZ01vcmU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nTW9yZSksXG4gIGRhdGFFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRGF0YUVtaXR0ZWQpXG59KVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcblxuICAvLyBCaXQgbWFwIGZpZWxkIHRvIHN0b3JlIFJlYWRhYmxlU3RhdGUgbW9yZSBlZmZjaWVudGx5IHdpdGggMSBiaXQgcGVyIGZpZWxkXG4gIC8vIGluc3RlYWQgb2YgYSBWOCBzbG90IHBlciBmaWVsZC5cbiAgdGhpcy5zdGF0ZSA9IGtFbWl0Q2xvc2UgfCBrQXV0b0Rlc3Ryb3kgfCBrQ29uc3RydWN0ZWQgfCBrU3luY1xuICAvLyBPYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheS5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG4gIGlmIChpc0R1cGxleCAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG5cbiAgLy8gVGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRpb25zXG4gICAgPyBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleClcbiAgICA6IGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKGZhbHNlKVxuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KCkuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKVxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5waXBlcyA9IFtdXG4gIHRoaXMuZmxvd2luZyA9IG51bGxcbiAgdGhpc1trUGF1c2VkXSA9IG51bGxcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVtaXRDbG9zZSA9PT0gZmFsc2UpIHRoaXMuc3RhdGUgJj0gfmtFbWl0Q2xvc2VcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJykuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKSB0aGlzLnN0YXRlICY9IH5rQXV0b0Rlc3Ryb3lcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBlcnJvcmVkLiBXaGVuIHRydWUgbm8gZnVydGhlclxuICAvLyBfcmVhZCBjYWxscywgJ2RhdGEnIG9yICdyZWFkYWJsZScgZXZlbnRzIHNob3VsZCBvY2N1ci4gVGhpcyBpcyBuZWVkZWRcbiAgLy8gc2luY2Ugd2hlbiBhdXRvRGVzdHJveSBpcyBkaXNhYmxlZCB3ZSBuZWVkIGEgd2F5IHRvIHRlbGwgd2hldGhlciB0aGVcbiAgLy8gc3RyZWFtIGhhcyBmYWlsZWQuXG4gIHRoaXMuZXJyb3JlZCA9IG51bGxcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKSB8fCAndXRmOCdcblxuICAvLyBSZWYgdGhlIHBpcGVkIGRlc3Qgd2hpY2ggd2UgbmVlZCBhIGRyYWluIGV2ZW50IG9uIGl0XG4gIC8vIHR5cGU6IG51bGwgfCBXcml0YWJsZSB8IFNldDxXcml0YWJsZT4uXG4gIHRoaXMuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gIHRoaXMuZGVjb2RlciA9IG51bGxcbiAgdGhpcy5lbmNvZGluZyA9IG51bGxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfVxufVxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjUuXG4gIGNvbnN0IGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3lcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9jb25zdHJ1Y3QgPSBvcHRpb25zLmNvbnN0cnVjdFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhaXNEdXBsZXgpIGFkZEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCB0aGlzKVxuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGRlc3Ryb3lJbXBsLmNvbnN0cnVjdCh0aGlzLCAoKSA9PiB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlKSB7XG4gICAgICBtYXliZVJlYWRNb3JlKHRoaXMsIHRoaXMuX3JlYWRhYmxlU3RhdGUpXG4gICAgfVxuICB9KVxufVxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveVxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW0VFLmNhcHR1cmVSZWplY3Rpb25TeW1ib2xdID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmRlc3Ryb3koZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbEFzeW5jRGlzcG9zZV0gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBlcnJvclxuICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgZXJyb3IgPSB0aGlzLnJlYWRhYmxlRW5kZWQgPyBudWxsIDogbmV3IEFib3J0RXJyb3IoKVxuICAgIHRoaXMuZGVzdHJveShlcnJvcilcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gZW9zKHRoaXMsIChlcnIpID0+IChlcnIgJiYgZXJyICE9PSBlcnJvciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShudWxsKSkpKVxufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKCkuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCB0cnVlKVxufVxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKVxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBsZXQgZXJyXG4gIGlmICgoc3RhdGUuc3RhdGUgJiBrT2JqZWN0TW9kZSkgPT09IDApIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2RpbmdcbiAgICAgIGlmIChzdGF0ZS5lbmNvZGluZyAhPT0gZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQgJiYgc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgICAvLyBXaGVuIHVuc2hpZnRpbmcsIGlmIHN0YXRlLmVuY29kaW5nIGlzIHNldCwgd2UgaGF2ZSB0byBzYXZlXG4gICAgICAgICAgLy8gdGhlIHN0cmluZyBpbiB0aGUgQnVmZmVyTGlzdCB3aXRoIHRoZSBzdGF0ZSBlbmNvZGluZy5cbiAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZykudG9TdHJpbmcoc3RhdGUuZW5jb2RpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoU3RyZWFtLl9pc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IFN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyKGNodW5rKVxuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoY2h1bmsgIT0gbnVsbCkge1xuICAgICAgZXJyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKVxuICAgIH1cbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5zdGF0ZSAmPSB+a1JlYWRpbmdcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoKHN0YXRlLnN0YXRlICYga09iamVjdE1vZGUpICE9PSAwIHx8IChjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSkge1xuICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICBpZiAoKHN0YXRlLnN0YXRlICYga0VuZEVtaXR0ZWQpICE9PSAwKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpXG4gICAgICBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQgfHwgc3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gICAgICBlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSlcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCB8fCBzdGF0ZS5lcnJvcmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKVxuICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSlcbiAgICAgICAgZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApXG59XG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMgJiYgc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICAvLyBVc2UgdGhlIGd1YXJkIHRvIGF2b2lkIGNyZWF0aW5nIGBTZXQoKWAgcmVwZWF0ZWRseVxuICAgIC8vIHdoZW4gd2UgaGF2ZSBtdWx0aXBsZSBwaXBlcy5cbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga011bHRpQXdhaXREcmFpbikgIT09IDApIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLmNsZWFyKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gICAgfVxuICAgIHN0YXRlLmRhdGFFbWl0dGVkID0gdHJ1ZVxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgLy8gVXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspXG4gICAgZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuaylcbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDApIGVtaXRSZWFkYWJsZShzdHJlYW0pXG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxufVxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgcmV0dXJuIHN0YXRlW2tQYXVzZWRdID09PSB0cnVlIHx8IHN0YXRlLmZsb3dpbmcgPT09IGZhbHNlXG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyXG4gIC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4LlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nXG4gIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIGxldCBjb250ZW50ID0gJydcbiAgZm9yIChjb25zdCBkYXRhIG9mIGJ1ZmZlcikge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShkYXRhKVxuICB9XG4gIGJ1ZmZlci5jbGVhcigpXG4gIGlmIChjb250ZW50ICE9PSAnJykgYnVmZmVyLnB1c2goY29udGVudClcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCLlxuY29uc3QgTUFYX0hXTSA9IDB4NDAwMDAwMDBcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPiBNQVhfSFdNKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoJ3NpemUnLCAnPD0gMUdpQicsIG4pXG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzLlxuICAgIG4tLVxuICAgIG4gfD0gbiA+Pj4gMVxuICAgIG4gfD0gbiA+Pj4gMlxuICAgIG4gfD0gbiA+Pj4gNFxuICAgIG4gfD0gbiA+Pj4gOFxuICAgIG4gfD0gbiA+Pj4gMTZcbiAgICBuKytcbiAgfVxuICByZXR1cm4gblxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSkgcmV0dXJuIDBcbiAgaWYgKChzdGF0ZS5zdGF0ZSAmIGtPYmplY3RNb2RlKSAhPT0gMCkgcmV0dXJuIDFcbiAgaWYgKE51bWJlcklzTmFOKG4pKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lLlxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5maXJzdCgpLmxlbmd0aFxuICAgIHJldHVybiBzdGF0ZS5sZW5ndGhcbiAgfVxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuXG4gIHJldHVybiBzdGF0ZS5lbmRlZCA/IHN0YXRlLmxlbmd0aCA6IDBcbn1cblxuLy8gWW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKVxuICAvLyBTYW1lIGFzIHBhcnNlSW50KHVuZGVmaW5lZCwgMTApLCBob3dldmVyIFY4IDcuMyBwZXJmb3JtYW5jZSByZWdyZXNzZWRcbiAgLy8gaW4gdGhpcyBzY2VuYXJpbywgc28gd2UgYXJlIGRvaW5nIGl0IG1hbnVhbGx5LlxuICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbiA9IE5hTlxuICB9IGVsc2UgaWYgKCFOdW1iZXJJc0ludGVnZXIobikpIHtcbiAgICBuID0gTnVtYmVyUGFyc2VJbnQobiwgMTApXG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IG5PcmlnID0gblxuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKVxuICBpZiAobiAhPT0gMCkgc3RhdGUuc3RhdGUgJj0gfmtFbWl0dGVkUmVhZGFibGVcblxuICAvLyBJZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChcbiAgICBuID09PSAwICYmXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZClcbiAgKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcylcbiAgICBlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpXG5cbiAgLy8gSWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICBsZXQgZG9SZWFkID0gKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDBcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpXG5cbiAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZVxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZClcbiAgfVxuXG4gIC8vIEhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LCBpZiB3ZSdyZSBjb25zdHJ1Y3Rpbmcgd2UgaGF2ZSB0byB3YWl0LFxuICAvLyBhbmQgaWYgd2UncmUgZGVzdHJveWVkIG9yIGVycm9yZWQsIHRoZW4gaXQncyBub3QgYWxsb3dlZCxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcgfHwgc3RhdGUuZGVzdHJveWVkIHx8IHN0YXRlLmVycm9yZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgZG9SZWFkID0gZmFsc2VcbiAgICBkZWJ1ZygncmVhZGluZywgZW5kZWQgb3IgY29uc3RydWN0aW5nJywgZG9SZWFkKVxuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJylcbiAgICBzdGF0ZS5zdGF0ZSB8PSBrUmVhZGluZyB8IGtTeW5jXG4gICAgLy8gSWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5zdGF0ZSB8PSBrTmVlZFJlYWRhYmxlXG5cbiAgICAvLyBDYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtTeW5jXG5cbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSlcbiAgfVxuICBsZXQgcmV0XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpXG4gIGVsc2UgcmV0ID0gbnVsbFxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICBuID0gMFxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuXG4gICAgaWYgKHN0YXRlLm11bHRpQXdhaXREcmFpbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuY2xlYXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlXG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKVxuICB9XG4gIGlmIChyZXQgIT09IG51bGwgJiYgIXN0YXRlLmVycm9yRW1pdHRlZCAmJiAhc3RhdGUuY2xvc2VFbWl0dGVkKSB7XG4gICAgc3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpXG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgY29uc3QgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gSWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGwuXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSlcbiAgfSBlbHNlIHtcbiAgICAvLyBFbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWVcbiAgICAvLyBXZSBoYXZlIHRvIGVtaXQgcmVhZGFibGUgbm93IHRoYXQgd2UgYXJlIEVPRi4gTW9kdWxlc1xuICAgIC8vIGluIHRoZSBlY29zeXN0ZW0gKGUuZy4gZGljZXIpIHJlbHkgb24gdGhpcyBldmVudCBiZWluZyBzeW5jLlxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKVxuICB9XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2VcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZylcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKVxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAhc3RhdGUuZXJyb3JlZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZjpcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFya1xuICBmbG93KHN0cmVhbSlcbn1cblxuLy8gQXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSAmJiBzdGF0ZS5jb25zdHJ1Y3RlZCkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZVxuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpXG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoXG4gICAgIXN0YXRlLnJlYWRpbmcgJiZcbiAgICAhc3RhdGUuZW5kZWQgJiZcbiAgICAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKVxuICApIHtcbiAgICBjb25zdCBsZW4gPSBzdGF0ZS5sZW5ndGhcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKVxuICAgIHN0cmVhbS5yZWFkKDApXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gRGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrXG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZVxufVxuXG4vLyBBYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRocm93IG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpXG59XG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICBjb25zdCBzcmMgPSB0aGlzXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoc3RhdGUucGlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFzdGF0ZS5tdWx0aUF3YWl0RHJhaW4pIHtcbiAgICAgIHN0YXRlLm11bHRpQXdhaXREcmFpbiA9IHRydWVcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbmV3IFNhZmVTZXQoc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPyBbc3RhdGUuYXdhaXREcmFpbldyaXRlcnNdIDogW10pXG4gICAgfVxuICB9XG4gIHN0YXRlLnBpcGVzLnB1c2goZGVzdClcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzLmxlbmd0aCwgcGlwZU9wdHMpXG4gIGNvbnN0IGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVyclxuICBjb25zdCBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGVcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pXG4gIGVsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKVxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSlcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKVxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWVcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpXG4gICAgZGVzdC5lbmQoKVxuICB9XG4gIGxldCBvbmRyYWluXG4gIGxldCBjbGVhbmVkVXAgPSBmYWxzZVxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJylcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuLlxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBpZiAob25kcmFpbikge1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSlcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgY2xlYW5lZFVwID0gdHJ1ZVxuXG4gICAgLy8gSWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAob25kcmFpbiAmJiBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKClcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgaWYgKCFjbGVhbmVkVXApIHtcbiAgICAgIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDEgJiYgc3RhdGUucGlwZXNbMF0gPT09IGRlc3QpIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIDApXG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gZGVzdFxuICAgICAgICBzdGF0ZS5tdWx0aUF3YWl0RHJhaW4gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPiAxICYmIHN0YXRlLnBpcGVzLmluY2x1ZGVzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5hZGQoZGVzdClcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpXG4gICAgfVxuICAgIGlmICghb25kcmFpbikge1xuICAgICAgLy8gV2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAgICAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gICAgICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAgICAgLy8gdG9vIHNsb3cuXG4gICAgICBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KVxuICAgICAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKVxuICAgIGNvbnN0IHJldCA9IGRlc3Qud3JpdGUoY2h1bmspXG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIHBhdXNlKClcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gSG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcilcbiAgICB1bnBpcGUoKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBpZiAoZGVzdC5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICBjb25zdCBzID0gZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAocyAmJiAhcy5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgLy8gVXNlciBpbmNvcnJlY3RseSBlbWl0dGVkICdlcnJvcicgZGlyZWN0bHkgb24gdGhlIHN0cmVhbS5cbiAgICAgICAgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKVxuICAgIHNyYy51bnBpcGUoZGVzdClcbiAgfVxuXG4gIC8vIFRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvLlxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpXG5cbiAgLy8gU3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmIChkZXN0LndyaXRhYmxlTmVlZERyYWluID09PSB0cnVlKSB7XG4gICAgcGF1c2UoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJylcbiAgICBzcmMucmVzdW1lKClcbiAgfVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlXG5cbiAgICAvLyBgb25kcmFpbmAgd2lsbCBjYWxsIGRpcmVjdGx5LFxuICAgIC8vIGB0aGlzYCBtYXliZSBub3QgYSByZWZlcmVuY2UgdG8gZGVzdCxcbiAgICAvLyBzbyB3ZSB1c2UgdGhlIHJlYWwgZGVzdCBoZXJlLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9PT0gZGVzdCkge1xuICAgICAgZGVidWcoJ3BpcGVPbkRyYWluJywgMSlcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoc3RhdGUubXVsdGlBd2FpdERyYWluKSB7XG4gICAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuZGVsZXRlKGRlc3QpXG4gICAgfVxuICAgIGlmICgoIXN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzIHx8IHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLnNpemUgPT09IDApICYmIHNyYy5saXN0ZW5lckNvdW50KCdkYXRhJykpIHtcbiAgICAgIHNyYy5yZXN1bWUoKVxuICAgIH1cbiAgfVxufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH1cblxuICAvLyBJZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgY29uc3QgZGVzdHMgPSBzdGF0ZS5waXBlc1xuICAgIHN0YXRlLnBpcGVzID0gW11cbiAgICB0aGlzLnBhdXNlKClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3RzLmxlbmd0aDsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgY29uc3QgaW5kZXggPSBBcnJheVByb3RvdHlwZUluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSlcbiAgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA9PT0gMCkgdGhpcy5wYXVzZSgpXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIGNvbnN0IHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuXG4gICAgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZC5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKClcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZVxuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZVxuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKVxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcylcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub25cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgY29uc3QgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbilcbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuUmVhZGFibGUucHJvdG90eXBlLm9mZiA9IFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lclxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICBjb25zdCByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICBjb25zdCBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgc3RhdGVba1BhdXNlZF0gPT09IGZhbHNlKSB7XG4gICAgLy8gRmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZVxuXG4gICAgLy8gQ3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWUuXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBudWxsXG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJylcbiAgc2VsZi5yZWFkKDApXG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJylcbiAgICAvLyBXZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpLlxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmdcbiAgICByZXN1bWUodGhpcywgc3RhdGUpXG4gIH1cbiAgc3RhdGVba1BhdXNlZF0gPSBmYWxzZVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKVxuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApXG4gIH1cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2VcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gIGZsb3coc3RyZWFtKVxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMClcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKVxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZVtrUGF1c2VkXSA9IHRydWVcbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZylcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCk7XG59XG5cbi8vIFdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICBsZXQgcGF1c2VkID0gZmFsc2VcblxuICAvLyBUT0RPIChyb25hZyk6IFNob3VsZCB0aGlzLmRlc3Ryb3koZXJyKSBlbWl0XG4gIC8vICdlcnJvcicgb24gdGhlIHdyYXBwZWQgc3RyZWFtPyBXb3VsZCByZXF1aXJlXG4gIC8vIGEgc3RhdGljIGZhY3RvcnkgbWV0aG9kLCBlLmcuIFJlYWRhYmxlLndyYXAoc3RyZWFtKS5cblxuICBzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICBpZiAoIXRoaXMucHVzaChjaHVuaykgJiYgc3RyZWFtLnBhdXNlKSB7XG4gICAgICBwYXVzZWQgPSB0cnVlXG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cbiAgfSlcbiAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gIH0pXG4gIHN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgZXJyb3JPckRlc3Ryb3kodGhpcywgZXJyKVxuICB9KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH0pXG4gIHN0cmVhbS5vbignZGVzdHJveScsICgpID0+IHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9KVxuICB0aGlzLl9yZWFkID0gKCkgPT4ge1xuICAgIGlmIChwYXVzZWQgJiYgc3RyZWFtLnJlc3VtZSkge1xuICAgICAgcGF1c2VkID0gZmFsc2VcbiAgICAgIHN0cmVhbS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy4gSW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGNvbnN0IHN0cmVhbUtleXMgPSBPYmplY3RLZXlzKHN0cmVhbSlcbiAgZm9yIChsZXQgaiA9IDE7IGogPCBzdHJlYW1LZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgaSA9IHN0cmVhbUtleXNbal1cbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBzdHJlYW1baV0uYmluZChzdHJlYW0pXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5SZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzdHJlYW1Ub0FzeW5jSXRlcmF0b3IodGhpcylcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVRvQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zKVxufVxuZnVuY3Rpb24gc3RyZWFtVG9Bc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0cmVhbS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtID0gUmVhZGFibGUud3JhcChzdHJlYW0sIHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KVxuICB9XG4gIGNvbnN0IGl0ZXIgPSBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucylcbiAgaXRlci5zdHJlYW0gPSBzdHJlYW1cbiAgcmV0dXJuIGl0ZXJcbn1cbmFzeW5jIGZ1bmN0aW9uKiBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBsZXQgY2FsbGJhY2sgPSBub3BcbiAgZnVuY3Rpb24gbmV4dChyZXNvbHZlKSB7XG4gICAgaWYgKHRoaXMgPT09IHN0cmVhbSkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgY2FsbGJhY2sgPSBub3BcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBuZXh0KVxuICBsZXQgZXJyb3JcbiAgY29uc3QgY2xlYW51cCA9IGVvcyhcbiAgICBzdHJlYW0sXG4gICAge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBlcnJvciA9IGVyciA/IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKSA6IG51bGxcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGNhbGxiYWNrID0gbm9wXG4gICAgfVxuICApXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gc3RyZWFtLmRlc3Ryb3llZCA/IG51bGwgOiBzdHJlYW0ucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgY2h1bmtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShuZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBhZ2dyZWdhdGVUd29FcnJvcnMoZXJyb3IsIGVycilcbiAgICB0aHJvdyBlcnJvclxuICB9IGZpbmFsbHkge1xuICAgIGlmIChcbiAgICAgIChlcnJvciB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRlc3Ryb3lPblJldHVybikgIT09IGZhbHNlKSAmJlxuICAgICAgKGVycm9yID09PSB1bmRlZmluZWQgfHwgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmF1dG9EZXN0cm95KVxuICAgICkge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHN0cmVhbSwgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9mZigncmVhZGFibGUnLCBuZXh0KVxuICAgICAgY2xlYW51cCgpXG4gICAgfVxuICB9XG59XG5cbi8vIE1ha2luZyBpdCBleHBsaWNpdCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZVxuLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4vLyB1c2VybGFuZCB3aWxsIGZhaWwuXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlLnByb3RvdHlwZSwge1xuICByZWFkYWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICAgICAgLy8gci5yZWFkYWJsZSA9PT0gZmFsc2UgbWVhbnMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgYSBEdXBsZXggc3RyZWFtXG4gICAgICAvLyB3aGVyZSB0aGUgcmVhZGFibGUgc2lkZSB3YXMgZGlzYWJsZWQgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICAvLyBDb21wYXQuIFRoZSB1c2VyIG1pZ2h0IG1hbnVhbGx5IGRpc2FibGUgcmVhZGFibGUgc2lkZSB0aHJvdWdoXG4gICAgICAvLyBkZXByZWNhdGVkIHNldHRlci5cbiAgICAgIHJldHVybiAhIXIgJiYgci5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgIXIuZGVzdHJveWVkICYmICFyLmVycm9yRW1pdHRlZCAmJiAhci5lbmRFbWl0dGVkXG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LlxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9ICEhdmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZWFkYWJsZURpZFJlYWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVBYm9ydGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgfHwgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkKSAmJlxuICAgICAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkXG4gICAgICApXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUJ1ZmZlcjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUZsb3dpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRW5jb2Rpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgPyB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgZXJyb3JlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCA6IG51bGxcbiAgICB9XG4gIH0sXG4gIGNsb3NlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuY2xvc2VkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkIDogZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gV2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkIDogZmFsc2VcbiAgICB9XG4gIH1cbn0pXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RhdGUucHJvdG90eXBlLCB7XG4gIC8vIExlZ2FjeSBnZXR0ZXIgZm9yIGBwaXBlc0NvdW50YC5cbiAgcGlwZXNDb3VudDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5waXBlcy5sZW5ndGhcbiAgICB9XG4gIH0sXG4gIC8vIExlZ2FjeSBwcm9wZXJ0eSBmb3IgYHBhdXNlZGAuXG4gIHBhdXNlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1trUGF1c2VkXSAhPT0gZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1trUGF1c2VkXSA9ICEhdmFsdWVcbiAgICB9XG4gIH1cbn0pXG5cbi8vIEV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWQuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gIGxldCByZXRcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpXG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gUmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0LlxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJylcbiAgICBlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKVxuICAgIGVsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKClcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdC5cbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKVxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aClcblxuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lcnJvcmVkICYmICFzdGF0ZS5jbG9zZUVtaXR0ZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWVcbiAgICBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICBpZiAoc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbmRXcml0YWJsZU5ULCBzdHJlYW0pXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGwuXG4gICAgICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgICAgIGNvbnN0IGF1dG9EZXN0cm95ID1cbiAgICAgICAgIXdTdGF0ZSB8fFxuICAgICAgICAod1N0YXRlLmF1dG9EZXN0cm95ICYmXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IHRoZSB3cml0YWJsZSB0byBldmVyICdmaW5pc2gnXG4gICAgICAgICAgLy8gaWYgd3JpdGFibGUgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgKHdTdGF0ZS5maW5pc2hlZCB8fCB3U3RhdGUud3JpdGFibGUgPT09IGZhbHNlKSlcbiAgICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbmRXcml0YWJsZU5UKHN0cmVhbSkge1xuICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS53cml0YWJsZSAmJiAhc3RyZWFtLndyaXRhYmxlRW5kZWQgJiYgIXN0cmVhbS5kZXN0cm95ZWRcbiAgaWYgKHdyaXRhYmxlKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gIH1cbn1cblJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKVxufVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cblJlYWRhYmxlLmZyb21XZWIgPSBmdW5jdGlvbiAocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtUmVhZGFibGVGcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpXG59XG5SZWFkYWJsZS50b1dlYiA9IGZ1bmN0aW9uIChzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdSZWFkYWJsZVN0cmVhbUZyb21TdHJlYW1SZWFkYWJsZShzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucylcbn1cblJlYWRhYmxlLndyYXAgPSBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmLCBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgb2JqZWN0TW9kZTpcbiAgICAgIChfcmVmID1cbiAgICAgICAgKF9zcmMkcmVhZGFibGVPYmplY3RNbyA9IHNyYy5yZWFkYWJsZU9iamVjdE1vZGUpICE9PSBudWxsICYmIF9zcmMkcmVhZGFibGVPYmplY3RNbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgICAgICAgICA6IHNyYy5vYmplY3RNb2RlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfcmVmXG4gICAgICAgIDogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHNyYywgZXJyKVxuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgfSkud3JhcChzcmMpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MathFloor, NumberIsInteger } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { validateInteger } = __webpack_require__(/*! ../validators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\")\nconst { ERR_INVALID_ARG_VALUE } = (__webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\").codes)\nlet defaultHighWaterMarkBytes = 16 * 1024\nlet defaultHighWaterMarkObjectMode = 16\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n  validateInteger(value, 'value', 0)\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value\n  } else {\n    defaultHighWaterMarkBytes = value\n  }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'\n      throw new ERR_INVALID_ARG_VALUE(name, hwm)\n    }\n    return MathFloor(hwm)\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode)\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n  setDefaultHighWaterMark\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUN2RSxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsbUhBQWU7QUFDbkQsUUFBUSx3QkFBd0IsRUFBRSw0SUFBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE1hdGhGbG9vciwgTnVtYmVySXNJbnRlZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgdmFsaWRhdGVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IHsgRVJSX0lOVkFMSURfQVJHX1ZBTFVFIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5sZXQgZGVmYXVsdEhpZ2hXYXRlck1hcmtCeXRlcyA9IDE2ICogMTAyNFxubGV0IGRlZmF1bHRIaWdoV2F0ZXJNYXJrT2JqZWN0TW9kZSA9IDE2XG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbFxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsob2JqZWN0TW9kZSkge1xuICByZXR1cm4gb2JqZWN0TW9kZSA/IGRlZmF1bHRIaWdoV2F0ZXJNYXJrT2JqZWN0TW9kZSA6IGRlZmF1bHRIaWdoV2F0ZXJNYXJrQnl0ZXNcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRIaWdoV2F0ZXJNYXJrKG9iamVjdE1vZGUsIHZhbHVlKSB7XG4gIHZhbGlkYXRlSW50ZWdlcih2YWx1ZSwgJ3ZhbHVlJywgMClcbiAgaWYgKG9iamVjdE1vZGUpIHtcbiAgICBkZWZhdWx0SGlnaFdhdGVyTWFya09iamVjdE1vZGUgPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRIaWdoV2F0ZXJNYXJrQnl0ZXMgPSB2YWx1ZVxuICB9XG59XG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIGNvbnN0IGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVySXNJbnRlZ2VyKGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRHVwbGV4ID8gYG9wdGlvbnMuJHtkdXBsZXhLZXl9YCA6ICdvcHRpb25zLmhpZ2hXYXRlck1hcmsnXG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKG5hbWUsIGh3bSlcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhGbG9vcihod20pXG4gIH1cblxuICAvLyBEZWZhdWx0IHZhbHVlXG4gIHJldHVybiBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayhzdGF0ZS5vYmplY3RNb2RlKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcmssXG4gIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrLFxuICBzZXREZWZhdWx0SGlnaFdhdGVyTWFya1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/transform.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/transform.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nconst { ObjectSetPrototypeOf, Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Transform\nconst { ERR_METHOD_NOT_IMPLEMENTED } = (__webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\").codes)\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\nconst { getHighWaterMark } = __webpack_require__(/*! ./state */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js\")\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)\nObjectSetPrototypeOf(Transform, Duplex)\nconst kCallback = Symbol('kCallback')\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options)\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options,\n      highWaterMark: null,\n      readableHighWaterMark,\n      // TODO (ronag): 0 is not optimal since we have\n      // a \"bug\" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\n    }\n  }\n  Duplex.call(this, options)\n\n  // We have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false\n  this[kCallback] = null\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform\n    if (typeof options.flush === 'function') this._flush = options.flush\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish', prefinish)\n}\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er, data) => {\n      if (er) {\n        if (cb) {\n          cb(er)\n        } else {\n          this.destroy(er)\n        }\n        return\n      }\n      if (data != null) {\n        this.push(data)\n      }\n      this.push(null)\n      if (cb) {\n        cb()\n      }\n    })\n  } else {\n    this.push(null)\n    if (cb) {\n      cb()\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this)\n  }\n}\nTransform.prototype._final = final\nTransform.prototype._transform = function (chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')\n}\nTransform.prototype._write = function (chunk, encoding, callback) {\n  const rState = this._readableState\n  const wState = this._writableState\n  const length = rState.length\n  this._transform(chunk, encoding, (err, val) => {\n    if (err) {\n      callback(err)\n      return\n    }\n    if (val != null) {\n      this.push(val)\n    }\n    if (\n      wState.ended ||\n      // Backwards compat.\n      length === rState.length ||\n      // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback()\n    } else {\n      this[kCallback] = callback\n    }\n  })\n}\nTransform.prototype._read = function () {\n  if (this[kCallback]) {\n    const callback = this[kCallback]\n    this[kCallback] = null\n    callback()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLHlIQUF3QjtBQUN6RTtBQUNBLFFBQVEsNkJBQTZCLEVBQUUsNElBQWtDO0FBQ3pFLGVBQWUsbUJBQU8sQ0FBQyxrSEFBVTtBQUNqQyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsZ0hBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgT2JqZWN0U2V0UHJvdG90eXBlT2YsIFN5bWJvbCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybVxuY29uc3QgeyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKS5jb2Rlc1xuY29uc3QgRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXgnKVxuY29uc3QgeyBnZXRIaWdoV2F0ZXJNYXJrIH0gPSByZXF1aXJlKCcuL3N0YXRlJylcbk9iamVjdFNldFByb3RvdHlwZU9mKFRyYW5zZm9ybS5wcm90b3R5cGUsIER1cGxleC5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihUcmFuc2Zvcm0sIER1cGxleClcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgna0NhbGxiYWNrJylcbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKVxuXG4gIC8vIFRPRE8gKHJvbmFnKTogVGhpcyBzaG91bGQgcHJlZmVyYWJseSBhbHdheXMgYmVcbiAgLy8gYXBwbGllZCBidXQgd291bGQgYmUgc2VtdmVyLW1ham9yLiBPciBldmVuIGJldHRlcjtcbiAgLy8gbWFrZSBUcmFuc2Zvcm0gYSBSZWFkYWJsZSB3aXRoIHRoZSBXcml0YWJsZSBpbnRlcmZhY2UuXG4gIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IG9wdGlvbnMgPyBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB0cnVlKSA6IG51bGxcbiAgaWYgKHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9PT0gMCkge1xuICAgIC8vIEEgRHVwbGV4IHdpbGwgYnVmZmVyIGJvdGggb24gdGhlIHdyaXRhYmxlIGFuZCByZWFkYWJsZSBzaWRlIHdoaWxlXG4gICAgLy8gYSBUcmFuc2Zvcm0ganVzdCB3YW50cyB0byBidWZmZXIgaHdtIG51bWJlciBvZiBlbGVtZW50cy4gVG8gYXZvaWRcbiAgICAvLyBidWZmZXJpbmcgdHdpY2Ugd2UgZGlzYWJsZSBidWZmZXJpbmcgb24gdGhlIHdyaXRhYmxlIHNpZGUuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoaWdoV2F0ZXJNYXJrOiBudWxsLFxuICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLFxuICAgICAgLy8gVE9ETyAocm9uYWcpOiAwIGlzIG5vdCBvcHRpbWFsIHNpbmNlIHdlIGhhdmVcbiAgICAgIC8vIGEgXCJidWdcIiB3aGVyZSB3ZSBjaGVjayBuZWVkRHJhaW4gYmVmb3JlIGNhbGxpbmcgX3dyaXRlIGFuZCBub3QgYWZ0ZXIuXG4gICAgICAvLyBSZWZzOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjg4N1xuICAgICAgLy8gUmVmczogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzU5NDFcbiAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyazogb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcmsgfHwgMFxuICAgIH1cbiAgfVxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKVxuXG4gIC8vIFdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2VcbiAgdGhpc1trQ2FsbGJhY2tdID0gbnVsbFxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2hcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdC4gU29tZSBUcmFuc2Zvcm0gc3RyZWFtcyBpbmNvcnJlY3RseSBpbXBsZW1lbnQgX2ZpbmFsXG4gIC8vIGluc3RlYWQgb2Ygb3IgaW4gYWRkaXRpb24gdG8gX2ZsdXNoLiBCeSB1c2luZyAncHJlZmluaXNoJyBpbnN0ZWFkIG9mXG4gIC8vIGltcGxlbWVudGluZyBfZmluYWwgd2UgY29udGludWUgc3VwcG9ydGluZyB0aGlzIHVuZm9ydHVuYXRlIHVzZSBjYXNlLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpXG59XG5mdW5jdGlvbiBmaW5hbChjYikge1xuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKChlciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wdXNoKGRhdGEpXG4gICAgICB9XG4gICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgaWYgKHRoaXMuX2ZpbmFsICE9PSBmaW5hbCkge1xuICAgIGZpbmFsLmNhbGwodGhpcylcbiAgfVxufVxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZmluYWwgPSBmaW5hbFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdGhyb3cgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKVxufVxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjb25zdCByU3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHdTdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgbGVuZ3RoID0gclN0YXRlLmxlbmd0aFxuICB0aGlzLl90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCAoZXJyLCB2YWwpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnB1c2godmFsKVxuICAgIH1cbiAgICBpZiAoXG4gICAgICB3U3RhdGUuZW5kZWQgfHxcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQuXG4gICAgICBsZW5ndGggPT09IHJTdGF0ZS5sZW5ndGggfHxcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQuXG4gICAgICByU3RhdGUubGVuZ3RoIDwgclN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trQ2FsbGJhY2tdID0gY2FsbGJhY2tcbiAgICB9XG4gIH0pXG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpc1trQ2FsbGJhY2tdKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzW2tDYWxsYmFja11cbiAgICB0aGlzW2tDYWxsYmFja10gPSBudWxsXG4gICAgY2FsbGJhY2soKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/transform.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed')\nconst kIsErrored = SymbolFor('nodejs.stream.errored')\nconst kIsReadable = SymbolFor('nodejs.stream.readable')\nconst kIsWritable = SymbolFor('nodejs.stream.writable')\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed')\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')\nfunction isReadableNodeStream(obj, strict = false) {\n  var _obj$_readableState\n  return !!(\n    (\n      obj &&\n      typeof obj.pipe === 'function' &&\n      typeof obj.on === 'function' &&\n      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&\n      (!obj._writableState ||\n        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined\n          ? undefined\n          : _obj$_readableState.readable) !== false) &&\n      // Duplex\n      (!obj._writableState || obj._readableState)\n    ) // Writable has .pipe.\n  )\n}\n\nfunction isWritableNodeStream(obj) {\n  var _obj$_writableState\n  return !!(\n    (\n      obj &&\n      typeof obj.write === 'function' &&\n      typeof obj.on === 'function' &&\n      (!obj._readableState ||\n        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined\n          ? undefined\n          : _obj$_writableState.writable) !== false)\n    ) // Duplex\n  )\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    obj._readableState &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  )\n}\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))\n  )\n}\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  )\n}\nfunction isWritableStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')\n}\nfunction isTransformStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')\n}\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null) return false\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'\n  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableEnded === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null\n  return wState.ended\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableFinished === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null\n  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null\n  if (stream.readableEnded === true) return true\n  const rState = stream._readableState\n  if (!rState || rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null\n  return rState.ended\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream)) return null\n  const rState = stream._readableState\n  if (rState !== null && rState !== undefined && rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null\n  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))\n}\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)\n}\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (isDestroyed(stream)) {\n    return true\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n    return false\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n    return false\n  }\n  return true\n}\nfunction isWritableErrored(stream) {\n  var _stream$_writableStat, _stream$_writableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.writableErrored) {\n    return stream.writableErrored\n  }\n  return (_stream$_writableStat =\n    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined\n      ? undefined\n      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined\n    ? _stream$_writableStat\n    : null\n}\nfunction isReadableErrored(stream) {\n  var _stream$_readableStat, _stream$_readableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.readableErrored) {\n    return stream.readableErrored\n  }\n  return (_stream$_readableStat =\n    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined\n      ? undefined\n      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined\n    ? _stream$_readableStat\n    : null\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  if (\n    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||\n    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'\n  ) {\n    return (\n      (wState === null || wState === undefined ? undefined : wState.closed) ||\n      (rState === null || rState === undefined ? undefined : rState.closed)\n    )\n  }\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed\n  }\n  return null\n}\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  )\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)\n}\nfunction isServerRequest(stream) {\n  var _stream$req\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===\n      undefined\n  )\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return (\n    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n  )\n}\nfunction isDisturbed(stream) {\n  var _stream$kIsDisturbed\n  return !!(\n    stream &&\n    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined\n      ? _stream$kIsDisturbed\n      : stream.readableDidRead || stream.readableAborted)\n  )\n}\nfunction isErrored(stream) {\n  var _ref,\n    _ref2,\n    _ref3,\n    _ref4,\n    _ref5,\n    _stream$kIsErrored,\n    _stream$_readableStat3,\n    _stream$_writableStat3,\n    _stream$_readableStat4,\n    _stream$_writableStat4\n  return !!(\n    stream &&\n    ((_ref =\n      (_ref2 =\n        (_ref3 =\n          (_ref4 =\n            (_ref5 =\n              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined\n                ? _stream$kIsErrored\n                : stream.readableErrored) !== null && _ref5 !== undefined\n              ? _ref5\n              : stream.writableErrored) !== null && _ref4 !== undefined\n            ? _ref4\n            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined\n            ? undefined\n            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined\n          ? _ref3\n          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined\n          ? undefined\n          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined\n        ? _ref2\n        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined\n        ? undefined\n        : _stream$_readableStat4.errored) !== null && _ref !== undefined\n      ? _ref\n      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined\n      ? undefined\n      : _stream$_writableStat4.errored)\n  )\n}\nmodule.exports = {\n  isDestroyed,\n  kIsDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isErrored,\n  kIsErrored,\n  isReadable,\n  kIsReadable,\n  kIsClosedPromise,\n  kControllerErrorFunction,\n  kIsWritable,\n  isClosed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableEnded,\n  isReadableFinished,\n  isReadableErrored,\n  isNodeStream,\n  isWebStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableEnded,\n  isWritableFinished,\n  isWritableErrored,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose,\n  isTransformStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxpREFBaUQsRUFBRSxtQkFBTyxDQUFDLHlIQUF3Qjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBTeW1ib2xBc3luY0l0ZXJhdG9yLCBTeW1ib2xJdGVyYXRvciwgU3ltYm9sRm9yIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcblxuLy8gV2UgbmVlZCB0byB1c2UgU3ltYm9sRm9yIHRvIG1ha2UgdGhlc2UgZ2xvYmFsbHkgYXZhaWxhYmxlXG4vLyBmb3IgaW50ZXJvcHQgd2l0aCByZWFkYWJsZS1zdHJlYW0sIGkuZS4gcmVhZGFibGUtc3RyZWFtXG4vLyBhbmQgbm9kZSBjb3JlIG5lZWRzIHRvIGJlIGFibGUgdG8gcmVhZC93cml0ZSBwcml2YXRlIHN0YXRlXG4vLyBmcm9tIGVhY2ggb3RoZXIgZm9yIHByb3BlciBpbnRlcm9wZXJhYmlsaXR5LlxuY29uc3Qga0lzRGVzdHJveWVkID0gU3ltYm9sRm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpXG5jb25zdCBrSXNFcnJvcmVkID0gU3ltYm9sRm9yKCdub2RlanMuc3RyZWFtLmVycm9yZWQnKVxuY29uc3Qga0lzUmVhZGFibGUgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0ucmVhZGFibGUnKVxuY29uc3Qga0lzV3JpdGFibGUgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0ud3JpdGFibGUnKVxuY29uc3Qga0lzRGlzdHVyYmVkID0gU3ltYm9sRm9yKCdub2RlanMuc3RyZWFtLmRpc3R1cmJlZCcpXG5jb25zdCBrSXNDbG9zZWRQcm9taXNlID0gU3ltYm9sRm9yKCdub2RlanMud2Vic3RyZWFtLmlzQ2xvc2VkUHJvbWlzZScpXG5jb25zdCBrQ29udHJvbGxlckVycm9yRnVuY3Rpb24gPSBTeW1ib2xGb3IoJ25vZGVqcy53ZWJzdHJlYW0uY29udHJvbGxlckVycm9yRnVuY3Rpb24nKVxuZnVuY3Rpb24gaXNSZWFkYWJsZU5vZGVTdHJlYW0ob2JqLCBzdHJpY3QgPSBmYWxzZSkge1xuICB2YXIgX29iaiRfcmVhZGFibGVTdGF0ZVxuICByZXR1cm4gISEoXG4gICAgKFxuICAgICAgb2JqICYmXG4gICAgICB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICghc3RyaWN0IHx8ICh0eXBlb2Ygb2JqLnBhdXNlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoucmVzdW1lID09PSAnZnVuY3Rpb24nKSkgJiZcbiAgICAgICghb2JqLl93cml0YWJsZVN0YXRlIHx8XG4gICAgICAgICgoX29iaiRfcmVhZGFibGVTdGF0ZSA9IG9iai5fcmVhZGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX29iaiRfcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IF9vYmokX3JlYWRhYmxlU3RhdGUucmVhZGFibGUpICE9PSBmYWxzZSkgJiZcbiAgICAgIC8vIER1cGxleFxuICAgICAgKCFvYmouX3dyaXRhYmxlU3RhdGUgfHwgb2JqLl9yZWFkYWJsZVN0YXRlKVxuICAgICkgLy8gV3JpdGFibGUgaGFzIC5waXBlLlxuICApXG59XG5cbmZ1bmN0aW9uIGlzV3JpdGFibGVOb2RlU3RyZWFtKG9iaikge1xuICB2YXIgX29iaiRfd3JpdGFibGVTdGF0ZVxuICByZXR1cm4gISEoXG4gICAgKFxuICAgICAgb2JqICYmXG4gICAgICB0eXBlb2Ygb2JqLndyaXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoIW9iai5fcmVhZGFibGVTdGF0ZSB8fFxuICAgICAgICAoKF9vYmokX3dyaXRhYmxlU3RhdGUgPSBvYmouX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9vYmokX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBfb2JqJF93cml0YWJsZVN0YXRlLndyaXRhYmxlKSAhPT0gZmFsc2UpXG4gICAgKSAvLyBEdXBsZXhcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0R1cGxleE5vZGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAhIShcbiAgICBvYmogJiZcbiAgICB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICBvYmouX3JlYWRhYmxlU3RhdGUgJiZcbiAgICB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iai53cml0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5mdW5jdGlvbiBpc05vZGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgKG9iai5fcmVhZGFibGVTdGF0ZSB8fFxuICAgICAgb2JqLl93cml0YWJsZVN0YXRlIHx8XG4gICAgICAodHlwZW9mIG9iai53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgKHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nKSlcbiAgKVxufVxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKFxuICAgIG9iaiAmJlxuICAgICFpc05vZGVTdHJlYW0ob2JqKSAmJlxuICAgIHR5cGVvZiBvYmoucGlwZVRocm91Z2ggPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouY2FuY2VsID09PSAnZnVuY3Rpb24nXG4gIClcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgIWlzTm9kZVN0cmVhbShvYmopICYmIHR5cGVvZiBvYmouZ2V0V3JpdGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouYWJvcnQgPT09ICdmdW5jdGlvbicpXG59XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiAhaXNOb2RlU3RyZWFtKG9iaikgJiYgdHlwZW9mIG9iai5yZWFkYWJsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai53cml0YWJsZSA9PT0gJ29iamVjdCcpXG59XG5mdW5jdGlvbiBpc1dlYlN0cmVhbShvYmopIHtcbiAgcmV0dXJuIGlzUmVhZGFibGVTdHJlYW0ob2JqKSB8fCBpc1dyaXRhYmxlU3RyZWFtKG9iaikgfHwgaXNUcmFuc2Zvcm1TdHJlYW0ob2JqKVxufVxuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmosIGlzQXN5bmMpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgaWYgKGlzQXN5bmMgPT09IHRydWUpIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbEFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gIGlmIChpc0FzeW5jID09PSBmYWxzZSkgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbEFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG59XG5mdW5jdGlvbiBpc0Rlc3Ryb3llZChzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHdTdGF0ZSB8fCByU3RhdGVcbiAgcmV0dXJuICEhKHN0cmVhbS5kZXN0cm95ZWQgfHwgc3RyZWFtW2tJc0Rlc3Ryb3llZF0gfHwgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUuZGVzdHJveWVkKSlcbn1cblxuLy8gSGF2ZSBiZWVuIGVuZCgpOmQuXG5mdW5jdGlvbiBpc1dyaXRhYmxlRW5kZWQoc3RyZWFtKSB7XG4gIGlmICghaXNXcml0YWJsZU5vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgaWYgKHN0cmVhbS53cml0YWJsZUVuZGVkID09PSB0cnVlKSByZXR1cm4gdHJ1ZVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHdTdGF0ZSAhPT0gbnVsbCAmJiB3U3RhdGUgIT09IHVuZGVmaW5lZCAmJiB3U3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5lbmRlZCkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdTdGF0ZS5lbmRlZFxufVxuXG4vLyBIYXZlIGVtaXR0ZWQgJ2ZpbmlzaCcuXG5mdW5jdGlvbiBpc1dyaXRhYmxlRmluaXNoZWQoc3RyZWFtLCBzdHJpY3QpIHtcbiAgaWYgKCFpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLndyaXRhYmxlRmluaXNoZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAod1N0YXRlICE9PSBudWxsICYmIHdTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHdTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmZpbmlzaGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gISEod1N0YXRlLmZpbmlzaGVkIHx8IChzdHJpY3QgPT09IGZhbHNlICYmIHdTdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiB3U3RhdGUubGVuZ3RoID09PSAwKSlcbn1cblxuLy8gSGF2ZSBiZWVuIHB1c2gobnVsbCk6ZC5cbmZ1bmN0aW9uIGlzUmVhZGFibGVFbmRlZChzdHJlYW0pIHtcbiAgaWYgKCFpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLnJlYWRhYmxlRW5kZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5lbmRlZCkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHJTdGF0ZS5lbmRlZFxufVxuXG4vLyBIYXZlIGVtaXR0ZWQgJ2VuZCcuXG5mdW5jdGlvbiBpc1JlYWRhYmxlRmluaXNoZWQoc3RyZWFtLCBzdHJpY3QpIHtcbiAgaWYgKCFpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgaWYgKHJTdGF0ZSAhPT0gbnVsbCAmJiByU3RhdGUgIT09IHVuZGVmaW5lZCAmJiByU3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5lbmRFbWl0dGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gISEoclN0YXRlLmVuZEVtaXR0ZWQgfHwgKHN0cmljdCA9PT0gZmFsc2UgJiYgclN0YXRlLmVuZGVkID09PSB0cnVlICYmIHJTdGF0ZS5sZW5ndGggPT09IDApKVxufVxuZnVuY3Rpb24gaXNSZWFkYWJsZShzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbSAmJiBzdHJlYW1ba0lzUmVhZGFibGVdICE9IG51bGwpIHJldHVybiBzdHJlYW1ba0lzUmVhZGFibGVdXG4gIGlmICh0eXBlb2YgKHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHN0cmVhbS5yZWFkYWJsZSkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgaWYgKGlzRGVzdHJveWVkKHN0cmVhbSkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKSAmJiBzdHJlYW0ucmVhZGFibGUgJiYgIWlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0pXG59XG5mdW5jdGlvbiBpc1dyaXRhYmxlKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtICYmIHN0cmVhbVtrSXNXcml0YWJsZV0gIT0gbnVsbCkgcmV0dXJuIHN0cmVhbVtrSXNXcml0YWJsZV1cbiAgaWYgKHR5cGVvZiAoc3RyZWFtID09PSBudWxsIHx8IHN0cmVhbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyZWFtLndyaXRhYmxlKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICBpZiAoaXNEZXN0cm95ZWQoc3RyZWFtKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pICYmIHN0cmVhbS53cml0YWJsZSAmJiAhaXNXcml0YWJsZUVuZGVkKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzRmluaXNoZWQoc3RyZWFtLCBvcHRzKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5yZWFkYWJsZSkgIT09IGZhbHNlICYmIGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLndyaXRhYmxlKSAhPT0gZmFsc2UgJiYgaXNXcml0YWJsZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGVFcnJvcmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRfd3JpdGFibGVTdGF0LCBfc3RyZWFtJF93cml0YWJsZVN0YXQyXG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChzdHJlYW0ud3JpdGFibGVFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS53cml0YWJsZUVycm9yZWRcbiAgfVxuICByZXR1cm4gKF9zdHJlYW0kX3dyaXRhYmxlU3RhdCA9XG4gICAgKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDIgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDIgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0Mi5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RyZWFtJF93cml0YWJsZVN0YXQgIT09IHVuZGVmaW5lZFxuICAgID8gX3N0cmVhbSRfd3JpdGFibGVTdGF0XG4gICAgOiBudWxsXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlRXJyb3JlZChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0kX3JlYWRhYmxlU3RhdCwgX3N0cmVhbSRfcmVhZGFibGVTdGF0MlxuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoc3RyZWFtLnJlYWRhYmxlRXJyb3JlZCkge1xuICAgIHJldHVybiBzdHJlYW0ucmVhZGFibGVFcnJvcmVkXG4gIH1cbiAgcmV0dXJuIChfc3RyZWFtJF9yZWFkYWJsZVN0YXQgPVxuICAgIChfc3RyZWFtJF9yZWFkYWJsZVN0YXQyID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQyID09PSB1bmRlZmluZWRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIuZXJyb3JlZCkgIT09IG51bGwgJiYgX3N0cmVhbSRfcmVhZGFibGVTdGF0ICE9PSB1bmRlZmluZWRcbiAgICA/IF9zdHJlYW0kX3JlYWRhYmxlU3RhdFxuICAgIDogbnVsbFxufVxuZnVuY3Rpb24gaXNDbG9zZWQoc3RyZWFtKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyZWFtLmNsb3NlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5jbG9zZWRcbiAgfVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChcbiAgICB0eXBlb2YgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5jbG9zZWQpID09PSAnYm9vbGVhbicgfHxcbiAgICB0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5jbG9zZWQpID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh3U3RhdGUgPT09IG51bGwgfHwgd1N0YXRlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB3U3RhdGUuY2xvc2VkKSB8fFxuICAgICAgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5jbG9zZWQpXG4gICAgKVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyZWFtLl9jbG9zZWQgPT09ICdib29sZWFuJyAmJiBpc091dGdvaW5nTWVzc2FnZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5fY2xvc2VkXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbmZ1bmN0aW9uIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBzdHJlYW0uX2Nsb3NlZCA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fZGVmYXVsdEtlZXBBbGl2ZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fcmVtb3ZlZENvbm5lY3Rpb24gPT09ICdib29sZWFuJyAmJlxuICAgIHR5cGVvZiBzdHJlYW0uX3JlbW92ZWRDb250TGVuID09PSAnYm9vbGVhbidcbiAgKVxufVxuZnVuY3Rpb24gaXNTZXJ2ZXJSZXNwb25zZShzdHJlYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHJlYW0uX3NlbnQxMDAgPT09ICdib29sZWFuJyAmJiBpc091dGdvaW5nTWVzc2FnZShzdHJlYW0pXG59XG5mdW5jdGlvbiBpc1NlcnZlclJlcXVlc3Qoc3RyZWFtKSB7XG4gIHZhciBfc3RyZWFtJHJlcVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiBzdHJlYW0uX2NvbnN1bWluZyA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fZHVtcGVkID09PSAnYm9vbGVhbicgJiZcbiAgICAoKF9zdHJlYW0kcmVxID0gc3RyZWFtLnJlcSkgPT09IG51bGwgfHwgX3N0cmVhbSRyZXEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9zdHJlYW0kcmVxLnVwZ3JhZGVPckNvbm5lY3QpID09PVxuICAgICAgdW5kZWZpbmVkXG4gIClcbn1cbmZ1bmN0aW9uIHdpbGxFbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgc3RhdGUgPSB3U3RhdGUgfHwgclN0YXRlXG4gIHJldHVybiAoXG4gICAgKCFzdGF0ZSAmJiBpc1NlcnZlclJlc3BvbnNlKHN0cmVhbSkpIHx8ICEhKHN0YXRlICYmIHN0YXRlLmF1dG9EZXN0cm95ICYmIHN0YXRlLmVtaXRDbG9zZSAmJiBzdGF0ZS5jbG9zZWQgPT09IGZhbHNlKVxuICApXG59XG5mdW5jdGlvbiBpc0Rpc3R1cmJlZChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0ka0lzRGlzdHVyYmVkXG4gIHJldHVybiAhIShcbiAgICBzdHJlYW0gJiZcbiAgICAoKF9zdHJlYW0ka0lzRGlzdHVyYmVkID0gc3RyZWFtW2tJc0Rpc3R1cmJlZF0pICE9PSBudWxsICYmIF9zdHJlYW0ka0lzRGlzdHVyYmVkICE9PSB1bmRlZmluZWRcbiAgICAgID8gX3N0cmVhbSRrSXNEaXN0dXJiZWRcbiAgICAgIDogc3RyZWFtLnJlYWRhYmxlRGlkUmVhZCB8fCBzdHJlYW0ucmVhZGFibGVBYm9ydGVkKVxuICApXG59XG5mdW5jdGlvbiBpc0Vycm9yZWQoc3RyZWFtKSB7XG4gIHZhciBfcmVmLFxuICAgIF9yZWYyLFxuICAgIF9yZWYzLFxuICAgIF9yZWY0LFxuICAgIF9yZWY1LFxuICAgIF9zdHJlYW0ka0lzRXJyb3JlZCxcbiAgICBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzLFxuICAgIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMsXG4gICAgX3N0cmVhbSRfcmVhZGFibGVTdGF0NCxcbiAgICBfc3RyZWFtJF93cml0YWJsZVN0YXQ0XG4gIHJldHVybiAhIShcbiAgICBzdHJlYW0gJiZcbiAgICAoKF9yZWYgPVxuICAgICAgKF9yZWYyID1cbiAgICAgICAgKF9yZWYzID1cbiAgICAgICAgICAoX3JlZjQgPVxuICAgICAgICAgICAgKF9yZWY1ID1cbiAgICAgICAgICAgICAgKF9zdHJlYW0ka0lzRXJyb3JlZCA9IHN0cmVhbVtrSXNFcnJvcmVkXSkgIT09IG51bGwgJiYgX3N0cmVhbSRrSXNFcnJvcmVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IF9zdHJlYW0ka0lzRXJyb3JlZFxuICAgICAgICAgICAgICAgIDogc3RyZWFtLnJlYWRhYmxlRXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZjUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IF9yZWY1XG4gICAgICAgICAgICAgIDogc3RyZWFtLndyaXRhYmxlRXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZjQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBfcmVmNFxuICAgICAgICAgICAgOiAoX3N0cmVhbSRfcmVhZGFibGVTdGF0MyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX3N0cmVhbSRfcmVhZGFibGVTdGF0MyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzLmVycm9yRW1pdHRlZCkgIT09IG51bGwgJiYgX3JlZjMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gX3JlZjNcbiAgICAgICAgICA6IChfc3RyZWFtJF93cml0YWJsZVN0YXQzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF93cml0YWJsZVN0YXQzID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0My5lcnJvckVtaXR0ZWQpICE9PSBudWxsICYmIF9yZWYyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfcmVmMlxuICAgICAgICA6IChfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0ID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0LmVycm9yZWQpICE9PSBudWxsICYmIF9yZWYgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfcmVmXG4gICAgICA6IChfc3RyZWFtJF93cml0YWJsZVN0YXQ0ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF93cml0YWJsZVN0YXQ0ID09PSB1bmRlZmluZWRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQuZXJyb3JlZClcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVzdHJveWVkLFxuICBrSXNEZXN0cm95ZWQsXG4gIGlzRGlzdHVyYmVkLFxuICBrSXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAga0lzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAga0lzUmVhZGFibGUsXG4gIGtJc0Nsb3NlZFByb21pc2UsXG4gIGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbixcbiAga0lzV3JpdGFibGUsXG4gIGlzQ2xvc2VkLFxuICBpc0R1cGxleE5vZGVTdHJlYW0sXG4gIGlzRmluaXNoZWQsXG4gIGlzSXRlcmFibGUsXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlYWRhYmxlRW5kZWQsXG4gIGlzUmVhZGFibGVGaW5pc2hlZCxcbiAgaXNSZWFkYWJsZUVycm9yZWQsXG4gIGlzTm9kZVN0cmVhbSxcbiAgaXNXZWJTdHJlYW0sXG4gIGlzV3JpdGFibGUsXG4gIGlzV3JpdGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlRW5kZWQsXG4gIGlzV3JpdGFibGVGaW5pc2hlZCxcbiAgaXNXcml0YWJsZUVycm9yZWQsXG4gIGlzU2VydmVyUmVxdWVzdCxcbiAgaXNTZXJ2ZXJSZXNwb25zZSxcbiAgd2lsbEVtaXRDbG9zZSxcbiAgaXNUcmFuc2Zvcm1TdHJlYW1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst process = __webpack_require__(/*! process/ */ \"(rsc)/../node_modules/process/index.js\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n;('use strict')\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = __webpack_require__(/*! ../../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nmodule.exports = Writable\nWritable.WritableState = WritableState\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\")\nconst Stream = (__webpack_require__(/*! ./legacy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream)\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js\")\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = (__webpack_require__(/*! ../../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\").codes)\nconst { errorOrDestroy } = destroyImpl\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Writable, Stream)\nfunction nop() {}\nconst kOnFinished = Symbol('kOnFinished')\nfunction WritableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // if _final has been called.\n  this.finalCalled = false\n\n  // drain event flag.\n  this.needDrain = false\n  // At the start of calling end()\n  this.ending = false\n  // When end() has been called, and returned.\n  this.ended = false\n  // When 'finish' is emitted.\n  this.finished = false\n\n  // Has it been destroyed\n  this.destroyed = false\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false)\n  this.decodeStrings = !noDecode\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream)\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  this.writecb = null\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null\n  resetBuffer(this)\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n  this[kOnFinished] = []\n}\nfunction resetBuffer(state) {\n  state.buffered = []\n  state.bufferedIndex = 0\n  state.allBuffers = true\n  state.allNoop = true\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)\n}\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return this.buffered.length - this.bufferedIndex\n  }\n})\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)\n  this._writableState = new WritableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write\n    if (typeof options.writev === 'function') this._writev = options.writev\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.final === 'function') this._final = options.final\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    const state = this._writableState\n    if (!state.writing) {\n      clearBuffer(this, state)\n    }\n    finishMaybe(this, state)\n  })\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function (object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true\n    if (this !== Writable) return false\n    return object && object._writableState instanceof WritableState\n  }\n})\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())\n}\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = state.defaultEncoding\n  } else {\n    if (!encoding) encoding = state.defaultEncoding\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n    if (typeof cb !== 'function') cb = nop\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES()\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding)\n        encoding = 'buffer'\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer'\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = 'buffer'\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  let err\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END()\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write')\n  }\n  if (err) {\n    process.nextTick(cb, err)\n    errorOrDestroy(stream, err, true)\n    return err\n  }\n  state.pendingcb++\n  return writeOrBuffer(stream, state, chunk, encoding, cb)\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true\n}\nWritable.prototype.cork = function () {\n  this._writableState.corked++\n}\nWritable.prototype.uncork = function () {\n  const state = this._writableState\n  if (state.corked) {\n    state.corked--\n    if (!state.writing) clearBuffer(this, state)\n  }\n}\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)\n  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n  this._writableState.defaultEncoding = encoding\n  return this\n}\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length\n  state.length += len\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({\n      chunk,\n      encoding,\n      callback\n    })\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false\n    }\n  } else {\n    state.writelen = len\n    state.writecb = callback\n    state.writing = true\n    state.sync = true\n    stream._write(chunk, encoding, state.onwrite)\n    state.sync = false\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len\n  state.writecb = cb\n  state.writing = true\n  state.sync = true\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))\n  else if (writev) stream._writev(chunk, state.onwrite)\n  else stream._write(chunk, encoding, state.onwrite)\n  state.sync = false\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb\n  cb(er)\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state)\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er)\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState\n  const sync = state.sync\n  const cb = state.writecb\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())\n    return\n  }\n  state.writing = false\n  state.writecb = null\n  state.length -= state.writelen\n  state.writelen = 0\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb)\n    } else {\n      onwriteError(stream, state, er, cb)\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state)\n    }\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++\n      } else {\n        state.afterWriteTickInfo = {\n          count: 1,\n          cb,\n          stream,\n          state\n        }\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo)\n      }\n    } else {\n      afterWrite(stream, state, 1, cb)\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null\n  return afterWrite(stream, state, count, cb)\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain\n  if (needDrain) {\n    state.needDrain = false\n    stream.emit('drain')\n  }\n  while (count-- > 0) {\n    state.pendingcb--\n    cb()\n  }\n  if (state.destroyed) {\n    errorBuffer(state)\n  }\n  finishMaybe(stream, state)\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    var _state$errored\n    const { chunk, callback } = state.buffered[n]\n    const len = state.objectMode ? 1 : chunk.length\n    state.length -= len\n    callback(\n      (_state$errored = state.errored) !== null && _state$errored !== undefined\n        ? _state$errored\n        : new ERR_STREAM_DESTROYED('write')\n    )\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    var _state$errored2\n    onfinishCallbacks[i](\n      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined\n        ? _state$errored2\n        : new ERR_STREAM_DESTROYED('end')\n    )\n  }\n  resetBuffer(state)\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return\n  }\n  const { buffered, bufferedIndex, objectMode } = state\n  const bufferedLength = buffered.length - bufferedIndex\n  if (!bufferedLength) {\n    return\n  }\n  let i = bufferedIndex\n  state.bufferProcessing = true\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1\n    const callback = state.allNoop\n      ? nop\n      : (err) => {\n          for (let n = i; n < buffered.length; ++n) {\n            buffered[n].callback(err)\n          }\n        }\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)\n    chunks.allBuffers = state.allBuffers\n    doWrite(stream, state, true, state.length, chunks, '', callback)\n    resetBuffer(state)\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i]\n      buffered[i++] = null\n      const len = objectMode ? 1 : chunk.length\n      doWrite(stream, state, false, len, chunk, encoding, callback)\n    } while (i < buffered.length && !state.writing)\n    if (i === buffered.length) {\n      resetBuffer(state)\n    } else if (i > 256) {\n      buffered.splice(0, i)\n      state.bufferedIndex = 0\n    } else {\n      state.bufferedIndex = i\n    }\n  }\n  state.bufferProcessing = false\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev(\n      [\n        {\n          chunk,\n          encoding\n        }\n      ],\n      cb\n    )\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')\n  }\n}\nWritable.prototype._writev = null\nWritable.prototype.end = function (chunk, encoding, cb) {\n  const state = this._writableState\n  if (typeof chunk === 'function') {\n    cb = chunk\n    chunk = null\n    encoding = null\n  } else if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n  let err\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this, chunk, encoding)\n    if (ret instanceof Error) {\n      err = ret\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1\n    this.uncork()\n  }\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true\n    finishMaybe(this, state, true)\n    state.ended = true\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end')\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end')\n  }\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb, err)\n    } else {\n      state[kOnFinished].push(cb)\n    }\n  }\n  return this\n}\nfunction needFinish(state) {\n  return (\n    state.ending &&\n    !state.destroyed &&\n    state.constructed &&\n    state.length === 0 &&\n    !state.errored &&\n    state.buffered.length === 0 &&\n    !state.finished &&\n    !state.writing &&\n    !state.errorEmitted &&\n    !state.closeEmitted\n  )\n}\nfunction callFinal(stream, state) {\n  let called = false\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    state.pendingcb--\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0)\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err)\n      }\n      errorOrDestroy(stream, err, state.sync)\n    } else if (needFinish(state)) {\n      state.prefinished = true\n      stream.emit('prefinish')\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++\n      process.nextTick(finish, stream, state)\n    }\n  }\n  state.sync = true\n  state.pendingcb++\n  try {\n    stream._final(onFinish)\n  } catch (err) {\n    onFinish(err)\n  }\n  state.sync = false\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true\n      callFinal(stream, state)\n    } else {\n      state.prefinished = true\n      stream.emit('prefinish')\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state)\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++\n        process.nextTick(\n          (stream, state) => {\n            if (needFinish(state)) {\n              finish(stream, state)\n            } else {\n              state.pendingcb--\n            }\n          },\n          stream,\n          state\n        )\n      } else if (needFinish(state)) {\n        state.pendingcb++\n        finish(stream, state)\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--\n  state.finished = true\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]()\n  }\n  stream.emit('finish')\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState\n    const autoDestroy =\n      !rState ||\n      (rState.autoDestroy &&\n        // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false))\n    if (autoDestroy) {\n      stream.destroy()\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.destroyed : false\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value\n      }\n    }\n  },\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val\n      }\n    }\n  },\n  writableFinished: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.finished : false\n    }\n  },\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.objectMode : false\n    }\n  },\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.getBuffer()\n    }\n  },\n  writableEnded: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.ending : false\n    }\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const wState = this._writableState\n      if (!wState) return false\n      return !wState.destroyed && !wState.ending && wState.needDrain\n    }\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.highWaterMark\n    }\n  },\n  writableCorked: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.corked : 0\n    }\n  },\n  writableLength: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.length\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._writableState ? this._writableState.errored : null\n    }\n  },\n  writableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      )\n    }\n  }\n})\nconst destroy = destroyImpl.destroy\nWritable.prototype.destroy = function (err, cb) {\n  const state = this._writableState\n\n  // Invoke pending callbacks.\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state)\n  }\n  destroy.call(this, err, cb)\n  return this\n}\nWritable.prototype._undestroy = destroyImpl.undestroy\nWritable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nWritable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nWritable.fromWeb = function (writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)\n}\nWritable.toWeb = function (streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvd3JpdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVU7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseUhBQXdCO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDN0MsZUFBZSxnSkFBMEI7QUFDekMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyxvSEFBVztBQUN2QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsc0lBQW9CO0FBQ3ZELFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxnSEFBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSw0SUFBa0M7QUFDdEMsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsbUJBQU8sQ0FBQyxrSEFBVTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQU8sQ0FBQyxrSEFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy93cml0YWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3Qge1xuICBBcnJheVByb3RvdHlwZVNsaWNlLFxuICBFcnJvcixcbiAgRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gIE9iamVjdERlZmluZVByb3BlcnRpZXMsXG4gIE9iamVjdFNldFByb3RvdHlwZU9mLFxuICBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZSxcbiAgU3ltYm9sLFxuICBTeW1ib2xIYXNJbnN0YW5jZVxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZVxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGVcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJy4vbGVnYWN5JykuU3RyZWFtXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IHsgYWRkQWJvcnRTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWRkLWFib3J0LXNpZ25hbCcpXG5jb25zdCB7IGdldEhpZ2hXYXRlck1hcmssIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrIH0gPSByZXF1aXJlKCcuL3N0YXRlJylcbmNvbnN0IHtcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gIEVSUl9TVFJFQU1fREVTVFJPWUVELFxuICBFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRUQsXG4gIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICBFUlJfVU5LTk9XTl9FTkNPRElOR1xufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmNvbnN0IHsgZXJyb3JPckRlc3Ryb3kgfSA9IGRlc3Ryb3lJbXBsXG5PYmplY3RTZXRQcm90b3R5cGVPZihXcml0YWJsZS5wcm90b3R5cGUsIFN0cmVhbS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihXcml0YWJsZSwgU3RyZWFtKVxuZnVuY3Rpb24gbm9wKCkge31cbmNvbnN0IGtPbkZpbmlzaGVkID0gU3ltYm9sKCdrT25GaW5pc2hlZCcpXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiByZXF1aXJlKCcuL2R1cGxleCcpXG5cbiAgLy8gT2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISEob3B0aW9ucyAmJiBvcHRpb25zLm9iamVjdE1vZGUpXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUpXG5cbiAgLy8gVGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRpb25zXG4gICAgPyBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleClcbiAgICA6IGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKGZhbHNlKVxuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWQuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZVxuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2VcbiAgLy8gQXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZVxuICAvLyBXaGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkLlxuICB0aGlzLmVuZGVkID0gZmFsc2VcbiAgLy8gV2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkLlxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2VcblxuICAvLyBIYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIC8vIFNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgY29uc3Qgbm9EZWNvZGUgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2UpXG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZVxuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcpIHx8ICd1dGY4J1xuXG4gIC8vIE5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMFxuXG4gIC8vIEEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlXG5cbiAgLy8gV2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbC5cbiAgdGhpcy5jb3JrZWQgPSAwXG5cbiAgLy8gQSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWVcblxuICAvLyBBIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZVxuXG4gIC8vIFRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuaywgY2IpLlxuICB0aGlzLm9ud3JpdGUgPSBvbndyaXRlLmJpbmQodW5kZWZpbmVkLCBzdHJlYW0pXG5cbiAgLy8gVGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikuXG4gIHRoaXMud3JpdGVjYiA9IG51bGxcblxuICAvLyBUaGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwXG5cbiAgLy8gU3RvcmFnZSBmb3IgZGF0YSBwYXNzZWQgdG8gdGhlIGFmdGVyV3JpdGUoKSBjYWxsYmFjayBpbiBjYXNlIG9mXG4gIC8vIHN5bmNocm9ub3VzIF93cml0ZSgpIGNvbXBsZXRpb24uXG4gIHRoaXMuYWZ0ZXJXcml0ZVRpY2tJbmZvID0gbnVsbFxuICByZXNldEJ1ZmZlcih0aGlzKVxuXG4gIC8vIE51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZC5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwXG5cbiAgLy8gU3RyZWFtIGlzIHN0aWxsIGJlaW5nIGNvbnN0cnVjdGVkIGFuZCBjYW5ub3QgYmVcbiAgLy8gZGVzdHJveWVkIHVudGlsIGNvbnN0cnVjdGlvbiBmaW5pc2hlZCBvciBmYWlsZWQuXG4gIC8vIEFzeW5jIGNvbnN0cnVjdGlvbiBpcyBvcHQgaW4sIHRoZXJlZm9yZSB3ZSBzdGFydCBhc1xuICAvLyBjb25zdHJ1Y3RlZC5cbiAgdGhpcy5jb25zdHJ1Y3RlZCA9IHRydWVcblxuICAvLyBFbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zLlxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2VcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2Fpbi5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZVxuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlXG5cbiAgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpLlxuICB0aGlzLmF1dG9EZXN0cm95ID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5hdXRvRGVzdHJveSAhPT0gZmFsc2VcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBlcnJvcmVkLiBXaGVuIHRydWUgYWxsIHdyaXRlKCkgY2FsbHNcbiAgLy8gc2hvdWxkIHJldHVybiBmYWxzZS4gVGhpcyBpcyBuZWVkZWQgc2luY2Ugd2hlbiBhdXRvRGVzdHJveVxuICAvLyBpcyBkaXNhYmxlZCB3ZSBuZWVkIGEgd2F5IHRvIHRlbGwgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBmYWlsZWQuXG4gIHRoaXMuZXJyb3JlZCA9IG51bGxcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBmaW5pc2hlZCBkZXN0cm95aW5nLlxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG5cbiAgLy8gVHJ1ZSBpZiBjbG9zZSBoYXMgYmVlbiBlbWl0dGVkIG9yIHdvdWxkIGhhdmUgYmVlbiBlbWl0dGVkXG4gIC8vIGRlcGVuZGluZyBvbiBlbWl0Q2xvc2UuXG4gIHRoaXMuY2xvc2VFbWl0dGVkID0gZmFsc2VcbiAgdGhpc1trT25GaW5pc2hlZF0gPSBbXVxufVxuZnVuY3Rpb24gcmVzZXRCdWZmZXIoc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyZWQgPSBbXVxuICBzdGF0ZS5idWZmZXJlZEluZGV4ID0gMFxuICBzdGF0ZS5hbGxCdWZmZXJzID0gdHJ1ZVxuICBzdGF0ZS5hbGxOb29wID0gdHJ1ZVxufVxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICByZXR1cm4gQXJyYXlQcm90b3R5cGVTbGljZSh0aGlzLmJ1ZmZlcmVkLCB0aGlzLmJ1ZmZlcmVkSW5kZXgpXG59XG5PYmplY3REZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcmVkUmVxdWVzdENvdW50Jywge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJlZC5sZW5ndGggLSB0aGlzLmJ1ZmZlcmVkSW5kZXhcbiAgfVxufSlcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjUuXG4gIGNvbnN0IGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcbiAgaWYgKCFpc0R1cGxleCAmJiAhRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZShXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucylcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXZcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnN0cnVjdCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fY29uc3RydWN0ID0gb3B0aW9ucy5jb25zdHJ1Y3RcbiAgICBpZiAob3B0aW9ucy5zaWduYWwpIGFkZEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCB0aGlzKVxuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGRlc3Ryb3lJbXBsLmNvbnN0cnVjdCh0aGlzLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSlcbiAgICB9XG4gICAgZmluaXNoTWF5YmUodGhpcywgc3RhdGUpXG4gIH0pXG59XG5PYmplY3REZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sSGFzSW5zdGFuY2UsIHtcbiAgX19wcm90b19fOiBudWxsLFxuICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmIChGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGVcbiAgfVxufSlcblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpXG59XG5mdW5jdGlvbiBfd3JpdGUoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZ1xuICAgIGVsc2UgaWYgKGVuY29kaW5nICE9PSAnYnVmZmVyJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3BcbiAgfVxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpXG4gIH0gZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICdidWZmZXInXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJ1xuICAgIH0gZWxzZSBpZiAoU3RyZWFtLl9pc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IFN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyKGNodW5rKVxuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspXG4gICAgfVxuICB9XG4gIGxldCBlcnJcbiAgaWYgKHN0YXRlLmVuZGluZykge1xuICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpXG4gIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpXG4gIH1cbiAgaWYgKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycilcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciwgdHJ1ZSlcbiAgICByZXR1cm4gZXJyXG4gIH1cbiAgc3RhdGUucGVuZGluZ2NiKytcbiAgcmV0dXJuIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYilcbn1cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHJldHVybiBfd3JpdGUodGhpcywgY2h1bmssIGVuY29kaW5nLCBjYikgPT09IHRydWVcbn1cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrXG59XG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nKSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSlcbiAgfVxufVxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2UoZW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2RpbmdcbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjb25zdCBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aFxuICBzdGF0ZS5sZW5ndGggKz0gbGVuXG5cbiAgLy8gc3RyZWFtLl93cml0ZSByZXNldHMgc3RhdGUubGVuZ3RoXG4gIGNvbnN0IHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgLy8gV2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCB8fCBzdGF0ZS5lcnJvcmVkIHx8ICFzdGF0ZS5jb25zdHJ1Y3RlZCkge1xuICAgIHN0YXRlLmJ1ZmZlcmVkLnB1c2goe1xuICAgICAgY2h1bmssXG4gICAgICBlbmNvZGluZyxcbiAgICAgIGNhbGxiYWNrXG4gICAgfSlcbiAgICBpZiAoc3RhdGUuYWxsQnVmZmVycyAmJiBlbmNvZGluZyAhPT0gJ2J1ZmZlcicpIHtcbiAgICAgIHN0YXRlLmFsbEJ1ZmZlcnMgPSBmYWxzZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuYWxsTm9vcCAmJiBjYWxsYmFjayAhPT0gbm9wKSB7XG4gICAgICBzdGF0ZS5hbGxOb29wID0gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUud3JpdGVsZW4gPSBsZW5cbiAgICBzdGF0ZS53cml0ZWNiID0gY2FsbGJhY2tcbiAgICBzdGF0ZS53cml0aW5nID0gdHJ1ZVxuICAgIHN0YXRlLnN5bmMgPSB0cnVlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlXG4gIH1cblxuICAvLyBSZXR1cm4gZmFsc2UgaWYgZXJyb3JlZCBvciBkZXN0cm95ZWQgaW4gb3JkZXIgdG8gYnJlYWtcbiAgLy8gYW55IHN5bmNocm9ub3VzIHdoaWxlKHN0cmVhbS53cml0ZShkYXRhKSkgbG9vcHMuXG4gIHJldHVybiByZXQgJiYgIXN0YXRlLmVycm9yZWQgJiYgIXN0YXRlLmRlc3Ryb3llZFxufVxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlblxuICBzdGF0ZS53cml0ZWNiID0gY2JcbiAgc3RhdGUud3JpdGluZyA9IHRydWVcbiAgc3RhdGUuc3luYyA9IHRydWVcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpXG4gIGVsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpXG4gIGVsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpXG4gIHN0YXRlLnN5bmMgPSBmYWxzZVxufVxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYlxuICBjYihlcilcbiAgLy8gRW5zdXJlIGNhbGxiYWNrcyBhcmUgaW52b2tlZCBldmVuIHdoZW4gYXV0b0Rlc3Ryb3kgaXNcbiAgLy8gbm90IGVuYWJsZWQuIFBhc3NpbmcgYGVyYCBoZXJlIGRvZXNuJ3QgbWFrZSBzZW5zZSBzaW5jZVxuICAvLyBpdCdzIHJlbGF0ZWQgdG8gb25lIHNwZWNpZmljIHdyaXRlLCBub3QgdG8gdGhlIGJ1ZmZlcmVkXG4gIC8vIHdyaXRlcy5cbiAgZXJyb3JCdWZmZXIoc3RhdGUpXG4gIC8vIFRoaXMgY2FuIGVtaXQgZXJyb3IsIGJ1dCBlcnJvciBtdXN0IGFsd2F5cyBmb2xsb3cgY2IuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpXG59XG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3Qgc3luYyA9IHN0YXRlLnN5bmNcbiAgY29uc3QgY2IgPSBzdGF0ZS53cml0ZWNiXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSlcbiAgICByZXR1cm5cbiAgfVxuICBzdGF0ZS53cml0aW5nID0gZmFsc2VcbiAgc3RhdGUud3JpdGVjYiA9IG51bGxcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuXG4gIHN0YXRlLndyaXRlbGVuID0gMFxuICBpZiAoZXIpIHtcbiAgICAvLyBBdm9pZCBWOCBsZWFrLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDEwMyNpc3N1ZWNvbW1lbnQtNjUyMDAyMzY0XG4gICAgZXIuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIGlmICghc3RhdGUuZXJyb3JlZCkge1xuICAgICAgc3RhdGUuZXJyb3JlZCA9IGVyXG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIHRvIG5vdGlmeSB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGVcbiAgICAvLyBlcnJvci5cbiAgICBpZiAoc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCkge1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVycm9yZWQgPSBlclxuICAgIH1cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbndyaXRlRXJyb3IsIHN0cmVhbSwgc3RhdGUsIGVyLCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIGVyLCBjYilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlLmJ1ZmZlcmVkLmxlbmd0aCA+IHN0YXRlLmJ1ZmZlcmVkSW5kZXgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdCBpcyBhIGNvbW1vbiBjYXNlIHRoYXQgdGhlIGNhbGxiYWNrIHBhc3NlZCB0byAud3JpdGUoKSBpcyBhbHdheXNcbiAgICAgIC8vIHRoZSBzYW1lLiBJbiB0aGF0IGNhc2UsIHdlIGRvIG5vdCBzY2hlZHVsZSBhIG5ldyBuZXh0VGljaygpLCBidXRcbiAgICAgIC8vIHJhdGhlciBqdXN0IGluY3JlYXNlIGEgY291bnRlciwgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBhbmQgYXZvaWRcbiAgICAgIC8vIG1lbW9yeSBhbGxvY2F0aW9ucy5cbiAgICAgIGlmIChzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8gIT09IG51bGwgJiYgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvLmNiID09PSBjYikge1xuICAgICAgICBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8uY291bnQrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvID0ge1xuICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgIGNiLFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZVRpY2ssIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mbylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCAxLCBjYilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFmdGVyV3JpdGVUaWNrKHsgc3RyZWFtLCBzdGF0ZSwgY291bnQsIGNiIH0pIHtcbiAgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvID0gbnVsbFxuICByZXR1cm4gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBjb3VudCwgY2IpXG59XG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGNvdW50LCBjYikge1xuICBjb25zdCBuZWVkRHJhaW4gPSAhc3RhdGUuZW5kaW5nICYmICFzdHJlYW0uZGVzdHJveWVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW5cbiAgaWYgKG5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJylcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLVxuICAgIGNiKClcbiAgfVxuICBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgZXJyb3JCdWZmZXIoc3RhdGUpXG4gIH1cbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSlcbn1cblxuLy8gSWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIGludm9rZSBjYWxsYmFja3MuXG5mdW5jdGlvbiBlcnJvckJ1ZmZlcihzdGF0ZSkge1xuICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgIHJldHVyblxuICB9XG4gIGZvciAobGV0IG4gPSBzdGF0ZS5idWZmZXJlZEluZGV4OyBuIDwgc3RhdGUuYnVmZmVyZWQubGVuZ3RoOyArK24pIHtcbiAgICB2YXIgX3N0YXRlJGVycm9yZWRcbiAgICBjb25zdCB7IGNodW5rLCBjYWxsYmFjayB9ID0gc3RhdGUuYnVmZmVyZWRbbl1cbiAgICBjb25zdCBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aFxuICAgIHN0YXRlLmxlbmd0aCAtPSBsZW5cbiAgICBjYWxsYmFjayhcbiAgICAgIChfc3RhdGUkZXJyb3JlZCA9IHN0YXRlLmVycm9yZWQpICE9PSBudWxsICYmIF9zdGF0ZSRlcnJvcmVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfc3RhdGUkZXJyb3JlZFxuICAgICAgICA6IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKVxuICAgIClcbiAgfVxuICBjb25zdCBvbmZpbmlzaENhbGxiYWNrcyA9IHN0YXRlW2tPbkZpbmlzaGVkXS5zcGxpY2UoMClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmZpbmlzaENhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfc3RhdGUkZXJyb3JlZDJcbiAgICBvbmZpbmlzaENhbGxiYWNrc1tpXShcbiAgICAgIChfc3RhdGUkZXJyb3JlZDIgPSBzdGF0ZS5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RhdGUkZXJyb3JlZDIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9zdGF0ZSRlcnJvcmVkMlxuICAgICAgICA6IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnZW5kJylcbiAgICApXG4gIH1cbiAgcmVzZXRCdWZmZXIoc3RhdGUpXG59XG5cbi8vIElmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0LlxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuY29ya2VkIHx8IHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgfHwgc3RhdGUuZGVzdHJveWVkIHx8ICFzdGF0ZS5jb25zdHJ1Y3RlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHsgYnVmZmVyZWQsIGJ1ZmZlcmVkSW5kZXgsIG9iamVjdE1vZGUgfSA9IHN0YXRlXG4gIGNvbnN0IGJ1ZmZlcmVkTGVuZ3RoID0gYnVmZmVyZWQubGVuZ3RoIC0gYnVmZmVyZWRJbmRleFxuICBpZiAoIWJ1ZmZlcmVkTGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IGkgPSBidWZmZXJlZEluZGV4XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlXG4gIGlmIChidWZmZXJlZExlbmd0aCA+IDEgJiYgc3RyZWFtLl93cml0ZXYpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IgLT0gYnVmZmVyZWRMZW5ndGggLSAxXG4gICAgY29uc3QgY2FsbGJhY2sgPSBzdGF0ZS5hbGxOb29wXG4gICAgICA/IG5vcFxuICAgICAgOiAoZXJyKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgbiA9IGk7IG4gPCBidWZmZXJlZC5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgYnVmZmVyZWRbbl0uY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIE1ha2UgYSBjb3B5IG9mIGBidWZmZXJlZGAgaWYgaXQncyBnb2luZyB0byBiZSB1c2VkIGJ5IGBjYWxsYmFja2AgYWJvdmUsXG4gICAgLy8gc2luY2UgYGRvV3JpdGVgIHdpbGwgbXV0YXRlIHRoZSBhcnJheS5cbiAgICBjb25zdCBjaHVua3MgPSBzdGF0ZS5hbGxOb29wICYmIGkgPT09IDAgPyBidWZmZXJlZCA6IEFycmF5UHJvdG90eXBlU2xpY2UoYnVmZmVyZWQsIGkpXG4gICAgY2h1bmtzLmFsbEJ1ZmZlcnMgPSBzdGF0ZS5hbGxCdWZmZXJzXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGNodW5rcywgJycsIGNhbGxiYWNrKVxuICAgIHJlc2V0QnVmZmVyKHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHsgY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayB9ID0gYnVmZmVyZWRbaV1cbiAgICAgIGJ1ZmZlcmVkW2krK10gPSBudWxsXG4gICAgICBjb25zdCBsZW4gPSBvYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aFxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICAgIH0gd2hpbGUgKGkgPCBidWZmZXJlZC5sZW5ndGggJiYgIXN0YXRlLndyaXRpbmcpXG4gICAgaWYgKGkgPT09IGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgcmVzZXRCdWZmZXIoc3RhdGUpXG4gICAgfSBlbHNlIGlmIChpID4gMjU2KSB7XG4gICAgICBidWZmZXJlZC5zcGxpY2UoMCwgaSlcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkSW5kZXggPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkSW5kZXggPSBpXG4gICAgfVxuICB9XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZVxufVxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICh0aGlzLl93cml0ZXYpIHtcbiAgICB0aGlzLl93cml0ZXYoXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICBjaHVuayxcbiAgICAgICAgICBlbmNvZGluZ1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgY2JcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpXG4gIH1cbn1cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbFxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVua1xuICAgIGNodW5rID0gbnVsbFxuICAgIGVuY29kaW5nID0gbnVsbFxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG51bGxcbiAgfVxuICBsZXQgZXJyXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcmV0ID0gX3dyaXRlKHRoaXMsIGNodW5rLCBlbmNvZGluZylcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVyciA9IHJldFxuICAgIH1cbiAgfVxuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzLlxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMVxuICAgIHRoaXMudW5jb3JrKClcbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy4uLlxuICB9IGVsc2UgaWYgKCFzdGF0ZS5lcnJvcmVkICYmICFzdGF0ZS5lbmRpbmcpIHtcbiAgICAvLyBUaGlzIGlzIGZvcmdpdmluZyBpbiB0ZXJtcyBvZiB1bm5lY2Vzc2FyeSBjYWxscyB0byBlbmQoKSBhbmQgY2FuIGhpZGVcbiAgICAvLyBsb2dpYyBlcnJvcnMuIEhvd2V2ZXIsIHVzdWFsbHkgc3VjaCBlcnJvcnMgYXJlIGhhcm1sZXNzIGFuZCBjYXVzaW5nIGFcbiAgICAvLyBoYXJkIGVycm9yIGNhbiBiZSBkaXNwcm9wb3J0aW9uYXRlbHkgZGVzdHJ1Y3RpdmUuIEl0IGlzIG5vdCBhbHdheXNcbiAgICAvLyB0cml2aWFsIGZvciB0aGUgdXNlciB0byBkZXRlcm1pbmUgd2hldGhlciBlbmQoKSBuZWVkcyB0byBiZSBjYWxsZWRcbiAgICAvLyBvciBub3QuXG5cbiAgICBzdGF0ZS5lbmRpbmcgPSB0cnVlXG4gICAgZmluaXNoTWF5YmUodGhpcywgc3RhdGUsIHRydWUpXG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlXG4gIH0gZWxzZSBpZiAoc3RhdGUuZmluaXNoZWQpIHtcbiAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9BTFJFQURZX0ZJTklTSEVEKCdlbmQnKVxuICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnZW5kJylcbiAgfVxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVyciB8fCBzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZVtrT25GaW5pc2hlZF0ucHVzaChjYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lbmRpbmcgJiZcbiAgICAhc3RhdGUuZGVzdHJveWVkICYmXG4gICAgc3RhdGUuY29uc3RydWN0ZWQgJiZcbiAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAhc3RhdGUuZXJyb3JlZCAmJlxuICAgIHN0YXRlLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCAmJlxuICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICFzdGF0ZS53cml0aW5nICYmXG4gICAgIXN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgICFzdGF0ZS5jbG9zZUVtaXR0ZWRcbiAgKVxufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gIGZ1bmN0aW9uIG9uRmluaXNoKGVycikge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkID8gZXJyIDogRVJSX01VTFRJUExFX0NBTExCQUNLKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHN0YXRlLnBlbmRpbmdjYi0tXG4gICAgaWYgKGVycikge1xuICAgICAgY29uc3Qgb25maW5pc2hDYWxsYmFja3MgPSBzdGF0ZVtrT25GaW5pc2hlZF0uc3BsaWNlKDApXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZmluaXNoQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9uZmluaXNoQ2FsbGJhY2tzW2ldKGVycilcbiAgICAgIH1cbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCBzdGF0ZS5zeW5jKVxuICAgIH0gZWxzZSBpZiAobmVlZEZpbmlzaChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZVxuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LiBEb24ndCBjaGVjayBzdGF0ZS5zeW5jIGhlcmUuXG4gICAgICAvLyBTb21lIHN0cmVhbXMgYXNzdW1lICdmaW5pc2gnIHdpbGwgYmUgZW1pdHRlZFxuICAgICAgLy8gYXN5bmNocm9ub3VzbHkgcmVsYXRpdmUgdG8gX2ZpbmFsIGNhbGxiYWNrLlxuICAgICAgc3RhdGUucGVuZGluZ2NiKytcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoLCBzdHJlYW0sIHN0YXRlKVxuICAgIH1cbiAgfVxuICBzdGF0ZS5zeW5jID0gdHJ1ZVxuICBzdGF0ZS5wZW5kaW5nY2IrK1xuICB0cnkge1xuICAgIHN0cmVhbS5fZmluYWwob25GaW5pc2gpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG9uRmluaXNoKGVycilcbiAgfVxuICBzdGF0ZS5zeW5jID0gZmFsc2Vcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZVxuICAgICAgY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZVxuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlLCBzeW5jKSB7XG4gIGlmIChuZWVkRmluaXNoKHN0YXRlKSkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKVxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYisrXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soXG4gICAgICAgICAgKHN0cmVhbSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChuZWVkRmluaXNoKHN0YXRlKSkge1xuICAgICAgICAgICAgICBmaW5pc2goc3RyZWFtLCBzdGF0ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChuZWVkRmluaXNoKHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrK1xuICAgICAgICBmaW5pc2goc3RyZWFtLCBzdGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnBlbmRpbmdjYi0tXG4gIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZVxuICBjb25zdCBvbmZpbmlzaENhbGxiYWNrcyA9IHN0YXRlW2tPbkZpbmlzaGVkXS5zcGxpY2UoMClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmZpbmlzaENhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIG9uZmluaXNoQ2FsbGJhY2tzW2ldKClcbiAgfVxuICBzdHJlYW0uZW1pdCgnZmluaXNoJylcbiAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsLlxuICAgIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICAgIGNvbnN0IGF1dG9EZXN0cm95ID1cbiAgICAgICFyU3RhdGUgfHxcbiAgICAgIChyU3RhdGUuYXV0b0Rlc3Ryb3kgJiZcbiAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IHRoZSByZWFkYWJsZSB0byBldmVyICdlbmQnXG4gICAgICAgIC8vIGlmIHJlYWRhYmxlIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLlxuICAgICAgICAoclN0YXRlLmVuZEVtaXR0ZWQgfHwgclN0YXRlLnJlYWRhYmxlID09PSBmYWxzZSkpXG4gICAgaWYgKGF1dG9EZXN0cm95KSB7XG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgfVxuICB9XG59XG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlLnByb3RvdHlwZSwge1xuICBjbG9zZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmNsb3NlZCA6IGZhbHNlXG4gICAgfVxuICB9LFxuICBkZXN0cm95ZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA6IGZhbHNlXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkgbWFuYWdpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgdyA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgICAgIC8vIHcud3JpdGFibGUgPT09IGZhbHNlIG1lYW5zIHRoYXQgdGhpcyBpcyBwYXJ0IG9mIGEgRHVwbGV4IHN0cmVhbVxuICAgICAgLy8gd2hlcmUgdGhlIHdyaXRhYmxlIHNpZGUgd2FzIGRpc2FibGVkIHVwb24gY29uc3RydWN0aW9uLlxuICAgICAgLy8gQ29tcGF0LiBUaGUgdXNlciBtaWdodCBtYW51YWxseSBkaXNhYmxlIHdyaXRhYmxlIHNpZGUgdGhyb3VnaFxuICAgICAgLy8gZGVwcmVjYXRlZCBzZXR0ZXIuXG4gICAgICByZXR1cm4gISF3ICYmIHcud3JpdGFibGUgIT09IGZhbHNlICYmICF3LmRlc3Ryb3llZCAmJiAhdy5lcnJvcmVkICYmICF3LmVuZGluZyAmJiAhdy5lbmRlZFxuICAgIH0sXG4gICAgc2V0KHZhbCkge1xuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGlibGUuXG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlID0gISF2YWxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlRmluaXNoZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlT2JqZWN0TW9kZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZSA6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUJ1ZmZlcjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVOZWVkRHJhaW46IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgd1N0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICAgICAgaWYgKCF3U3RhdGUpIHJldHVybiBmYWxzZVxuICAgICAgcmV0dXJuICF3U3RhdGUuZGVzdHJveWVkICYmICF3U3RhdGUuZW5kaW5nICYmIHdTdGF0ZS5uZWVkRHJhaW5cbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlSGlnaFdhdGVyTWFyazoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlQ29ya2VkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQgOiAwXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUxlbmd0aDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aFxuICAgIH1cbiAgfSxcbiAgZXJyb3JlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JlZCA6IG51bGxcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlQWJvcnRlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIShcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JlZCkgJiZcbiAgICAgICAgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWRcbiAgICAgIClcbiAgICB9XG4gIH1cbn0pXG5jb25zdCBkZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveVxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcblxuICAvLyBJbnZva2UgcGVuZGluZyBjYWxsYmFja3MuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5idWZmZXJlZEluZGV4IDwgc3RhdGUuYnVmZmVyZWQubGVuZ3RoIHx8IHN0YXRlW2tPbkZpbmlzaGVkXS5sZW5ndGgpKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlcnJvckJ1ZmZlciwgc3RhdGUpXG4gIH1cbiAgZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgY2IpXG4gIHJldHVybiB0aGlzXG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveVxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKVxufVxuV3JpdGFibGUucHJvdG90eXBlW0VFLmNhcHR1cmVSZWplY3Rpb25TeW1ib2xdID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmRlc3Ryb3koZXJyKVxufVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cbldyaXRhYmxlLmZyb21XZWIgPSBmdW5jdGlvbiAod3JpdGFibGVTdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtV3JpdGFibGVGcm9tV3JpdGFibGVTdHJlYW0od3JpdGFibGVTdHJlYW0sIG9wdGlvbnMpXG59XG5Xcml0YWJsZS50b1dlYiA9IGZ1bmN0aW9uIChzdHJlYW1Xcml0YWJsZSkge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdXcml0YWJsZVN0cmVhbUZyb21TdHJlYW1Xcml0YWJsZShzdHJlYW1Xcml0YWJsZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint jsdoc/require-jsdoc: \"error\" */\n\n\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = __webpack_require__(/*! ../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = __webpack_require__(/*! ../ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst { normalizeEncoding } = __webpack_require__(/*! ../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst { isAsyncFunction, isArrayBufferView } = (__webpack_require__(/*! ../ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\").types)\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i]\n    const indexedName = `${name}[${i}]`\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)\n    }\n    validateAbortSignal(signal, indexedName)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3ZhbGlkYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0hBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEdBQWdCO0FBQzVCLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyx3R0FBYztBQUNwRCxRQUFRLHFDQUFxQyxFQUFFLHFJQUE2QjtBQUM1RTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxLQUFLLFFBQVEsSUFBSTtBQUMxRixDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLLFFBQVEsSUFBSTtBQUM1RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLLFFBQVEsSUFBSTtBQUM1RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQkFBb0IsSUFBSSxPQUFPLEVBQUUseUNBQXlDLEVBQUUsb0JBQW9CLElBQUksT0FBTztBQUNwSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCOztBQUVBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsZ0NBQWdDLEtBQUssR0FBRyxFQUFFO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsaUNBQWlDLEtBQUssR0FBRyxFQUFFO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUEsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSwyQkFBMkIsS0FBSyxHQUFHLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsT0FBTztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkI7O0FBRUEsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxnQkFBZ0I7O0FBRWxFO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3ZhbGlkYXRvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IGpzZG9jL3JlcXVpcmUtanNkb2M6IFwiZXJyb3JcIiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBBcnJheUlzQXJyYXksXG4gIEFycmF5UHJvdG90eXBlSW5jbHVkZXMsXG4gIEFycmF5UHJvdG90eXBlSm9pbixcbiAgQXJyYXlQcm90b3R5cGVNYXAsXG4gIE51bWJlcklzSW50ZWdlcixcbiAgTnVtYmVySXNOYU4sXG4gIE51bWJlck1BWF9TQUZFX0lOVEVHRVIsXG4gIE51bWJlck1JTl9TQUZFX0lOVEVHRVIsXG4gIE51bWJlclBhcnNlSW50LFxuICBPYmplY3RQcm90b3R5cGVIYXNPd25Qcm9wZXJ0eSxcbiAgUmVnRXhwUHJvdG90eXBlRXhlYyxcbiAgU3RyaW5nLFxuICBTdHJpbmdQcm90b3R5cGVUb1VwcGVyQ2FzZSxcbiAgU3RyaW5nUHJvdG90eXBlVHJpbVxufSA9IHJlcXVpcmUoJy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qge1xuICBoaWRlU3RhY2tGcmFtZXMsXG4gIGNvZGVzOiB7IEVSUl9TT0NLRVRfQkFEX1BPUlQsIEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIEVSUl9PVVRfT0ZfUkFOR0UsIEVSUl9VTktOT1dOX1NJR05BTCB9XG59ID0gcmVxdWlyZSgnLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyBub3JtYWxpemVFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi4vb3Vycy91dGlsJylcbmNvbnN0IHsgaXNBc3luY0Z1bmN0aW9uLCBpc0FycmF5QnVmZmVyVmlldyB9ID0gcmVxdWlyZSgnLi4vb3Vycy91dGlsJykudHlwZXNcbmNvbnN0IHNpZ25hbHMgPSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ludDMyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gKHZhbHVlIHwgMClcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNVaW50MzIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA+Pj4gMFxufVxuY29uc3Qgb2N0YWxSZWcgPSAvXlswLTddKyQvXG5jb25zdCBtb2RlRGVzYyA9ICdtdXN0IGJlIGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgb3IgYW4gb2N0YWwgc3RyaW5nJ1xuXG4vKipcbiAqIFBhcnNlIGFuZCB2YWxpZGF0ZSB2YWx1ZXMgdGhhdCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIG1vZGVfdCAodGhlIFNfKlxuICogY29uc3RhbnRzKS4gT25seSB2YWxpZCBudW1iZXJzIGFuZCBvY3RhbCBzdHJpbmdzIGFyZSBhbGxvd2VkLiBUaGV5IGNvdWxkIGJlXG4gKiBjb252ZXJ0ZWQgdG8gMzItYml0IHVuc2lnbmVkIGludGVnZXJzIG9yIG5vbi1uZWdhdGl2ZSBzaWduZWQgaW50ZWdlcnMgaW4gdGhlXG4gKiBDKysgbGFuZCwgYnV0IGFueSB2YWx1ZSBoaWdoZXIgdGhhbiAwbzc3NyB3aWxsIHJlc3VsdCBpbiBwbGF0Zm9ybS1zcGVjaWZpY1xuICogYmVoYXZpb3JzLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZXMgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWZdIElmIHNwZWNpZmllZCwgd2lsbCBiZSByZXR1cm5lZCBmb3IgaW52YWxpZCB2YWx1ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsZU1vZGUodmFsdWUsIG5hbWUsIGRlZikge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhbHVlID0gZGVmXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoUmVnRXhwUHJvdG90eXBlRXhlYyhvY3RhbFJlZywgdmFsdWUpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKG5hbWUsIHZhbHVlLCBtb2RlRGVzYylcbiAgICB9XG4gICAgdmFsdWUgPSBOdW1iZXJQYXJzZUludCh2YWx1ZSwgOClcbiAgfVxuICB2YWxpZGF0ZVVpbnQzMih2YWx1ZSwgbmFtZSlcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlSW50ZWdlclxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBudW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUludGVnZXJ9ICovXG5jb25zdCB2YWxpZGF0ZUludGVnZXIgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBtaW4gPSBOdW1iZXJNSU5fU0FGRV9JTlRFR0VSLCBtYXggPSBOdW1iZXJNQVhfU0FGRV9JTlRFR0VSKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICBpZiAoIU51bWJlcklzSW50ZWdlcih2YWx1ZSkpIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgYD49ICR7bWlufSAmJiA8PSAke21heH1gLCB2YWx1ZSlcbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlSW50MzJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVJbnQzMn0gKi9cbmNvbnN0IHZhbGlkYXRlSW50MzIgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBtaW4gPSAtMjE0NzQ4MzY0OCwgbWF4ID0gMjE0NzQ4MzY0NykgPT4ge1xuICAvLyBUaGUgZGVmYXVsdHMgZm9yIG1pbiBhbmQgbWF4IGNvcnJlc3BvbmQgdG8gdGhlIGxpbWl0cyBvZiAzMi1iaXQgaW50ZWdlcnMuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxuICBpZiAoIU51bWJlcklzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsIGA+PSAke21pbn0gJiYgPD0gJHttYXh9YCwgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlVWludDMyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gW3Bvc2l0aXZlPWZhbHNlXVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVVaW50MzJ9ICovXG5jb25zdCB2YWxpZGF0ZVVpbnQzMiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIHBvc2l0aXZlID0gZmFsc2UpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG4gIGlmICghTnVtYmVySXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cbiAgY29uc3QgbWluID0gcG9zaXRpdmUgPyAxIDogMFxuICAvLyAyICoqIDMyID09PSA0Mjk0OTY3Mjk2XG4gIGNvbnN0IG1heCA9IDQyOTQ5NjcyOTVcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgYD49ICR7bWlufSAmJiA8PSAke21heH1gLCB2YWx1ZSlcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBzdHJpbmd9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZVN0cmluZ30gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ3N0cmluZycsIHZhbHVlKVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZU51bWJlclxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBudW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZU51bWJlcn0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lLCBtaW4gPSB1bmRlZmluZWQsIG1heCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgaWYgKFxuICAgIChtaW4gIT0gbnVsbCAmJiB2YWx1ZSA8IG1pbikgfHxcbiAgICAobWF4ICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHx8XG4gICAgKChtaW4gIT0gbnVsbCB8fCBtYXggIT0gbnVsbCkgJiYgTnVtYmVySXNOYU4odmFsdWUpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShcbiAgICAgIG5hbWUsXG4gICAgICBgJHttaW4gIT0gbnVsbCA/IGA+PSAke21pbn1gIDogJyd9JHttaW4gIT0gbnVsbCAmJiBtYXggIT0gbnVsbCA/ICcgJiYgJyA6ICcnfSR7bWF4ICE9IG51bGwgPyBgPD0gJHttYXh9YCA6ICcnfWAsXG4gICAgICB2YWx1ZVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZU9uZU9mXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7VFtdfSBvbmVPZlxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVPbmVPZn0gKi9cbmNvbnN0IHZhbGlkYXRlT25lT2YgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBvbmVPZikgPT4ge1xuICBpZiAoIUFycmF5UHJvdG90eXBlSW5jbHVkZXMob25lT2YsIHZhbHVlKSkge1xuICAgIGNvbnN0IGFsbG93ZWQgPSBBcnJheVByb3RvdHlwZUpvaW4oXG4gICAgICBBcnJheVByb3RvdHlwZU1hcChvbmVPZiwgKHYpID0+ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7dn0nYCA6IFN0cmluZyh2KSkpLFxuICAgICAgJywgJ1xuICAgIClcbiAgICBjb25zdCByZWFzb24gPSAnbXVzdCBiZSBvbmUgb2Y6ICcgKyBhbGxvd2VkXG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShuYW1lLCB2YWx1ZSwgcmVhc29uKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBib29sZWFufVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVCb29sZWFufSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdib29sZWFuJywgdmFsdWUpXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlWYWx1ZU9yRGVmYXVsdChvcHRpb25zLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gb3B0aW9ucyA9PSBudWxsIHx8ICFPYmplY3RQcm90b3R5cGVIYXNPd25Qcm9wZXJ0eShvcHRpb25zLCBrZXkpID8gZGVmYXVsdFZhbHVlIDogb3B0aW9uc1trZXldXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlT2JqZWN0XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7XG4gKiAgIGFsbG93QXJyYXk/OiBib29sZWFuLFxuICogICBhbGxvd0Z1bmN0aW9uPzogYm9vbGVhbixcbiAqICAgbnVsbGFibGU/OiBib29sZWFuXG4gKiB9fSBbb3B0aW9uc11cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlT2JqZWN0fSAqL1xuY29uc3QgdmFsaWRhdGVPYmplY3QgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBvcHRpb25zID0gbnVsbCkgPT4ge1xuICBjb25zdCBhbGxvd0FycmF5ID0gZ2V0T3duUHJvcGVydHlWYWx1ZU9yRGVmYXVsdChvcHRpb25zLCAnYWxsb3dBcnJheScsIGZhbHNlKVxuICBjb25zdCBhbGxvd0Z1bmN0aW9uID0gZ2V0T3duUHJvcGVydHlWYWx1ZU9yRGVmYXVsdChvcHRpb25zLCAnYWxsb3dGdW5jdGlvbicsIGZhbHNlKVxuICBjb25zdCBudWxsYWJsZSA9IGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywgJ251bGxhYmxlJywgZmFsc2UpXG4gIGlmIChcbiAgICAoIW51bGxhYmxlICYmIHZhbHVlID09PSBudWxsKSB8fFxuICAgICghYWxsb3dBcnJheSAmJiBBcnJheUlzQXJyYXkodmFsdWUpKSB8fFxuICAgICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmICghYWxsb3dGdW5jdGlvbiB8fCB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ09iamVjdCcsIHZhbHVlKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZURpY3Rpb25hcnkgLSBXZSBhcmUgdXNpbmcgdGhlIFdlYiBJREwgU3RhbmRhcmQgZGVmaW5pdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIFwiZGljdGlvbmFyeVwiIGhlcmUsIHdoaWNoIG1lYW5zIGFueSB2YWx1ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdob3NlIFR5cGUgaXMgZWl0aGVyIFVuZGVmaW5lZCwgTnVsbCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgKHdoaWNoIGluY2x1ZGVzIGZ1bmN0aW9ucykuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWRpY3Rpb25hcnlcbiAqIEBzZWUgaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3RhYmxlLXR5cGVvZi1vcGVyYXRvci1yZXN1bHRzXG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZURpY3Rpb25hcnl9ICovXG5jb25zdCB2YWxpZGF0ZURpY3Rpb25hcnkgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdhIGRpY3Rpb25hcnknLCB2YWx1ZSlcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVBcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluTGVuZ3RoXVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgYW55W119XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUFycmF5fSAqL1xuY29uc3QgdmFsaWRhdGVBcnJheSA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUsIG1pbkxlbmd0aCA9IDApID0+IHtcbiAgaWYgKCFBcnJheUlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdBcnJheScsIHZhbHVlKVxuICB9XG4gIGlmICh2YWx1ZS5sZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICBjb25zdCByZWFzb24gPSBgbXVzdCBiZSBsb25nZXIgdGhhbiAke21pbkxlbmd0aH1gXG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShuYW1lLCB2YWx1ZSwgcmVhc29uKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVN0cmluZ0FycmF5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgc3RyaW5nW119XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZVN0cmluZ0FycmF5fSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmdBcnJheSh2YWx1ZSwgbmFtZSkge1xuICB2YWxpZGF0ZUFycmF5KHZhbHVlLCBuYW1lKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVTdHJpbmcodmFsdWVbaV0sIGAke25hbWV9WyR7aX1dYClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUJvb2xlYW5BcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIGJvb2xlYW5bXX1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQm9vbGVhbkFycmF5fSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuQXJyYXkodmFsdWUsIG5hbWUpIHtcbiAgdmFsaWRhdGVBcnJheSh2YWx1ZSwgbmFtZSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQm9vbGVhbih2YWx1ZVtpXSwgYCR7bmFtZX1bJHtpfV1gKVxuICB9XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQWJvcnRTaWduYWxBcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIEFib3J0U2lnbmFsW119XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXl9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXkodmFsdWUsIG5hbWUpIHtcbiAgdmFsaWRhdGVBcnJheSh2YWx1ZSwgbmFtZSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpZ25hbCA9IHZhbHVlW2ldXG4gICAgY29uc3QgaW5kZXhlZE5hbWUgPSBgJHtuYW1lfVske2l9XWBcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShpbmRleGVkTmFtZSwgJ0Fib3J0U2lnbmFsJywgc2lnbmFsKVxuICAgIH1cbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCwgaW5kZXhlZE5hbWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IHNpZ25hbFxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPSdzaWduYWwnXVxuICogQHJldHVybnMge2Fzc2VydHMgc2lnbmFsIGlzIGtleW9mIHNpZ25hbHN9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbmFsTmFtZShzaWduYWwsIG5hbWUgPSAnc2lnbmFsJykge1xuICB2YWxpZGF0ZVN0cmluZyhzaWduYWwsIG5hbWUpXG4gIGlmIChzaWduYWxzW3NpZ25hbF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzaWduYWxzW1N0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlKHNpZ25hbCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfVU5LTk9XTl9TSUdOQUwoc2lnbmFsICsgJyAoc2lnbmFscyBtdXN0IHVzZSBhbGwgY2FwaXRhbCBsZXR0ZXJzKScpXG4gICAgfVxuICAgIHRocm93IG5ldyBFUlJfVU5LTk9XTl9TSUdOQUwoc2lnbmFsKVxuICB9XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQnVmZmVyXG4gKiBAcGFyYW0geyp9IGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPSdidWZmZXInXVxuICogQHJldHVybnMge2Fzc2VydHMgYnVmZmVyIGlzIEFycmF5QnVmZmVyVmlld31cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQnVmZmVyfSAqL1xuY29uc3QgdmFsaWRhdGVCdWZmZXIgPSBoaWRlU3RhY2tGcmFtZXMoKGJ1ZmZlciwgbmFtZSA9ICdidWZmZXInKSA9PiB7XG4gIGlmICghaXNBcnJheUJ1ZmZlclZpZXcoYnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCBbJ0J1ZmZlcicsICdUeXBlZEFycmF5JywgJ0RhdGFWaWV3J10sIGJ1ZmZlcilcbiAgfVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRW5jb2RpbmcoZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpXG4gIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIGlmIChub3JtYWxpemVkRW5jb2RpbmcgPT09ICdoZXgnICYmIGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlbmNvZGluZycsIGVuY29kaW5nLCBgaXMgaW52YWxpZCBmb3IgZGF0YSBvZiBsZW5ndGggJHtsZW5ndGh9YClcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHRoYXQgdGhlIHBvcnQgbnVtYmVyIGlzIG5vdCBOYU4gd2hlbiBjb2VyY2VkIHRvIGEgbnVtYmVyLFxuICogaXMgYW4gaW50ZWdlciBhbmQgdGhhdCBpdCBmYWxscyB3aXRoaW4gdGhlIGxlZ2FsIHJhbmdlIG9mIHBvcnQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Kn0gcG9ydFxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPSdQb3J0J11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93WmVybz10cnVlXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQb3J0KHBvcnQsIG5hbWUgPSAnUG9ydCcsIGFsbG93WmVybyA9IHRydWUpIHtcbiAgaWYgKFxuICAgICh0eXBlb2YgcG9ydCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHBvcnQgIT09ICdzdHJpbmcnKSB8fFxuICAgICh0eXBlb2YgcG9ydCA9PT0gJ3N0cmluZycgJiYgU3RyaW5nUHJvdG90eXBlVHJpbShwb3J0KS5sZW5ndGggPT09IDApIHx8XG4gICAgK3BvcnQgIT09ICtwb3J0ID4+PiAwIHx8XG4gICAgcG9ydCA+IDB4ZmZmZiB8fFxuICAgIChwb3J0ID09PSAwICYmICFhbGxvd1plcm8pXG4gICkge1xuICAgIHRocm93IG5ldyBFUlJfU09DS0VUX0JBRF9QT1JUKG5hbWUsIHBvcnQsIGFsbG93WmVybylcbiAgfVxuICByZXR1cm4gcG9ydCB8IDBcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVBYm9ydFNpZ25hbFxuICogQHBhcmFtIHsqfSBzaWduYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUFib3J0U2lnbmFsfSAqL1xuY29uc3QgdmFsaWRhdGVBYm9ydFNpZ25hbCA9IGhpZGVTdGFja0ZyYW1lcygoc2lnbmFsLCBuYW1lKSA9PiB7XG4gIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCAmJiAoc2lnbmFsID09PSBudWxsIHx8IHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVGdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIEZ1bmN0aW9ufVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVGdW5jdGlvbn0gKi9cbmNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnRnVuY3Rpb24nLCB2YWx1ZSlcbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlUGxhaW5GdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIEZ1bmN0aW9ufVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVQbGFpbkZ1bmN0aW9ufSAqL1xuY29uc3QgdmFsaWRhdGVQbGFpbkZ1bmN0aW9uID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnRnVuY3Rpb24nLCB2YWx1ZSlcbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlVW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgdW5kZWZpbmVkfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVVbmRlZmluZWR9ICovXG5jb25zdCB2YWxpZGF0ZVVuZGVmaW5lZCA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAndW5kZWZpbmVkJywgdmFsdWUpXG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtUW119IHVuaW9uXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24odmFsdWUsIG5hbWUsIHVuaW9uKSB7XG4gIGlmICghQXJyYXlQcm90b3R5cGVJbmNsdWRlcyh1bmlvbiwgdmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsIGAoJyR7QXJyYXlQcm90b3R5cGVKb2luKHVuaW9uLCAnfCcpfScpYCwgdmFsdWUpXG4gIH1cbn1cblxuLypcbiAgVGhlIHJ1bGVzIGZvciB0aGUgTGluayBoZWFkZXIgZmllbGQgYXJlIGRlc2NyaWJlZCBoZXJlOlxuICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjODI4OC5odG1sI3NlY3Rpb24tM1xuXG4gIFRoaXMgcmVnZXggdmFsaWRhdGVzIGFueSBzdHJpbmcgc3Vycm91bmRlZCBieSBhbmdsZSBicmFja2V0c1xuICAobm90IG5lY2Vzc2FyaWx5IGEgdmFsaWQgVVJJIHJlZmVyZW5jZSkgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlXG4gIGxpbmstcGFyYW1zIHNlcGFyYXRlZCBieSBzZW1pY29sb25zLlxuKi9cbmNvbnN0IGxpbmtWYWx1ZVJlZ0V4cCA9IC9eKD86PFtePl0qPikoPzpcXHMqO1xccypbXjtcIlxcc10rKD86PShcIik/W147XCJcXHNdKlxcMSk/KSokL1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0KHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8ICFSZWdFeHBQcm90b3R5cGVFeGVjKGxpbmtWYWx1ZVJlZ0V4cCwgdmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgICdtdXN0IGJlIGFuIGFycmF5IG9yIHN0cmluZyBvZiBmb3JtYXQgXCI8L3N0eWxlcy5jc3M+OyByZWw9cHJlbG9hZDsgYXM9c3R5bGVcIidcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gaGludHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMaW5rSGVhZGVyVmFsdWUoaGludHMpIHtcbiAgaWYgKHR5cGVvZiBoaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWxpZGF0ZUxpbmtIZWFkZXJGb3JtYXQoaGludHMsICdoaW50cycpXG4gICAgcmV0dXJuIGhpbnRzXG4gIH0gZWxzZSBpZiAoQXJyYXlJc0FycmF5KGhpbnRzKSkge1xuICAgIGNvbnN0IGhpbnRzTGVuZ3RoID0gaGludHMubGVuZ3RoXG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgaWYgKGhpbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGludHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluayA9IGhpbnRzW2ldXG4gICAgICB2YWxpZGF0ZUxpbmtIZWFkZXJGb3JtYXQobGluaywgJ2hpbnRzJylcbiAgICAgIHJlc3VsdCArPSBsaW5rXG4gICAgICBpZiAoaSAhPT0gaGludHNMZW5ndGggLSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLCAnXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKFxuICAgICdoaW50cycsXG4gICAgaGludHMsXG4gICAgJ211c3QgYmUgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGZvcm1hdCBcIjwvc3R5bGVzLmNzcz47IHJlbD1wcmVsb2FkOyBhcz1zdHlsZVwiJ1xuICApXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNJbnQzMixcbiAgaXNVaW50MzIsXG4gIHBhcnNlRmlsZU1vZGUsXG4gIHZhbGlkYXRlQXJyYXksXG4gIHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gIHZhbGlkYXRlQm9vbGVhbkFycmF5LFxuICB2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXksXG4gIHZhbGlkYXRlQm9vbGVhbixcbiAgdmFsaWRhdGVCdWZmZXIsXG4gIHZhbGlkYXRlRGljdGlvbmFyeSxcbiAgdmFsaWRhdGVFbmNvZGluZyxcbiAgdmFsaWRhdGVGdW5jdGlvbixcbiAgdmFsaWRhdGVJbnQzMixcbiAgdmFsaWRhdGVJbnRlZ2VyLFxuICB2YWxpZGF0ZU51bWJlcixcbiAgdmFsaWRhdGVPYmplY3QsXG4gIHZhbGlkYXRlT25lT2YsXG4gIHZhbGlkYXRlUGxhaW5GdW5jdGlvbixcbiAgdmFsaWRhdGVQb3J0LFxuICB2YWxpZGF0ZVNpZ25hbE5hbWUsXG4gIHZhbGlkYXRlU3RyaW5nLFxuICB2YWxpZGF0ZVVpbnQzMixcbiAgdmFsaWRhdGVVbmRlZmluZWQsXG4gIHZhbGlkYXRlVW5pb24sXG4gIHZhbGlkYXRlQWJvcnRTaWduYWwsXG4gIHZhbGlkYXRlTGlua0hlYWRlclZhbHVlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/validators.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { format, inspect, AggregateError: CustomAggregateError } = __webpack_require__(/*! ./util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError\nconst kIsNodeError = Symbol('kIsNodeError')\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/\nconst nodeInternalPrefix = '__node_internal_'\nconst codes = {}\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message)\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length,\n      // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`\n    )\n    return msg(...args)\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) {\n    return msg\n  }\n  return format(msg, ...args)\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args))\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  })\n  NodeError.prototype.code = code\n  NodeError.prototype[kIsNodeError] = true\n  codes[code] = NodeError\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  })\n  return fn\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError)\n      return outerError\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message)\n    err.code = outerError.code\n    return err\n  }\n  return innerError || outerError\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)\n    }\n    super(message, options)\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\nE('ERR_ASSERTION', '%s', Error)\nE(\n  'ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\")\n    if (!Array.isArray(expected)) {\n      expected = [expected]\n    }\n    let msg = 'The '\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `\n    } else {\n      msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `\n    }\n    msg += 'must be '\n    const types = []\n    const instances = []\n    const other = []\n    for (const value of expected) {\n      assert(typeof value === 'string', 'All expected entries have to be of type string')\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase())\n      } else if (classRegExp.test(value)) {\n        instances.push(value)\n      } else {\n        assert(value !== 'object', 'The value \"object\" should be written as \"Object\"')\n        other.push(value)\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object')\n      if (pos !== -1) {\n        types.splice(types, pos, 1)\n        instances.push('Object')\n      }\n    }\n    if (types.length > 0) {\n      switch (types.length) {\n        case 1:\n          msg += `of type ${types[0]}`\n          break\n        case 2:\n          msg += `one of type ${types[0]} or ${types[1]}`\n          break\n        default: {\n          const last = types.pop()\n          msg += `one of type ${types.join(', ')}, or ${last}`\n        }\n      }\n      if (instances.length > 0 || other.length > 0) {\n        msg += ' or '\n      }\n    }\n    if (instances.length > 0) {\n      switch (instances.length) {\n        case 1:\n          msg += `an instance of ${instances[0]}`\n          break\n        case 2:\n          msg += `an instance of ${instances[0]} or ${instances[1]}`\n          break\n        default: {\n          const last = instances.pop()\n          msg += `an instance of ${instances.join(', ')}, or ${last}`\n        }\n      }\n      if (other.length > 0) {\n        msg += ' or '\n      }\n    }\n    switch (other.length) {\n      case 0:\n        break\n      case 1:\n        if (other[0].toLowerCase() !== other[0]) {\n          msg += 'an '\n        }\n        msg += `${other[0]}`\n        break\n      case 2:\n        msg += `one of ${other[0]} or ${other[1]}`\n        break\n      default: {\n        const last = other.pop()\n        msg += `one of ${other.join(', ')}, or ${last}`\n      }\n    }\n    if (actual == null) {\n      msg += `. Received ${actual}`\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`\n    } else if (typeof actual === 'object') {\n      var _actual$constructor\n      if (\n        (_actual$constructor = actual.constructor) !== null &&\n        _actual$constructor !== undefined &&\n        _actual$constructor.name\n      ) {\n        msg += `. Received an instance of ${actual.constructor.name}`\n      } else {\n        const inspected = inspect(actual, {\n          depth: -1\n        })\n        msg += `. Received ${inspected}`\n      }\n    } else {\n      let inspected = inspect(actual, {\n        colors: false\n      })\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`\n    }\n    return msg\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_ARG_VALUE',\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n    if (inspected.length > 128) {\n      inspected = inspected.slice(0, 128) + '...'\n    }\n    const type = name.includes('.') ? 'property' : 'argument'\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_RETURN_VALUE',\n  (input, name, value) => {\n    var _value$constructor\n    const type =\n      value !== null &&\n      value !== undefined &&\n      (_value$constructor = value.constructor) !== null &&\n      _value$constructor !== undefined &&\n      _value$constructor.name\n        ? `instance of ${value.constructor.name}`\n        : `type ${typeof value}`\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`\n  },\n  TypeError\n)\nE(\n  'ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified')\n    let msg\n    const len = args.length\n    args = (Array.isArray(args) ? args : [args]).map((a) => `\"${a}\"`).join(' or ')\n    switch (len) {\n      case 1:\n        msg += `The ${args[0]} argument`\n        break\n      case 2:\n        msg += `The ${args[0]} and ${args[1]} arguments`\n        break\n      default:\n        {\n          const last = args.pop()\n          msg += `The ${args.join(', ')}, and ${last} arguments`\n        }\n        break\n    }\n    return `${msg} must be specified`\n  },\n  TypeError\n)\nE(\n  'ERR_OUT_OF_RANGE',\n  (str, range, input) => {\n    assert(range, 'Missing \"range\" argument')\n    let received\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    } else {\n      received = inspect(input)\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`\n  },\n  RangeError\n)\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsd0RBQXdELEVBQUUsbUJBQU8sQ0FBQyxrR0FBUTs7QUFFbEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLGNBQWMsb0JBQW9CLEVBQUUsSUFBSTtBQUN4QztBQUNBLFlBQVksZ0JBQWdCLEVBQUUsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU0saUNBQWlDLFlBQVksc0NBQXNDLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNLGlDQUFpQyxZQUFZLHNDQUFzQyxlQUFlO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLEdBQUcsS0FBSyxLQUFLLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyxLQUFLLEtBQUssYUFBYTtBQUN2RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsTUFBTTtBQUNOLGlCQUFpQixLQUFLLElBQUksOENBQThDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsS0FBSyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsT0FBTyxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyxLQUFLLGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQixPQUFPLEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsS0FBSyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUIsT0FBTyxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDLE1BQU07QUFDTixvQ0FBb0MsWUFBWTtBQUNoRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLGdDQUFnQyxlQUFlLEdBQUcsVUFBVTtBQUM1RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sR0FBRyxLQUFLLElBQUksT0FBTyxhQUFhLFVBQVU7QUFDbEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQsa0JBQWtCLGFBQWE7QUFDL0IsdUJBQXVCLE9BQU8sMkJBQTJCLEtBQUssMEJBQTBCLEtBQUs7QUFDN0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsRUFBRTtBQUNsRTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixTQUFTLE1BQU0sU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsUUFBUSxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRCQUE0QixJQUFJLGdDQUFnQyxNQUFNLGFBQWEsU0FBUztBQUM1RixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZm9ybWF0LCBpbnNwZWN0LCBBZ2dyZWdhdGVFcnJvcjogQ3VzdG9tQWdncmVnYXRlRXJyb3IgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qXG4gIFRoaXMgZmlsZSBpcyBhIHJlZHVjZWQgYW5kIGFkYXB0ZWQgdmVyc2lvbiBvZiB0aGUgbWFpbiBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzIGZpbGUgZGVmaW5lZCBhdFxuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cbiAgRG9uJ3QgdHJ5IHRvIHJlcGxhY2Ugd2l0aCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQga2VlcCBpdCB1cCB0byBkYXRlIChzdGFydGluZyBmcm9tIEUoLi4uKSBkZWZpbml0aW9ucylcbiAgd2l0aCB0aGUgdXBzdHJlYW0gZmlsZS5cbiovXG5cbmNvbnN0IEFnZ3JlZ2F0ZUVycm9yID0gZ2xvYmFsVGhpcy5BZ2dyZWdhdGVFcnJvciB8fCBDdXN0b21BZ2dyZWdhdGVFcnJvclxuY29uc3Qga0lzTm9kZUVycm9yID0gU3ltYm9sKCdrSXNOb2RlRXJyb3InKVxuY29uc3Qga1R5cGVzID0gW1xuICAnc3RyaW5nJyxcbiAgJ2Z1bmN0aW9uJyxcbiAgJ251bWJlcicsXG4gICdvYmplY3QnLFxuICAvLyBBY2NlcHQgJ0Z1bmN0aW9uJyBhbmQgJ09iamVjdCcgYXMgYWx0ZXJuYXRpdmUgdG8gdGhlIGxvd2VyIGNhc2VkIHZlcnNpb24uXG4gICdGdW5jdGlvbicsXG4gICdPYmplY3QnLFxuICAnYm9vbGVhbicsXG4gICdiaWdpbnQnLFxuICAnc3ltYm9sJ1xuXVxuY29uc3QgY2xhc3NSZWdFeHAgPSAvXihbQS1aXVthLXowLTldKikrJC9cbmNvbnN0IG5vZGVJbnRlcm5hbFByZWZpeCA9ICdfX25vZGVfaW50ZXJuYWxfJ1xuY29uc3QgY29kZXMgPSB7fVxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgY29kZXMuRVJSX0lOVEVSTkFMX0FTU0VSVElPTihtZXNzYWdlKVxuICB9XG59XG5cbi8vIE9ubHkgdXNlIHRoaXMgZm9yIGludGVnZXJzISBEZWNpbWFsIG51bWJlcnMgZG8gbm90IHdvcmsgd2l0aCB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5LCBtc2csIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NlcnQoXG4gICAgICBtc2cubGVuZ3RoIDw9IGFyZ3MubGVuZ3RoLFxuICAgICAgLy8gRGVmYXVsdCBvcHRpb25zIGRvIG5vdCBjb3VudC5cbiAgICAgIGBDb2RlOiAke2tleX07IFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbGVuZ3RoICgke2FyZ3MubGVuZ3RofSkgZG9lcyBub3QgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmBcbiAgICApXG4gICAgcmV0dXJuIG1zZyguLi5hcmdzKVxuICB9XG4gIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gKG1zZy5tYXRjaCgvJVtkZmlqb09zXS9nKSB8fCBbXSkubGVuZ3RoXG4gIGFzc2VydChcbiAgICBleHBlY3RlZExlbmd0aCA9PT0gYXJncy5sZW5ndGgsXG4gICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHtleHBlY3RlZExlbmd0aH0pLmBcbiAgKVxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbXNnXG4gIH1cbiAgcmV0dXJuIGZvcm1hdChtc2csIC4uLmFyZ3MpXG59XG5mdW5jdGlvbiBFKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yXG4gIH1cbiAgY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoZ2V0TWVzc2FnZShjb2RlLCBtZXNzYWdlLCBhcmdzKSlcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtjb2RlfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTm9kZUVycm9yLnByb3RvdHlwZSwge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbHVlOiBCYXNlLm5hbWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICB0b1N0cmluZzoge1xuICAgICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2NvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pXG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGVcbiAgTm9kZUVycm9yLnByb3RvdHlwZVtrSXNOb2RlRXJyb3JdID0gdHJ1ZVxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvclxufVxuZnVuY3Rpb24gaGlkZVN0YWNrRnJhbWVzKGZuKSB7XG4gIC8vIFdlIHJlbmFtZSB0aGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBoaWRkZW4gdG8gY3V0IG9mZiB0aGUgc3RhY2t0cmFjZVxuICAvLyBhdCB0aGUgb3V0ZXJtb3N0IG9uZVxuICBjb25zdCBoaWRkZW4gPSBub2RlSW50ZXJuYWxQcmVmaXggKyBmbi5uYW1lXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IGhpZGRlblxuICB9KVxuICByZXR1cm4gZm5cbn1cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVR3b0Vycm9ycyhpbm5lckVycm9yLCBvdXRlckVycm9yKSB7XG4gIGlmIChpbm5lckVycm9yICYmIG91dGVyRXJyb3IgJiYgaW5uZXJFcnJvciAhPT0gb3V0ZXJFcnJvcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG91dGVyRXJyb3IuZXJyb3JzKSkge1xuICAgICAgLy8gSWYgYG91dGVyRXJyb3JgIGlzIGFscmVhZHkgYW4gYEFnZ3JlZ2F0ZUVycm9yYC5cbiAgICAgIG91dGVyRXJyb3IuZXJyb3JzLnB1c2goaW5uZXJFcnJvcilcbiAgICAgIHJldHVybiBvdXRlckVycm9yXG4gICAgfVxuICAgIGNvbnN0IGVyciA9IG5ldyBBZ2dyZWdhdGVFcnJvcihbb3V0ZXJFcnJvciwgaW5uZXJFcnJvcl0sIG91dGVyRXJyb3IubWVzc2FnZSlcbiAgICBlcnIuY29kZSA9IG91dGVyRXJyb3IuY29kZVxuICAgIHJldHVybiBlcnJcbiAgfVxuICByZXR1cm4gaW5uZXJFcnJvciB8fCBvdXRlckVycm9yXG59XG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKVxuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKVxuICAgIHRoaXMuY29kZSA9ICdBQk9SVF9FUlInXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gIH1cbn1cbkUoJ0VSUl9BU1NFUlRJT04nLCAnJXMnLCBFcnJvcilcbkUoXG4gICdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gICAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKVxuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgIGV4cGVjdGVkID0gW2V4cGVjdGVkXVxuICAgIH1cbiAgICBsZXQgbXNnID0gJ1RoZSAnXG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJyBhcmd1bWVudCcpKSB7XG4gICAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgICBtc2cgKz0gYCR7bmFtZX0gYFxuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgKz0gYFwiJHtuYW1lfVwiICR7bmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCd9IGBcbiAgICB9XG4gICAgbXNnICs9ICdtdXN0IGJlICdcbiAgICBjb25zdCB0eXBlcyA9IFtdXG4gICAgY29uc3QgaW5zdGFuY2VzID0gW11cbiAgICBjb25zdCBvdGhlciA9IFtdXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBleHBlY3RlZCkge1xuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdBbGwgZXhwZWN0ZWQgZW50cmllcyBoYXZlIHRvIGJlIG9mIHR5cGUgc3RyaW5nJylcbiAgICAgIGlmIChrVHlwZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHR5cGVzLnB1c2godmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIH0gZWxzZSBpZiAoY2xhc3NSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQodmFsdWUgIT09ICdvYmplY3QnLCAnVGhlIHZhbHVlIFwib2JqZWN0XCIgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgXCJPYmplY3RcIicpXG4gICAgICAgIG90aGVyLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBoYW5kbGUgYG9iamVjdGAgaW4gY2FzZSBvdGhlciBpbnN0YW5jZXMgYXJlIGFsbG93ZWQgdG8gb3V0bGluZVxuICAgIC8vIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGVhY2ggb3RoZXIuXG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwb3MgPSB0eXBlcy5pbmRleE9mKCdvYmplY3QnKVxuICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKHR5cGVzLCBwb3MsIDEpXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKCdPYmplY3QnKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3dpdGNoICh0eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1zZyArPSBgb2YgdHlwZSAke3R5cGVzWzBdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbXNnICs9IGBvbmUgb2YgdHlwZSAke3R5cGVzWzBdfSBvciAke3R5cGVzWzFdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IHR5cGVzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBvbmUgb2YgdHlwZSAke3R5cGVzLmpvaW4oJywgJyl9LCBvciAke2xhc3R9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDAgfHwgb3RoZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gJyBvciAnXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3dpdGNoIChpbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzWzBdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbXNnICs9IGBhbiBpbnN0YW5jZSBvZiAke2luc3RhbmNlc1swXX0gb3IgJHtpbnN0YW5jZXNbMV19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gaW5zdGFuY2VzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBhbiBpbnN0YW5jZSBvZiAke2luc3RhbmNlcy5qb2luKCcsICcpfSwgb3IgJHtsYXN0fWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXNnICs9ICcgb3IgJ1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG90aGVyLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAob3RoZXJbMF0udG9Mb3dlckNhc2UoKSAhPT0gb3RoZXJbMF0pIHtcbiAgICAgICAgICBtc2cgKz0gJ2FuICdcbiAgICAgICAgfVxuICAgICAgICBtc2cgKz0gYCR7b3RoZXJbMF19YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtc2cgKz0gYG9uZSBvZiAke290aGVyWzBdfSBvciAke290aGVyWzFdfWBcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgbGFzdCA9IG90aGVyLnBvcCgpXG4gICAgICAgIG1zZyArPSBgb25lIG9mICR7b3RoZXIuam9pbignLCAnKX0sIG9yICR7bGFzdH1gXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhY3R1YWwgPT0gbnVsbCkge1xuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkICR7YWN0dWFsfWBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdmdW5jdGlvbicgJiYgYWN0dWFsLm5hbWUpIHtcbiAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCBmdW5jdGlvbiAke2FjdHVhbC5uYW1lfWBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgX2FjdHVhbCRjb25zdHJ1Y3RvclxuICAgICAgaWYgKFxuICAgICAgICAoX2FjdHVhbCRjb25zdHJ1Y3RvciA9IGFjdHVhbC5jb25zdHJ1Y3RvcikgIT09IG51bGwgJiZcbiAgICAgICAgX2FjdHVhbCRjb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9hY3R1YWwkY29uc3RydWN0b3IubmFtZVxuICAgICAgKSB7XG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCBhbiBpbnN0YW5jZSBvZiAke2FjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3BlY3RlZCA9IGluc3BlY3QoYWN0dWFsLCB7XG4gICAgICAgICAgZGVwdGg6IC0xXG4gICAgICAgIH0pXG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCAke2luc3BlY3RlZH1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpbnNwZWN0ZWQgPSBpbnNwZWN0KGFjdHVhbCwge1xuICAgICAgICBjb2xvcnM6IGZhbHNlXG4gICAgICB9KVxuICAgICAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAyNSkge1xuICAgICAgICBpbnNwZWN0ZWQgPSBgJHtpbnNwZWN0ZWQuc2xpY2UoMCwgMjUpfS4uLmBcbiAgICAgIH1cbiAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH0gKCR7aW5zcGVjdGVkfSlgXG4gICAgfVxuICAgIHJldHVybiBtc2dcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJyxcbiAgKG5hbWUsIHZhbHVlLCByZWFzb24gPSAnaXMgaW52YWxpZCcpID0+IHtcbiAgICBsZXQgaW5zcGVjdGVkID0gaW5zcGVjdCh2YWx1ZSlcbiAgICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgICAgaW5zcGVjdGVkID0gaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCkgKyAnLi4uJ1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gbmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCdcbiAgICByZXR1cm4gYFRoZSAke3R5cGV9ICcke25hbWV9JyAke3JlYXNvbn0uIFJlY2VpdmVkICR7aW5zcGVjdGVkfWBcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJyxcbiAgKGlucHV0LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIHZhciBfdmFsdWUkY29uc3RydWN0b3JcbiAgICBjb25zdCB0eXBlID1cbiAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpICE9PSBudWxsICYmXG4gICAgICBfdmFsdWUkY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgX3ZhbHVlJGNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgPyBgaW5zdGFuY2Ugb2YgJHt2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lfWBcbiAgICAgICAgOiBgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgcmV0dXJuIGBFeHBlY3RlZCAke2lucHV0fSB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcIiR7bmFtZX1cImAgKyBgIGZ1bmN0aW9uIGJ1dCBnb3QgJHt0eXBlfS5gXG4gIH0sXG4gIFR5cGVFcnJvclxuKVxuRShcbiAgJ0VSUl9NSVNTSU5HX0FSR1MnLFxuICAoLi4uYXJncykgPT4ge1xuICAgIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpXG4gICAgbGV0IG1zZ1xuICAgIGNvbnN0IGxlbiA9IGFyZ3MubGVuZ3RoXG4gICAgYXJncyA9IChBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXSkubWFwKChhKSA9PiBgXCIke2F9XCJgKS5qb2luKCcgb3IgJylcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtc2cgKz0gYFRoZSAke2FyZ3NbMF19IGFyZ3VtZW50YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtc2cgKz0gYFRoZSAke2FyZ3NbMF19IGFuZCAke2FyZ3NbMV19IGFyZ3VtZW50c2BcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gYXJncy5wb3AoKVxuICAgICAgICAgIG1zZyArPSBgVGhlICR7YXJncy5qb2luKCcsICcpfSwgYW5kICR7bGFzdH0gYXJndW1lbnRzYFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBgJHttc2d9IG11c3QgYmUgc3BlY2lmaWVkYFxuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfT1VUX09GX1JBTkdFJyxcbiAgKHN0ciwgcmFuZ2UsIGlucHV0KSA9PiB7XG4gICAgYXNzZXJ0KHJhbmdlLCAnTWlzc2luZyBcInJhbmdlXCIgYXJndW1lbnQnKVxuICAgIGxldCByZWNlaXZlZFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiAybiAqKiAzMm4gfHwgaW5wdXQgPCAtKDJuICoqIDMybikpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZWl2ZWQgPSBpbnNwZWN0KGlucHV0KVxuICAgIH1cbiAgICByZXR1cm4gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gIH0sXG4gIFJhbmdlRXJyb3JcbilcbkUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnLCBFcnJvcilcbkUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgJ1RoZSAlcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJywgRXJyb3IpXG5FKCdFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRUQnLCAnQ2Fubm90IGNhbGwgJXMgYWZ0ZXIgYSBzdHJlYW0gd2FzIGZpbmlzaGVkJywgRXJyb3IpXG5FKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgJ0Nhbm5vdCBjYWxsICVzIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpXG5FKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcsIEVycm9yKVxuRSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCAnVW5rbm93biBlbmNvZGluZzogJXMnLCBUeXBlRXJyb3IpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWJvcnRFcnJvcixcbiAgYWdncmVnYXRlVHdvRXJyb3JzOiBoaWRlU3RhY2tGcmFtZXMoYWdncmVnYXRlVHdvRXJyb3JzKSxcbiAgaGlkZVN0YWNrRnJhbWVzLFxuICBjb2Rlc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/index.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nif (Stream && process.env.READABLE_STREAM === 'disable') {\n  const promises = Stream.promises\n\n  // Explicit export naming is needed for ESM\n  module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer\n  module.exports._isUint8Array = Stream._isUint8Array\n  module.exports.isDisturbed = Stream.isDisturbed\n  module.exports.isErrored = Stream.isErrored\n  module.exports.isReadable = Stream.isReadable\n  module.exports.Readable = Stream.Readable\n  module.exports.Writable = Stream.Writable\n  module.exports.Duplex = Stream.Duplex\n  module.exports.Transform = Stream.Transform\n  module.exports.PassThrough = Stream.PassThrough\n  module.exports.addAbortSignal = Stream.addAbortSignal\n  module.exports.finished = Stream.finished\n  module.exports.destroy = Stream.destroy\n  module.exports.pipeline = Stream.pipeline\n  module.exports.compose = Stream.compose\n  Object.defineProperty(Stream, 'promises', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return promises\n    }\n  })\n  module.exports.Stream = Stream.Stream\n} else {\n  const CustomStream = __webpack_require__(/*! ../stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream.js\")\n  const promises = __webpack_require__(/*! ../stream/promises */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream/promises.js\")\n  const originalDestroy = CustomStream.Readable.destroy\n  module.exports = CustomStream.Readable\n\n  // Explicit export naming is needed for ESM\n  module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer\n  module.exports._isUint8Array = CustomStream._isUint8Array\n  module.exports.isDisturbed = CustomStream.isDisturbed\n  module.exports.isErrored = CustomStream.isErrored\n  module.exports.isReadable = CustomStream.isReadable\n  module.exports.Readable = CustomStream.Readable\n  module.exports.Writable = CustomStream.Writable\n  module.exports.Duplex = CustomStream.Duplex\n  module.exports.Transform = CustomStream.Transform\n  module.exports.PassThrough = CustomStream.PassThrough\n  module.exports.addAbortSignal = CustomStream.addAbortSignal\n  module.exports.finished = CustomStream.finished\n  module.exports.destroy = CustomStream.destroy\n  module.exports.destroy = originalDestroy\n  module.exports.pipeline = CustomStream.pipeline\n  module.exports.compose = CustomStream.compose\n  Object.defineProperty(CustomStream, 'promises', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return promises\n    }\n  })\n  module.exports.Stream = CustomStream.Stream\n}\n\n// Allow default importing\nmodule.exports[\"default\"] = module.exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGtDQUFrQztBQUNwQyxFQUFFLDRCQUE0QjtBQUM5QixFQUFFLDBCQUEwQjtBQUM1QixFQUFFLHdCQUF3QjtBQUMxQixFQUFFLHlCQUF5QjtBQUMzQixFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLHdCQUF3QjtBQUMxQixFQUFFLDBCQUEwQjtBQUM1QixFQUFFLDZCQUE2QjtBQUMvQixFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHNCQUFzQjtBQUN4QixFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHNCQUFzQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRTtBQUNGLHVCQUF1QixtQkFBTyxDQUFDLGtHQUFXO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLG9IQUFvQjtBQUMvQztBQUNBOztBQUVBO0FBQ0EsRUFBRSxrQ0FBa0M7QUFDcEMsRUFBRSw0QkFBNEI7QUFDOUIsRUFBRSwwQkFBMEI7QUFDNUIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSwwQkFBMEI7QUFDNUIsRUFBRSw2QkFBNkI7QUFDL0IsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxzQkFBc0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUscUJBQXFCO0FBQ3ZCOztBQUVBO0FBQ0EseUJBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5pZiAoU3RyZWFtICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnKSB7XG4gIGNvbnN0IHByb21pc2VzID0gU3RyZWFtLnByb21pc2VzXG5cbiAgLy8gRXhwbGljaXQgZXhwb3J0IG5hbWluZyBpcyBuZWVkZWQgZm9yIEVTTVxuICBtb2R1bGUuZXhwb3J0cy5fdWludDhBcnJheVRvQnVmZmVyID0gU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXJcbiAgbW9kdWxlLmV4cG9ydHMuX2lzVWludDhBcnJheSA9IFN0cmVhbS5faXNVaW50OEFycmF5XG4gIG1vZHVsZS5leHBvcnRzLmlzRGlzdHVyYmVkID0gU3RyZWFtLmlzRGlzdHVyYmVkXG4gIG1vZHVsZS5leHBvcnRzLmlzRXJyb3JlZCA9IFN0cmVhbS5pc0Vycm9yZWRcbiAgbW9kdWxlLmV4cG9ydHMuaXNSZWFkYWJsZSA9IFN0cmVhbS5pc1JlYWRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLlJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLldyaXRhYmxlID0gU3RyZWFtLldyaXRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLkR1cGxleCA9IFN0cmVhbS5EdXBsZXhcbiAgbW9kdWxlLmV4cG9ydHMuVHJhbnNmb3JtID0gU3RyZWFtLlRyYW5zZm9ybVxuICBtb2R1bGUuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaFxuICBtb2R1bGUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbCA9IFN0cmVhbS5hZGRBYm9ydFNpZ25hbFxuICBtb2R1bGUuZXhwb3J0cy5maW5pc2hlZCA9IFN0cmVhbS5maW5pc2hlZFxuICBtb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gU3RyZWFtLmRlc3Ryb3lcbiAgbW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSBTdHJlYW0ucGlwZWxpbmVcbiAgbW9kdWxlLmV4cG9ydHMuY29tcG9zZSA9IFN0cmVhbS5jb21wb3NlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0sICdwcm9taXNlcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZXNcbiAgICB9XG4gIH0pXG4gIG1vZHVsZS5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbS5TdHJlYW1cbn0gZWxzZSB7XG4gIGNvbnN0IEN1c3RvbVN0cmVhbSA9IHJlcXVpcmUoJy4uL3N0cmVhbScpXG4gIGNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi4vc3RyZWFtL3Byb21pc2VzJylcbiAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gQ3VzdG9tU3RyZWFtLlJlYWRhYmxlLmRlc3Ryb3lcbiAgbW9kdWxlLmV4cG9ydHMgPSBDdXN0b21TdHJlYW0uUmVhZGFibGVcblxuICAvLyBFeHBsaWNpdCBleHBvcnQgbmFtaW5nIGlzIG5lZWRlZCBmb3IgRVNNXG4gIG1vZHVsZS5leHBvcnRzLl91aW50OEFycmF5VG9CdWZmZXIgPSBDdXN0b21TdHJlYW0uX3VpbnQ4QXJyYXlUb0J1ZmZlclxuICBtb2R1bGUuZXhwb3J0cy5faXNVaW50OEFycmF5ID0gQ3VzdG9tU3RyZWFtLl9pc1VpbnQ4QXJyYXlcbiAgbW9kdWxlLmV4cG9ydHMuaXNEaXN0dXJiZWQgPSBDdXN0b21TdHJlYW0uaXNEaXN0dXJiZWRcbiAgbW9kdWxlLmV4cG9ydHMuaXNFcnJvcmVkID0gQ3VzdG9tU3RyZWFtLmlzRXJyb3JlZFxuICBtb2R1bGUuZXhwb3J0cy5pc1JlYWRhYmxlID0gQ3VzdG9tU3RyZWFtLmlzUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuUmVhZGFibGUgPSBDdXN0b21TdHJlYW0uUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuV3JpdGFibGUgPSBDdXN0b21TdHJlYW0uV3JpdGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuRHVwbGV4ID0gQ3VzdG9tU3RyZWFtLkR1cGxleFxuICBtb2R1bGUuZXhwb3J0cy5UcmFuc2Zvcm0gPSBDdXN0b21TdHJlYW0uVHJhbnNmb3JtXG4gIG1vZHVsZS5leHBvcnRzLlBhc3NUaHJvdWdoID0gQ3VzdG9tU3RyZWFtLlBhc3NUaHJvdWdoXG4gIG1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsID0gQ3VzdG9tU3RyZWFtLmFkZEFib3J0U2lnbmFsXG4gIG1vZHVsZS5leHBvcnRzLmZpbmlzaGVkID0gQ3VzdG9tU3RyZWFtLmZpbmlzaGVkXG4gIG1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBDdXN0b21TdHJlYW0uZGVzdHJveVxuICBtb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gb3JpZ2luYWxEZXN0cm95XG4gIG1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gQ3VzdG9tU3RyZWFtLnBpcGVsaW5lXG4gIG1vZHVsZS5leHBvcnRzLmNvbXBvc2UgPSBDdXN0b21TdHJlYW0uY29tcG9zZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tU3RyZWFtLCAncHJvbWlzZXMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHByb21pc2VzXG4gICAgfVxuICB9KVxuICBtb2R1bGUuZXhwb3J0cy5TdHJlYW0gPSBDdXN0b21TdHJlYW0uU3RyZWFtXG59XG5cbi8vIEFsbG93IGRlZmF1bHQgaW1wb3J0aW5nXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\nmodule.exports = {\n  ArrayIsArray(self) {\n    return Array.isArray(self)\n  },\n  ArrayPrototypeIncludes(self, el) {\n    return self.includes(el)\n  },\n  ArrayPrototypeIndexOf(self, el) {\n    return self.indexOf(el)\n  },\n  ArrayPrototypeJoin(self, sep) {\n    return self.join(sep)\n  },\n  ArrayPrototypeMap(self, fn) {\n    return self.map(fn)\n  },\n  ArrayPrototypePop(self, el) {\n    return self.pop(el)\n  },\n  ArrayPrototypePush(self, el) {\n    return self.push(el)\n  },\n  ArrayPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  Error,\n  FunctionPrototypeCall(fn, thisArgs, ...args) {\n    return fn.call(thisArgs, ...args)\n  },\n  FunctionPrototypeSymbolHasInstance(self, instance) {\n    return Function.prototype[Symbol.hasInstance].call(self, instance)\n  },\n  MathFloor: Math.floor,\n  Number,\n  NumberIsInteger: Number.isInteger,\n  NumberIsNaN: Number.isNaN,\n  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n  NumberParseInt: Number.parseInt,\n  ObjectDefineProperties(self, props) {\n    return Object.defineProperties(self, props)\n  },\n  ObjectDefineProperty(self, name, prop) {\n    return Object.defineProperty(self, name, prop)\n  },\n  ObjectGetOwnPropertyDescriptor(self, name) {\n    return Object.getOwnPropertyDescriptor(self, name)\n  },\n  ObjectKeys(obj) {\n    return Object.keys(obj)\n  },\n  ObjectSetPrototypeOf(target, proto) {\n    return Object.setPrototypeOf(target, proto)\n  },\n  Promise,\n  PromisePrototypeCatch(self, fn) {\n    return self.catch(fn)\n  },\n  PromisePrototypeThen(self, thenFn, catchFn) {\n    return self.then(thenFn, catchFn)\n  },\n  PromiseReject(err) {\n    return Promise.reject(err)\n  },\n  PromiseResolve(val) {\n    return Promise.resolve(val)\n  },\n  ReflectApply: Reflect.apply,\n  RegExpPrototypeTest(self, value) {\n    return self.test(value)\n  },\n  SafeSet: Set,\n  String,\n  StringPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  StringPrototypeToLowerCase(self) {\n    return self.toLowerCase()\n  },\n  StringPrototypeToUpperCase(self) {\n    return self.toUpperCase()\n  },\n  StringPrototypeTrim(self) {\n    return self.trim()\n  },\n  Symbol,\n  SymbolFor: Symbol.for,\n  SymbolAsyncIterator: Symbol.asyncIterator,\n  SymbolHasInstance: Symbol.hasInstance,\n  SymbolIterator: Symbol.iterator,\n  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n  TypedArrayPrototypeSet(self, buf, len) {\n    return self.set(buf, len)\n  },\n  Boolean: Boolean,\n  Uint8Array\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvcHJpbW9yZGlhbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvcHJpbW9yZGlhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gIFRoaXMgZmlsZSBpcyBhIHJlZHVjZWQgYW5kIGFkYXB0ZWQgdmVyc2lvbiBvZiB0aGUgbWFpbiBsaWIvaW50ZXJuYWwvcGVyX2NvbnRleHQvcHJpbW9yZGlhbHMuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9wZXJfY29udGV4dC9wcmltb3JkaWFscy5qc1xuXG4gIERvbid0IHRyeSB0byByZXBsYWNlIHdpdGggdGhlIG9yaWdpbmFsIGZpbGUgYW5kIGtlZXAgaXQgdXAgdG8gZGF0ZSB3aXRoIHRoZSB1cHN0cmVhbSBmaWxlLlxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBcnJheUlzQXJyYXkoc2VsZikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlbGYpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlSW5jbHVkZXMoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5pbmNsdWRlcyhlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVJbmRleE9mKHNlbGYsIGVsKSB7XG4gICAgcmV0dXJuIHNlbGYuaW5kZXhPZihlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVKb2luKHNlbGYsIHNlcCkge1xuICAgIHJldHVybiBzZWxmLmpvaW4oc2VwKVxuICB9LFxuICBBcnJheVByb3RvdHlwZU1hcChzZWxmLCBmbikge1xuICAgIHJldHVybiBzZWxmLm1hcChmbilcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVQb3Aoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5wb3AoZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlUHVzaChzZWxmLCBlbCkge1xuICAgIHJldHVybiBzZWxmLnB1c2goZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIEVycm9yLFxuICBGdW5jdGlvblByb3RvdHlwZUNhbGwoZm4sIHRoaXNBcmdzLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZ3MsIC4uLmFyZ3MpXG4gIH0sXG4gIEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2Uoc2VsZiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbChzZWxmLCBpbnN0YW5jZSlcbiAgfSxcbiAgTWF0aEZsb29yOiBNYXRoLmZsb29yLFxuICBOdW1iZXIsXG4gIE51bWJlcklzSW50ZWdlcjogTnVtYmVyLmlzSW50ZWdlcixcbiAgTnVtYmVySXNOYU46IE51bWJlci5pc05hTixcbiAgTnVtYmVyTUFYX1NBRkVfSU5URUdFUjogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIE51bWJlck1JTl9TQUZFX0lOVEVHRVI6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJQYXJzZUludDogTnVtYmVyLnBhcnNlSW50LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKVxuICB9LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKVxuICB9LFxuICBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZiwgbmFtZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlbGYsIG5hbWUpXG4gIH0sXG4gIE9iamVjdEtleXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgfSxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbiAgfSxcbiAgUHJvbWlzZSxcbiAgUHJvbWlzZVByb3RvdHlwZUNhdGNoKHNlbGYsIGZuKSB7XG4gICAgcmV0dXJuIHNlbGYuY2F0Y2goZm4pXG4gIH0sXG4gIFByb21pc2VQcm90b3R5cGVUaGVuKHNlbGYsIHRoZW5GbiwgY2F0Y2hGbikge1xuICAgIHJldHVybiBzZWxmLnRoZW4odGhlbkZuLCBjYXRjaEZuKVxuICB9LFxuICBQcm9taXNlUmVqZWN0KGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gIH0sXG4gIFByb21pc2VSZXNvbHZlKHZhbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKVxuICB9LFxuICBSZWZsZWN0QXBwbHk6IFJlZmxlY3QuYXBwbHksXG4gIFJlZ0V4cFByb3RvdHlwZVRlc3Qoc2VsZiwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2VsZi50ZXN0KHZhbHVlKVxuICB9LFxuICBTYWZlU2V0OiBTZXQsXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b0xvd2VyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b1VwcGVyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRyaW0oc2VsZikge1xuICAgIHJldHVybiBzZWxmLnRyaW0oKVxuICB9LFxuICBTeW1ib2wsXG4gIFN5bWJvbEZvcjogU3ltYm9sLmZvcixcbiAgU3ltYm9sQXN5bmNJdGVyYXRvcjogU3ltYm9sLmFzeW5jSXRlcmF0b3IsXG4gIFN5bWJvbEhhc0luc3RhbmNlOiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gIFN5bWJvbEl0ZXJhdG9yOiBTeW1ib2wuaXRlcmF0b3IsXG4gIFN5bWJvbERpc3Bvc2U6IFN5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmRpc3Bvc2UnKSxcbiAgU3ltYm9sQXN5bmNEaXNwb3NlOiBTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmFzeW5jRGlzcG9zZScpLFxuICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHNlbGYsIGJ1ZiwgbGVuKSB7XG4gICAgcmV0dXJuIHNlbGYuc2V0KGJ1ZiwgbGVuKVxuICB9LFxuICBCb29sZWFuOiBCb29sZWFuLFxuICBVaW50OEFycmF5XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js":
/*!************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\")\nconst { kResistStopPropagation, SymbolDispose } = __webpack_require__(/*! ./primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst AbortSignal = globalThis.AbortSignal || (__webpack_require__(/*! abort-controller */ \"(rsc)/../node_modules/abort-controller/dist/abort-controller.js\").AbortSignal)\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(rsc)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController)\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\nconst Blob = globalThis.Blob || bufferModule.Blob\n/* eslint-disable indent */\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        // eslint-disable-next-line indent\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n}\n\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n  constructor(errors) {\n    if (!Array.isArray(errors)) {\n      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)\n    }\n    let message = ''\n    for (let i = 0; i < errors.length; i++) {\n      message += `    ${errors[i].stack}\\n`\n    }\n    super(message)\n    this.name = 'AggregateError'\n    this.errors = errors\n  }\n}\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false\n    return function (...args) {\n      if (called) {\n        return\n      }\n      called = true\n      callback.apply(this, args)\n    }\n  },\n  createDeferredPromise: function () {\n    let resolve\n    let reject\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n    return {\n      promise,\n      resolve,\n      reject\n    }\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(...args)\n      })\n    })\n  },\n  debuglog() {\n    return function () {}\n  },\n  format(format, ...args) {\n    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n      const replacement = args.shift()\n      if (type === 'f') {\n        return replacement.toFixed(6)\n      } else if (type === 'j') {\n        return JSON.stringify(replacement)\n      } else if (type === 's' && typeof replacement === 'object') {\n        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''\n        return `${ctor} {}`.trim()\n      } else {\n        return replacement.toString()\n      }\n    })\n  },\n  inspect(value) {\n    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n    switch (typeof value) {\n      case 'string':\n        if (value.includes(\"'\")) {\n          if (!value.includes('\"')) {\n            return `\"${value}\"`\n          } else if (!value.includes('`') && !value.includes('${')) {\n            return `\\`${value}\\``\n          }\n        }\n        return `'${value}'`\n      case 'number':\n        if (isNaN(value)) {\n          return 'NaN'\n        } else if (Object.is(value, -0)) {\n          return String(value)\n        }\n        return value\n      case 'bigint':\n        return `${String(value)}n`\n      case 'boolean':\n      case 'undefined':\n        return String(value)\n      case 'object':\n        return '{}'\n    }\n  },\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr)\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn\n  },\n  addAbortListener:\n    (__webpack_require__(/*! events */ \"events\").addAbortListener) ||\n    function addAbortListener(signal, listener) {\n      if (signal === undefined) {\n        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)\n      }\n      validateAbortSignal(signal, 'signal')\n      validateFunction(listener, 'listener')\n      let removeEventListener\n      if (signal.aborted) {\n        queueMicrotask(() => listener())\n      } else {\n        signal.addEventListener('abort', listener, {\n          __proto__: null,\n          once: true,\n          [kResistStopPropagation]: true\n        })\n        removeEventListener = () => {\n          signal.removeEventListener('abort', listener)\n        }\n      }\n      return {\n        __proto__: null,\n        [SymbolDispose]() {\n          var _removeEventListener\n          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined\n            ? undefined\n            : _removeEventListener()\n        }\n      }\n    },\n  AbortSignalAny:\n    AbortSignal.any ||\n    function AbortSignalAny(signals) {\n      // Fast path if there is only one signal.\n      if (signals.length === 1) {\n        return signals[0]\n      }\n      const ac = new AbortController()\n      const abort = () => ac.abort()\n      signals.forEach((signal) => {\n        validateAbortSignal(signal, 'signals')\n        signal.addEventListener('abort', abort, {\n          once: true\n        })\n      })\n      ac.signal.addEventListener(\n        'abort',\n        () => {\n          signals.forEach((signal) => signal.removeEventListener('abort', abort))\n        },\n        {\n          once: true\n        }\n      )\n      return ac.signal\n    }\n}\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxRQUFRLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMsZ0hBQWU7QUFDekUsOENBQThDLDRIQUF1QztBQUNyRixzREFBc0QsZ0lBQTJDO0FBQ2pHLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QixZQUFZLG9EQUFvRDtBQUNoRSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLDhEQUFrQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBidWZmZXJNb2R1bGUgPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBrUmVzaXN0U3RvcFByb3BhZ2F0aW9uLCBTeW1ib2xEaXNwb3NlIH0gPSByZXF1aXJlKCcuL3ByaW1vcmRpYWxzJylcbmNvbnN0IEFib3J0U2lnbmFsID0gZ2xvYmFsVGhpcy5BYm9ydFNpZ25hbCB8fCByZXF1aXJlKCdhYm9ydC1jb250cm9sbGVyJykuQWJvcnRTaWduYWxcbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24gKCkge30pLmNvbnN0cnVjdG9yXG5jb25zdCBCbG9iID0gZ2xvYmFsVGhpcy5CbG9iIHx8IGJ1ZmZlck1vZHVsZS5CbG9iXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbmNvbnN0IGlzQmxvYiA9XG4gIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGluZGVudFxuICAgICAgICByZXR1cm4gYiBpbnN0YW5jZW9mIEJsb2JcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uIGlzQmxvYihiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuLyogZXNsaW50LWVuYWJsZSBpbmRlbnQgKi9cblxuY29uc3QgdmFsaWRhdGVBYm9ydFNpZ25hbCA9IChzaWduYWwsIG5hbWUpID0+IHtcbiAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIChzaWduYWwgPT09IG51bGwgfHwgdHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Fib3J0U2lnbmFsJywgc2lnbmFsKVxuICB9XG59XG5jb25zdCB2YWxpZGF0ZUZ1bmN0aW9uID0gKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnRnVuY3Rpb24nLCB2YWx1ZSlcbn1cblxuLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBBZ2dyZWdhdGVFcnJvclxuY2xhc3MgQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0byBiZSBhbiBBcnJheSwgZ290ICR7dHlwZW9mIGVycm9yc31gKVxuICAgIH1cbiAgICBsZXQgbWVzc2FnZSA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCAgICAke2Vycm9yc1tpXS5zdGFja31cXG5gXG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0FnZ3JlZ2F0ZUVycm9yJ1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBZ2dyZWdhdGVFcnJvcixcbiAga0VtcHR5T2JqZWN0OiBPYmplY3QuZnJlZXplKHt9KSxcbiAgb25jZShjYWxsYmFjaykge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfVxuICB9LFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzb2x2ZVxuICAgIGxldCByZWplY3RcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3BhcmFtLW5hbWVzXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlc1xuICAgICAgcmVqZWN0ID0gcmVqXG4gICAgfSlcbiAgICByZXR1cm4ge1xuICAgICAgcHJvbWlzZSxcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3RcbiAgICB9XG4gIH0sXG4gIHByb21pc2lmeShmbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmbigoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSguLi5hcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBkZWJ1Z2xvZygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge31cbiAgfSxcbiAgZm9ybWF0KGZvcm1hdCwgLi4uYXJncykge1xuICAgIC8vIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsZm9ybWF0Zm9ybWF0LWFyZ3NcbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyUoW3NkaWZqXSkvZywgZnVuY3Rpb24gKC4uLltfdW51c2VkLCB0eXBlXSkge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBhcmdzLnNoaWZ0KClcbiAgICAgIGlmICh0eXBlID09PSAnZicpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50LnRvRml4ZWQoNilcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2onKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXBsYWNlbWVudClcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3MnICYmIHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgY3RvciA9IHJlcGxhY2VtZW50LmNvbnN0cnVjdG9yICE9PSBPYmplY3QgPyByZXBsYWNlbWVudC5jb25zdHJ1Y3Rvci5uYW1lIDogJydcbiAgICAgICAgcmV0dXJuIGAke2N0b3J9IHt9YC50cmltKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudC50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgaW5zcGVjdCh2YWx1ZSkge1xuICAgIC8vIFZhc3RseSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjdXRpbGluc3BlY3RvYmplY3Qtb3B0aW9uc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCInXCIpKSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnXCInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgXG4gICAgICAgICAgfSBlbHNlIGlmICghdmFsdWUuaW5jbHVkZXMoJ2AnKSAmJiAhdmFsdWUuaW5jbHVkZXMoJyR7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHt2YWx1ZX1cXGBgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9J2BcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJ05hTidcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuaXModmFsdWUsIC0wKSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICByZXR1cm4gYCR7U3RyaW5nKHZhbHVlKX1uYFxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICd7fSdcbiAgICB9XG4gIH0sXG4gIHR5cGVzOiB7XG4gICAgaXNBc3luY0Z1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gZm4gaW5zdGFuY2VvZiBBc3luY0Z1bmN0aW9uXG4gICAgfSxcbiAgICBpc0FycmF5QnVmZmVyVmlldyhhcnIpIHtcbiAgICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyKVxuICAgIH1cbiAgfSxcbiAgaXNCbG9iLFxuICBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZm5cbiAgfSxcbiAgYWRkQWJvcnRMaXN0ZW5lcjpcbiAgICByZXF1aXJlKCdldmVudHMnKS5hZGRBYm9ydExpc3RlbmVyIHx8XG4gICAgZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAoc2lnbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdzaWduYWwnLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCwgJ3NpZ25hbCcpXG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uKGxpc3RlbmVyLCAnbGlzdGVuZXInKVxuICAgICAgbGV0IHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBsaXN0ZW5lcigpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHtcbiAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICBba1Jlc2lzdFN0b3BQcm9wYWdhdGlvbl06IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbU3ltYm9sRGlzcG9zZV0oKSB7XG4gICAgICAgICAgdmFyIF9yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICAgICAgOyhfcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXIpID09PSBudWxsIHx8IF9yZW1vdmVFdmVudExpc3RlbmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IF9yZW1vdmVFdmVudExpc3RlbmVyKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIEFib3J0U2lnbmFsQW55OlxuICAgIEFib3J0U2lnbmFsLmFueSB8fFxuICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsQW55KHNpZ25hbHMpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzaWduYWwuXG4gICAgICBpZiAoc2lnbmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hbHNbMF1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICBjb25zdCBhYm9ydCA9ICgpID0+IGFjLmFib3J0KClcbiAgICAgIHNpZ25hbHMuZm9yRWFjaCgoc2lnbmFsKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlQWJvcnRTaWduYWwoc2lnbmFsLCAnc2lnbmFscycpXG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0LCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnYWJvcnQnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIGFjLnNpZ25hbFxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5wcm9taXNpZnkuY3VzdG9tJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/stream.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = __webpack_require__(/*! ./ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst {\n  promisify: { custom: customPromisify }\n} = __webpack_require__(/*! ./ours/util */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/util.js\")\nconst { streamReturningOperators, promiseReturningOperators } = __webpack_require__(/*! ./internal/streams/operators */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/operators.js\")\nconst {\n  codes: { ERR_ILLEGAL_CONSTRUCTOR }\n} = __webpack_require__(/*! ./ours/errors */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/errors.js\")\nconst compose = __webpack_require__(/*! ./internal/streams/compose */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/compose.js\")\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./internal/streams/state */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/state.js\")\nconst { pipeline } = __webpack_require__(/*! ./internal/streams/pipeline */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst { destroyer } = __webpack_require__(/*! ./internal/streams/destroy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js\")\nconst eos = __webpack_require__(/*! ./internal/streams/end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nconst internalBuffer = {}\nconst promises = __webpack_require__(/*! ./stream/promises */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream/promises.js\")\nconst utils = __webpack_require__(/*! ./internal/streams/utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst Stream = (module.exports = __webpack_require__(/*! ./internal/streams/legacy */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream)\nStream.isDestroyed = utils.isDestroyed\nStream.isDisturbed = utils.isDisturbed\nStream.isErrored = utils.isErrored\nStream.isReadable = utils.isReadable\nStream.isWritable = utils.isWritable\nStream.Readable = __webpack_require__(/*! ./internal/streams/readable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/readable.js\")\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return Stream.Readable.from(ReflectApply(op, this, args))\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return ReflectApply(op, this, args)\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nStream.Writable = __webpack_require__(/*! ./internal/streams/writable */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/writable.js\")\nStream.Duplex = __webpack_require__(/*! ./internal/streams/duplex */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/duplex.js\")\nStream.Transform = __webpack_require__(/*! ./internal/streams/transform */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/transform.js\")\nStream.PassThrough = __webpack_require__(/*! ./internal/streams/passthrough */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/passthrough.js\")\nStream.pipeline = pipeline\nconst { addAbortSignal } = __webpack_require__(/*! ./internal/streams/add-abort-signal */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\")\nStream.addAbortSignal = addAbortSignal\nStream.finished = eos\nStream.destroy = destroyer\nStream.compose = compose\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark\nObjectDefineProperty(Stream, 'promises', {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nObjectDefineProperty(pipeline, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.pipeline\n  }\n})\nObjectDefineProperty(eos, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.finished\n  }\n})\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream\nStream._isUint8Array = function isUint8Array(value) {\n  return value instanceof Uint8Array\n}\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQVEsaURBQWlELEVBQUUsbUJBQU8sQ0FBQyxxSEFBb0I7QUFDdkY7QUFDQSxlQUFlO0FBQ2YsRUFBRSxFQUFFLG1CQUFPLENBQUMsdUdBQWE7QUFDekIsUUFBUSxzREFBc0QsRUFBRSxtQkFBTyxDQUFDLHlJQUE4QjtBQUN0RztBQUNBLFdBQVc7QUFDWCxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyR0FBZTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyxxSUFBNEI7QUFDcEQsUUFBUSxtREFBbUQsRUFBRSxtQkFBTyxDQUFDLGlJQUEwQjtBQUMvRixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHVJQUE2QjtBQUMxRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHFJQUE0QjtBQUMxRCxZQUFZLG1CQUFPLENBQUMsaUpBQWtDO0FBQ3REO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsbUhBQW1CO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxpSUFBMEI7QUFDaEQsZ0JBQWdCLGdMQUE0RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUlBQTZCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVJQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtSUFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMseUlBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLDZJQUFnQztBQUM3RDtBQUNBLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyx1SkFBcUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3QgeyBPYmplY3REZWZpbmVQcm9wZXJ0eSwgT2JqZWN0S2V5cywgUmVmbGVjdEFwcGx5IH0gPSByZXF1aXJlKCcuL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qge1xuICBwcm9taXNpZnk6IHsgY3VzdG9tOiBjdXN0b21Qcm9taXNpZnkgfVxufSA9IHJlcXVpcmUoJy4vb3Vycy91dGlsJylcbmNvbnN0IHsgc3RyZWFtUmV0dXJuaW5nT3BlcmF0b3JzLCBwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvb3BlcmF0b3JzJylcbmNvbnN0IHtcbiAgY29kZXM6IHsgRVJSX0lMTEVHQUxfQ09OU1RSVUNUT1IgfVxufSA9IHJlcXVpcmUoJy4vb3Vycy9lcnJvcnMnKVxuY29uc3QgY29tcG9zZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9jb21wb3NlJylcbmNvbnN0IHsgc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmssIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKVxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lJylcbmNvbnN0IHsgZGVzdHJveWVyIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbScpXG5jb25zdCBpbnRlcm5hbEJ1ZmZlciA9IHt9XG5jb25zdCBwcm9taXNlcyA9IHJlcXVpcmUoJy4vc3RyZWFtL3Byb21pc2VzJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3V0aWxzJylcbmNvbnN0IFN0cmVhbSA9IChtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9sZWdhY3knKS5TdHJlYW0pXG5TdHJlYW0uaXNEZXN0cm95ZWQgPSB1dGlscy5pc0Rlc3Ryb3llZFxuU3RyZWFtLmlzRGlzdHVyYmVkID0gdXRpbHMuaXNEaXN0dXJiZWRcblN0cmVhbS5pc0Vycm9yZWQgPSB1dGlscy5pc0Vycm9yZWRcblN0cmVhbS5pc1JlYWRhYmxlID0gdXRpbHMuaXNSZWFkYWJsZVxuU3RyZWFtLmlzV3JpdGFibGUgPSB1dGlscy5pc1dyaXRhYmxlXG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvcmVhZGFibGUnKVxuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0S2V5cyhzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMpKSB7XG4gIGNvbnN0IG9wID0gc3RyZWFtUmV0dXJuaW5nT3BlcmF0b3JzW2tleV1cbiAgZnVuY3Rpb24gZm4oLi4uYXJncykge1xuICAgIGlmIChuZXcudGFyZ2V0KSB7XG4gICAgICB0aHJvdyBFUlJfSUxMRUdBTF9DT05TVFJVQ1RPUigpXG4gICAgfVxuICAgIHJldHVybiBTdHJlYW0uUmVhZGFibGUuZnJvbShSZWZsZWN0QXBwbHkob3AsIHRoaXMsIGFyZ3MpKVxuICB9XG4gIE9iamVjdERlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IG9wLm5hbWVcbiAgfSlcbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICdsZW5ndGgnLCB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHZhbHVlOiBvcC5sZW5ndGhcbiAgfSlcbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoU3RyZWFtLlJlYWRhYmxlLnByb3RvdHlwZSwga2V5LCB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHZhbHVlOiBmbixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSlcbn1cbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdEtleXMocHJvbWlzZVJldHVybmluZ09wZXJhdG9ycykpIHtcbiAgY29uc3Qgb3AgPSBwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzW2tleV1cbiAgZnVuY3Rpb24gZm4oLi4uYXJncykge1xuICAgIGlmIChuZXcudGFyZ2V0KSB7XG4gICAgICB0aHJvdyBFUlJfSUxMRUdBTF9DT05TVFJVQ1RPUigpXG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0QXBwbHkob3AsIHRoaXMsIGFyZ3MpXG4gIH1cbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubmFtZVxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IG9wLmxlbmd0aFxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlLCBrZXksIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IGZuLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KVxufVxuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3dyaXRhYmxlJylcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZHVwbGV4JylcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvdHJhbnNmb3JtJylcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9wYXNzdGhyb3VnaCcpXG5TdHJlYW0ucGlwZWxpbmUgPSBwaXBlbGluZVxuY29uc3QgeyBhZGRBYm9ydFNpZ25hbCB9ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FkZC1hYm9ydC1zaWduYWwnKVxuU3RyZWFtLmFkZEFib3J0U2lnbmFsID0gYWRkQWJvcnRTaWduYWxcblN0cmVhbS5maW5pc2hlZCA9IGVvc1xuU3RyZWFtLmRlc3Ryb3kgPSBkZXN0cm95ZXJcblN0cmVhbS5jb21wb3NlID0gY29tcG9zZVxuU3RyZWFtLnNldERlZmF1bHRIaWdoV2F0ZXJNYXJrID0gc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmtcblN0cmVhbS5nZXREZWZhdWx0SGlnaFdhdGVyTWFyayA9IGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrXG5PYmplY3REZWZpbmVQcm9wZXJ0eShTdHJlYW0sICdwcm9taXNlcycsIHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcHJvbWlzZXNcbiAgfVxufSlcbk9iamVjdERlZmluZVByb3BlcnR5KHBpcGVsaW5lLCBjdXN0b21Qcm9taXNpZnksIHtcbiAgX19wcm90b19fOiBudWxsLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHByb21pc2VzLnBpcGVsaW5lXG4gIH1cbn0pXG5PYmplY3REZWZpbmVQcm9wZXJ0eShlb3MsIGN1c3RvbVByb21pc2lmeSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcHJvbWlzZXMuZmluaXNoZWRcbiAgfVxufSlcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW1cblN0cmVhbS5faXNVaW50OEFycmF5ID0gZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbn1cblN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyID0gZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream/promises.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/readable-stream/lib/stream/promises.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { ArrayPrototypePop, Promise } = __webpack_require__(/*! ../ours/primordials */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/ours/primordials.js\")\nconst { isIterable, isNodeStream, isWebStream } = __webpack_require__(/*! ../internal/streams/utils */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/utils.js\")\nconst { pipelineImpl: pl } = __webpack_require__(/*! ../internal/streams/pipeline */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js\")\nconst { finished } = __webpack_require__(/*! ../internal/streams/end-of-stream */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\n__webpack_require__(/*! ../../lib/stream.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream.js\")\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal\n    let end\n    const lastArg = streams[streams.length - 1]\n    if (\n      lastArg &&\n      typeof lastArg === 'object' &&\n      !isNodeStream(lastArg) &&\n      !isIterable(lastArg) &&\n      !isWebStream(lastArg)\n    ) {\n      const options = ArrayPrototypePop(streams)\n      signal = options.signal\n      end = options.end\n    }\n    pl(\n      streams,\n      (err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      },\n      {\n        signal,\n        end\n      }\n    )\n  })\n}\nmodule.exports = {\n  finished,\n  pipeline\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL3N0cmVhbS9wcm9taXNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDZCQUE2QixFQUFFLG1CQUFPLENBQUMsc0hBQXFCO0FBQ3BFLFFBQVEsd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyxrSUFBMkI7QUFDckYsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHdJQUE4QjtBQUNuRSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLGtKQUFtQztBQUNoRSxtQkFBTyxDQUFDLDRHQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvc3RyZWFtL3Byb21pc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEFycmF5UHJvdG90eXBlUG9wLCBQcm9taXNlIH0gPSByZXF1aXJlKCcuLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgaXNJdGVyYWJsZSwgaXNOb2RlU3RyZWFtLCBpc1dlYlN0cmVhbSB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy91dGlscycpXG5jb25zdCB7IHBpcGVsaW5lSW1wbDogcGwgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUnKVxuY29uc3QgeyBmaW5pc2hlZCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtJylcbnJlcXVpcmUoJy4uLy4uL2xpYi9zdHJlYW0uanMnKVxuZnVuY3Rpb24gcGlwZWxpbmUoLi4uc3RyZWFtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBzaWduYWxcbiAgICBsZXQgZW5kXG4gICAgY29uc3QgbGFzdEFyZyA9IHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXVxuICAgIGlmIChcbiAgICAgIGxhc3RBcmcgJiZcbiAgICAgIHR5cGVvZiBsYXN0QXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgIWlzTm9kZVN0cmVhbShsYXN0QXJnKSAmJlxuICAgICAgIWlzSXRlcmFibGUobGFzdEFyZykgJiZcbiAgICAgICFpc1dlYlN0cmVhbShsYXN0QXJnKVxuICAgICkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IEFycmF5UHJvdG90eXBlUG9wKHN0cmVhbXMpXG4gICAgICBzaWduYWwgPSBvcHRpb25zLnNpZ25hbFxuICAgICAgZW5kID0gb3B0aW9ucy5lbmRcbiAgICB9XG4gICAgcGwoXG4gICAgICBzdHJlYW1zLFxuICAgICAgKGVyciwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICApXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluaXNoZWQsXG4gIHBpcGVsaW5lXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/readable-stream/lib/stream/promises.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/glob.js":
/*!******************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/glob.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Glob = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst path_scurry_1 = __webpack_require__(/*! path-scurry */ \"(rsc)/../node_modules/path-scurry/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/pattern.js\");\nconst walker_js_1 = __webpack_require__(/*! ./walker.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/walker.js\");\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nclass Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? path_scurry_1.PathScurryWin32\n                : opts.platform === 'darwin' ? path_scurry_1.PathScurryDarwin\n                    : opts.platform ? path_scurry_1.PathScurryPosix\n                        : path_scurry_1.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new minimatch_1.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new pattern_js_1.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvZ2xvYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osb0JBQW9CLG1CQUFPLENBQUMscUdBQVc7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsMEJBQVU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsNkVBQWE7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMscUdBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2dsb2IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdsb2IgPSB2b2lkIDA7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG5jb25zdCBub2RlX3VybF8xID0gcmVxdWlyZShcIm5vZGU6dXJsXCIpO1xuY29uc3QgcGF0aF9zY3VycnlfMSA9IHJlcXVpcmUoXCJwYXRoLXNjdXJyeVwiKTtcbmNvbnN0IHBhdHRlcm5fanNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm4uanNcIik7XG5jb25zdCB3YWxrZXJfanNfMSA9IHJlcXVpcmUoXCIuL3dhbGtlci5qc1wiKTtcbi8vIGlmIG5vIHByb2Nlc3MgZ2xvYmFsLCBqdXN0IGNhbGwgaXQgbGludXguXG4vLyBzbyB3ZSBkZWZhdWx0IHRvIGNhc2Utc2Vuc2l0aXZlLCAvIHNlcGFyYXRvcnNcbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucGxhdGZvcm0gPT09ICdzdHJpbmcnKSA/XG4gICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ2xpbnV4Jztcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHBlcmZvcm0gZ2xvYiBwYXR0ZXJuIHRyYXZlcnNhbHMuXG4gKi9cbmNsYXNzIEdsb2Ige1xuICAgIGFic29sdXRlO1xuICAgIGN3ZDtcbiAgICByb290O1xuICAgIGRvdDtcbiAgICBkb3RSZWxhdGl2ZTtcbiAgICBmb2xsb3c7XG4gICAgaWdub3JlO1xuICAgIG1hZ2ljYWxCcmFjZXM7XG4gICAgbWFyaztcbiAgICBtYXRjaEJhc2U7XG4gICAgbWF4RGVwdGg7XG4gICAgbm9icmFjZTtcbiAgICBub2Nhc2U7XG4gICAgbm9kaXI7XG4gICAgbm9leHQ7XG4gICAgbm9nbG9ic3RhcjtcbiAgICBwYXR0ZXJuO1xuICAgIHBsYXRmb3JtO1xuICAgIHJlYWxwYXRoO1xuICAgIHNjdXJyeTtcbiAgICBzdGF0O1xuICAgIHNpZ25hbDtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICB3aXRoRmlsZVR5cGVzO1xuICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIG9wdHM7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcGFyc2VkIGltbXV0YWJsZSB7QGxpbmsgUGF0dGVybn0gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBwYXR0ZXJucztcbiAgICAvKipcbiAgICAgKiBBbGwgb3B0aW9ucyBhcmUgc3RvcmVkIGFzIHByb3BlcnRpZXMgb24gdGhlIGBHbG9iYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIEdsb2JPcHRpb25zfSBmb3IgZnVsbCBvcHRpb25zIGRlc2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhIHByZXZpb3VzIGBHbG9iYCBvYmplY3QgY2FuIGJlIHBhc3NlZCBhcyB0aGVcbiAgICAgKiBgR2xvYk9wdGlvbnNgIHRvIGFub3RoZXIgYEdsb2JgIGluc3RhbnRpYXRpb24gdG8gcmUtdXNlIHNldHRpbmdzXG4gICAgICogYW5kIGNhY2hlcyB3aXRoIGEgbmV3IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUcmF2ZXJzYWwgZnVuY3Rpb25zIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcnVuIHRoZSB3YWxrXG4gICAgICogYWdhaW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0cykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2xvYiBvcHRpb25zIHJlcXVpcmVkJyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2l0aEZpbGVUeXBlcyA9ICEhb3B0cy53aXRoRmlsZVR5cGVzO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0cy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZG90ID0gISFvcHRzLmRvdDtcbiAgICAgICAgdGhpcy5kb3RSZWxhdGl2ZSA9ICEhb3B0cy5kb3RSZWxhdGl2ZTtcbiAgICAgICAgdGhpcy5ub2RpciA9ICEhb3B0cy5ub2RpcjtcbiAgICAgICAgdGhpcy5tYXJrID0gISFvcHRzLm1hcms7XG4gICAgICAgIGlmICghb3B0cy5jd2QpIHtcbiAgICAgICAgICAgIHRoaXMuY3dkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5jd2QgaW5zdGFuY2VvZiBVUkwgfHwgb3B0cy5jd2Quc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XG4gICAgICAgICAgICBvcHRzLmN3ZCA9ICgwLCBub2RlX3VybF8xLmZpbGVVUkxUb1BhdGgpKG9wdHMuY3dkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN3ZCA9IG9wdHMuY3dkIHx8ICcnO1xuICAgICAgICB0aGlzLnJvb3QgPSBvcHRzLnJvb3Q7XG4gICAgICAgIHRoaXMubWFnaWNhbEJyYWNlcyA9ICEhb3B0cy5tYWdpY2FsQnJhY2VzO1xuICAgICAgICB0aGlzLm5vYnJhY2UgPSAhIW9wdHMubm9icmFjZTtcbiAgICAgICAgdGhpcy5ub2V4dCA9ICEhb3B0cy5ub2V4dDtcbiAgICAgICAgdGhpcy5yZWFscGF0aCA9ICEhb3B0cy5yZWFscGF0aDtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IG9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyA9IG9wdHMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9nbG9ic3RhciA9ICEhb3B0cy5ub2dsb2JzdGFyO1xuICAgICAgICB0aGlzLm1hdGNoQmFzZSA9ICEhb3B0cy5tYXRjaEJhc2U7XG4gICAgICAgIHRoaXMubWF4RGVwdGggPVxuICAgICAgICAgICAgdHlwZW9mIG9wdHMubWF4RGVwdGggPT09ICdudW1iZXInID8gb3B0cy5tYXhEZXB0aCA6IEluZmluaXR5O1xuICAgICAgICB0aGlzLnN0YXQgPSAhIW9wdHMuc3RhdDtcbiAgICAgICAgdGhpcy5pZ25vcmUgPSBvcHRzLmlnbm9yZTtcbiAgICAgICAgaWYgKHRoaXMud2l0aEZpbGVUeXBlcyAmJiB0aGlzLmFic29sdXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBhYnNvbHV0ZSBhbmQgd2l0aEZpbGVUeXBlczp0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybiA9IFtwYXR0ZXJuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlID1cbiAgICAgICAgICAgICEhb3B0cy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fFxuICAgICAgICAgICAgICAgIG9wdHMuYWxsb3dXaW5kb3dzRXNjYXBlID09PVxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLm1hcChwID0+IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaEJhc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXNlIG1hdGNoaW5nIHJlcXVpcmVzIGdsb2JzdGFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5tYXAocCA9PiAocC5pbmNsdWRlcygnLycpID8gcCA6IGAuLyoqLyR7cH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdHMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtIH07XG4gICAgICAgIGlmIChvcHRzLnNjdXJyeSkge1xuICAgICAgICAgICAgdGhpcy5zY3VycnkgPSBvcHRzLnNjdXJyeTtcbiAgICAgICAgICAgIGlmIChvcHRzLm5vY2FzZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb3B0cy5ub2Nhc2UgIT09IG9wdHMuc2N1cnJ5Lm5vY2FzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9jYXNlIG9wdGlvbiBjb250cmFkaWN0cyBwcm92aWRlZCBzY3Vycnkgb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBTY3VycnkgPSBvcHRzLnBsYXRmb3JtID09PSAnd2luMzInID8gcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5V2luMzJcbiAgICAgICAgICAgICAgICA6IG9wdHMucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5RGFyd2luXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5wbGF0Zm9ybSA/IHBhdGhfc2N1cnJ5XzEuUGF0aFNjdXJyeVBvc2l4XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhdGhfc2N1cnJ5XzEuUGF0aFNjdXJyeTtcbiAgICAgICAgICAgIHRoaXMuc2N1cnJ5ID0gbmV3IFNjdXJyeSh0aGlzLmN3ZCwge1xuICAgICAgICAgICAgICAgIG5vY2FzZTogb3B0cy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgZnM6IG9wdHMuZnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vY2FzZSA9IHRoaXMuc2N1cnJ5Lm5vY2FzZTtcbiAgICAgICAgLy8gSWYgeW91IGRvIG5vY2FzZTp0cnVlIG9uIGEgY2FzZS1zZW5zaXRpdmUgZmlsZSBzeXN0ZW0sIHRoZW5cbiAgICAgICAgLy8gd2UgbmVlZCB0byB1c2UgcmVnZXhwcyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yIG5vbi1tYWdpY1xuICAgICAgICAvLyBwYXRoIHBvcnRpb25zLCBiZWNhdXNlIHN0YXR0aW5nIGBhQmNgIHdvbid0IHJldHVybiByZXN1bHRzXG4gICAgICAgIC8vIGZvciB0aGUgZmlsZSBgQWJDYCBmb3IgZXhhbXBsZS5cbiAgICAgICAgY29uc3Qgbm9jYXNlTWFnaWNPbmx5ID0gdGhpcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHwgdGhpcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgY29uc3QgbW1vID0ge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBub2Nhc2UgYmFzZWQgb24gcGxhdGZvcm1cbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBkb3Q6IHRoaXMuZG90LFxuICAgICAgICAgICAgbWF0Y2hCYXNlOiB0aGlzLm1hdGNoQmFzZSxcbiAgICAgICAgICAgIG5vYnJhY2U6IHRoaXMubm9icmFjZSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBub2Nhc2VNYWdpY09ubHksXG4gICAgICAgICAgICBub2NvbW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBub2V4dDogdGhpcy5ub2V4dCxcbiAgICAgICAgICAgIG5vbmVnYXRlOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pemF0aW9uTGV2ZWw6IDIsXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlOiB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlLFxuICAgICAgICAgICAgZGVidWc6ICEhdGhpcy5vcHRzLmRlYnVnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtbXMgPSB0aGlzLnBhdHRlcm4ubWFwKHAgPT4gbmV3IG1pbmltYXRjaF8xLk1pbmltYXRjaChwLCBtbW8pKTtcbiAgICAgICAgY29uc3QgW21hdGNoU2V0LCBnbG9iUGFydHNdID0gbW1zLnJlZHVjZSgoc2V0LCBtKSA9PiB7XG4gICAgICAgICAgICBzZXRbMF0ucHVzaCguLi5tLnNldCk7XG4gICAgICAgICAgICBzZXRbMV0ucHVzaCguLi5tLmdsb2JQYXJ0cyk7XG4gICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICB9LCBbW10sIFtdXSk7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBtYXRjaFNldC5tYXAoKHNldCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZyA9IGdsb2JQYXJ0c1tpXTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKCFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXR0ZXJuIG9iamVjdCcpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHJldHVybiBuZXcgcGF0dGVybl9qc18xLlBhdHRlcm4oc2V0LCBnLCAwLCB0aGlzLnBsYXRmb3JtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoKSB7XG4gICAgICAgIC8vIFdhbGtlcnMgYWx3YXlzIHJldHVybiBhcnJheSBvZiBQYXRoIG9iamVjdHMsIHNvIHdlIGp1c3QgaGF2ZSB0b1xuICAgICAgICAvLyBjb2VyY2UgdGhlbSBpbnRvIHRoZSByaWdodCBzaGFwZS4gIEl0IHdpbGwgaGF2ZSBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAvLyByZWFscGF0aCgpIGlmIHRoZSBvcHRpb24gd2FzIHNldCB0byBkbyBzbywgc28gd2Uga25vdyB0aGF0J3MgY2FjaGVkLlxuICAgICAgICAvLyBzdGFydCBvdXQga25vd2luZyB0aGUgY3dkLCBhdCBsZWFzdFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uKGF3YWl0IG5ldyB3YWxrZXJfanNfMS5HbG9iV2Fsa2VyKHRoaXMucGF0dGVybnMsIHRoaXMuc2N1cnJ5LmN3ZCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heERlcHRoICsgdGhpcy5zY3VycnkuY3dkLmRlcHRoKClcbiAgICAgICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgICAgIH0pLndhbGsoKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHdhbGtTeW5jKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4ubmV3IHdhbGtlcl9qc18xLkdsb2JXYWxrZXIodGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICAgICAgfSkud2Fsa1N5bmMoKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gbmV3IHdhbGtlcl9qc18xLkdsb2JTdHJlYW0odGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgIH0pLnN0cmVhbSgpO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKCkge1xuICAgICAgICByZXR1cm4gbmV3IHdhbGtlcl9qc18xLkdsb2JTdHJlYW0odGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgIH0pLnN0cmVhbVN5bmMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzeW5jIGl0ZXJhdGlvbiBmdW5jdGlvbi4gUmV0dXJucyBhIEdlbmVyYXRvciB0aGF0XG4gICAgICogaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBpdGVyYXRlU3luYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtU3luYygpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVTeW5jKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYXN5bmMgaXRlcmF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGFuIEFzeW5jR2VuZXJhdG9yIHRoYXRcbiAgICAgKiBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGl0ZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbSgpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5HbG9iID0gR2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/glob.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/has-magic.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/has-magic.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasMagic = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nconst hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new minimatch_1.Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\nexports.hasMagic = hasMagic;\n//# sourceMappingURL=has-magic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaGFzLW1hZ2ljLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy9oYXMtbWFnaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc01hZ2ljID0gdm9pZCAwO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGF0dGVybnMgcHJvdmlkZWQgY29udGFpbiBhbnkgbWFnaWMgZ2xvYiBjaGFyYWN0ZXJzLFxuICogZ2l2ZW4gdGhlIG9wdGlvbnMgcHJvdmlkZWQuXG4gKlxuICogQnJhY2UgZXhwYW5zaW9uIGlzIG5vdCBjb25zaWRlcmVkIFwibWFnaWNcIiB1bmxlc3MgdGhlIGBtYWdpY2FsQnJhY2VzYCBvcHRpb25cbiAqIGlzIHNldCwgYXMgYnJhY2UgZXhwYW5zaW9uIGp1c3QgdHVybnMgb25lIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBTbyBhIHBhdHRlcm4gbGlrZSBgJ3h7YSxifXknYCB3b3VsZCByZXR1cm4gYGZhbHNlYCwgYmVjYXVzZSBgJ3hheSdgIGFuZFxuICogYCd4YnknYCBib3RoIGRvIG5vdCBjb250YWluIGFueSBtYWdpYyBnbG9iIGNoYXJhY3RlcnMsIGFuZCBpdCdzIHRyZWF0ZWQgdGhlXG4gKiBzYW1lIGFzIGlmIHlvdSBoYWQgY2FsbGVkIGl0IG9uIGBbJ3hheScsICd4YnknXWAuIFdoZW4gYG1hZ2ljYWxCcmFjZXM6dHJ1ZWBcbiAqIGlzIGluIHRoZSBvcHRpb25zLCBicmFjZSBleHBhbnNpb24gX2lzXyB0cmVhdGVkIGFzIGEgcGF0dGVybiBoYXZpbmcgbWFnaWMuXG4gKi9cbmNvbnN0IGhhc01hZ2ljID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0dGVybikge1xuICAgICAgICBpZiAobmV3IG1pbmltYXRjaF8xLk1pbmltYXRjaChwLCBvcHRpb25zKS5oYXNNYWdpYygpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLmhhc01hZ2ljID0gaGFzTWFnaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtbWFnaWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/has-magic.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/ignore.js":
/*!********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/ignore.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Ignore = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/pattern.js\");\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch_1.Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\nexports.Ignore = Ignore;\n//# sourceMappingURL=ignore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaWdub3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLHFHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBaUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaWdub3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gZ2l2ZSBpdCBhIHBhdHRlcm4sIGFuZCBpdCdsbCBiZSBhYmxlIHRvIHRlbGwgeW91IGlmXG4vLyBhIGdpdmVuIHBhdGggc2hvdWxkIGJlIGlnbm9yZWQuXG4vLyBJZ25vcmluZyBhIHBhdGggaWdub3JlcyBpdHMgY2hpbGRyZW4gaWYgdGhlIHBhdHRlcm4gZW5kcyBpbiAvKipcbi8vIElnbm9yZXMgYXJlIGFsd2F5cyBwYXJzZWQgaW4gZG90OnRydWUgbW9kZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZ25vcmUgPSB2b2lkIDA7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG5jb25zdCBwYXR0ZXJuX2pzXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuLmpzXCIpO1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3N0cmluZycpID9cbiAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAnbGludXgnO1xuLyoqXG4gKiBDbGFzcyB1c2VkIHRvIHByb2Nlc3MgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5jbGFzcyBJZ25vcmUge1xuICAgIHJlbGF0aXZlO1xuICAgIHJlbGF0aXZlQ2hpbGRyZW47XG4gICAgYWJzb2x1dGU7XG4gICAgYWJzb2x1dGVDaGlsZHJlbjtcbiAgICBwbGF0Zm9ybTtcbiAgICBtbW9wdHM7XG4gICAgY29uc3RydWN0b3IoaWdub3JlZCwgeyBub2JyYWNlLCBub2Nhc2UsIG5vZXh0LCBub2dsb2JzdGFyLCBwbGF0Zm9ybSA9IGRlZmF1bHRQbGF0Zm9ybSwgfSkge1xuICAgICAgICB0aGlzLnJlbGF0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWJzb2x1dGUgPSBbXTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuYWJzb2x1dGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMubW1vcHRzID0ge1xuICAgICAgICAgICAgZG90OiB0cnVlLFxuICAgICAgICAgICAgbm9icmFjZSxcbiAgICAgICAgICAgIG5vY2FzZSxcbiAgICAgICAgICAgIG5vZXh0LFxuICAgICAgICAgICAgbm9nbG9ic3RhcixcbiAgICAgICAgICAgIG9wdGltaXphdGlvbkxldmVsOiAyLFxuICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICBub2NvbW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBub25lZ2F0ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBpZ24gb2YgaWdub3JlZClcbiAgICAgICAgICAgIHRoaXMuYWRkKGlnbik7XG4gICAgfVxuICAgIGFkZChpZ24pIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGxpdHRsZSB3ZWlyZCwgYnV0IGl0IGdpdmVzIHVzIGEgY2xlYW4gc2V0IG9mIG9wdGltaXplZFxuICAgICAgICAvLyBtaW5pbWF0Y2ggbWF0Y2hlcnMsIHdpdGhvdXQgZ2V0dGluZyB0cmlwcGVkIHVwIGlmIG9uZSBvZiB0aGVtXG4gICAgICAgIC8vIGVuZHMgaW4gLyoqIGluc2lkZSBhIGJyYWNlIHNlY3Rpb24sIGFuZCBpdCdzIG9ubHkgaW5lZmZpY2llbnQgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSB3YWxrLCBub3QgYWxvbmcgaXQuXG4gICAgICAgIC8vIEl0J2QgYmUgbmljZSBpZiB0aGUgUGF0dGVybiBjbGFzcyBqdXN0IGhhZCBhIC50ZXN0KCkgbWV0aG9kLCBidXRcbiAgICAgICAgLy8gaGFuZGxpbmcgZ2xvYnN0YXJzIGlzIGEgYml0IG9mIGEgcGl0YSwgYW5kIHRoYXQgY29kZSBhbHJlYWR5IGxpdmVzXG4gICAgICAgIC8vIGluIG1pbmltYXRjaCBhbnl3YXkuXG4gICAgICAgIC8vIEFub3RoZXIgd2F5IHdvdWxkIGJlIGlmIG1heWJlIE1pbmltYXRjaCBjb3VsZCB0YWtlIGl0cyBzZXQvZ2xvYlBhcnRzXG4gICAgICAgIC8vIGFzIGFuIG9wdGlvbiwgYW5kIHRoZW4gd2UgY291bGQgYXQgbGVhc3QganVzdCB1c2UgUGF0dGVybiB0byB0ZXN0XG4gICAgICAgIC8vIGZvciBhYnNvbHV0ZS1uZXNzLlxuICAgICAgICAvLyBZZXQgYW5vdGhlciB3YXksIE1pbmltYXRjaCBjb3VsZCB0YWtlIGFuIGFycmF5IG9mIGdsb2Igc3RyaW5ncywgYW5kXG4gICAgICAgIC8vIGEgY3dkIG9wdGlvbiwgYW5kIGRvIHRoZSByaWdodCB0aGluZy5cbiAgICAgICAgY29uc3QgbW0gPSBuZXcgbWluaW1hdGNoXzEuTWluaW1hdGNoKGlnbiwgdGhpcy5tbW9wdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1tLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbW0uc2V0W2ldO1xuICAgICAgICAgICAgY29uc3QgZ2xvYlBhcnRzID0gbW0uZ2xvYlBhcnRzW2ldO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIXBhcnNlZCB8fCAhZ2xvYlBhcnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhdHRlcm4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHJpcCBvZmYgbGVhZGluZyAuLyBwb3J0aW9uc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzU3MFxuICAgICAgICAgICAgd2hpbGUgKHBhcnNlZFswXSA9PT0gJy4nICYmIGdsb2JQYXJ0c1swXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZ2xvYlBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBwYXR0ZXJuX2pzXzEuUGF0dGVybihwYXJzZWQsIGdsb2JQYXJ0cywgMCwgdGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IG1pbmltYXRjaF8xLk1pbmltYXRjaChwLmdsb2JTdHJpbmcoKSwgdGhpcy5tbW9wdHMpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnbG9iUGFydHNbZ2xvYlBhcnRzLmxlbmd0aCAtIDFdID09PSAnKionO1xuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwLmlzQWJzb2x1dGUoKTtcbiAgICAgICAgICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlLnB1c2gobSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZS5wdXNoKG0pO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlQ2hpbGRyZW4ucHVzaChtKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVDaGlsZHJlbi5wdXNoKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZWQocCkge1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHAuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgZnVsbHBhdGhzID0gYCR7ZnVsbHBhdGh9L2A7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlID0gcC5yZWxhdGl2ZSgpIHx8ICcuJztcbiAgICAgICAgY29uc3QgcmVsYXRpdmVzID0gYCR7cmVsYXRpdmV9L2A7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChyZWxhdGl2ZSkgfHwgbS5tYXRjaChyZWxhdGl2ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLmFic29sdXRlKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChmdWxscGF0aCkgfHwgbS5tYXRjaChmdWxscGF0aHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hpbGRyZW5JZ25vcmVkKHApIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSBwLmZ1bGxwYXRoKCkgKyAnLyc7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlID0gKHAucmVsYXRpdmUoKSB8fCAnLicpICsgJy8nO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChyZWxhdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMuYWJzb2x1dGVDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2goZnVsbHBhdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLklnbm9yZSA9IElnbm9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/ignore.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/index.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;\nexports.globStreamSync = globStreamSync;\nexports.globStream = globStream;\nexports.globSync = globSync;\nexports.globIterateSync = globIterateSync;\nexports.globIterate = globIterate;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\nconst glob_js_1 = __webpack_require__(/*! ./glob.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/glob.js\");\nconst has_magic_js_1 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/has-magic.js\");\nvar minimatch_2 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return minimatch_2.escape; } }));\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return minimatch_2.unescape; } }));\nvar glob_js_2 = __webpack_require__(/*! ./glob.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/glob.js\");\nObject.defineProperty(exports, \"Glob\", ({ enumerable: true, get: function () { return glob_js_2.Glob; } }));\nvar has_magic_js_2 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/has-magic.js\");\nObject.defineProperty(exports, \"hasMagic\", ({ enumerable: true, get: function () { return has_magic_js_2.hasMagic; } }));\nvar ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/ignore.js\");\nObject.defineProperty(exports, \"Ignore\", ({ enumerable: true, get: function () { return ignore_js_1.Ignore; } }));\nfunction globStreamSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexports.streamSync = globStreamSync;\nexports.stream = Object.assign(globStream, { sync: globStreamSync });\nexports.iterateSync = globIterateSync;\nexports.iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nexports.sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nexports.glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync: exports.sync,\n    globStream,\n    stream: exports.stream,\n    globStreamSync,\n    streamSync: exports.streamSync,\n    globIterate,\n    iterate: exports.iterate,\n    globIterateSync,\n    iterateSync: exports.iterateSync,\n    Glob: glob_js_1.Glob,\n    hasMagic: has_magic_js_1.hasMagic,\n    escape: minimatch_1.escape,\n    unescape: minimatch_1.unescape,\n});\nexports.glob.glob = exports.glob;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYztBQUNoTSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLCtGQUFXO0FBQ3JDLHVCQUF1QixtQkFBTyxDQUFDLHlHQUFnQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQywwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNENBQTJDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ25ILGdCQUFnQixtQkFBTyxDQUFDLCtGQUFXO0FBQ25DLHdDQUF1QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUN6RyxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBZ0I7QUFDN0MsNENBQTJDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3RILGtCQUFrQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3ZDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjLCtCQUErQixzQkFBc0I7QUFDbkUsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBLENBQUM7QUFDRCxZQUFZO0FBQ1o7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iID0gZXhwb3J0cy5zeW5jID0gZXhwb3J0cy5pdGVyYXRlID0gZXhwb3J0cy5pdGVyYXRlU3luYyA9IGV4cG9ydHMuc3RyZWFtID0gZXhwb3J0cy5zdHJlYW1TeW5jID0gZXhwb3J0cy5JZ25vcmUgPSBleHBvcnRzLmhhc01hZ2ljID0gZXhwb3J0cy5HbG9iID0gZXhwb3J0cy51bmVzY2FwZSA9IGV4cG9ydHMuZXNjYXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nbG9iU3RyZWFtU3luYyA9IGdsb2JTdHJlYW1TeW5jO1xuZXhwb3J0cy5nbG9iU3RyZWFtID0gZ2xvYlN0cmVhbTtcbmV4cG9ydHMuZ2xvYlN5bmMgPSBnbG9iU3luYztcbmV4cG9ydHMuZ2xvYkl0ZXJhdGVTeW5jID0gZ2xvYkl0ZXJhdGVTeW5jO1xuZXhwb3J0cy5nbG9iSXRlcmF0ZSA9IGdsb2JJdGVyYXRlO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuY29uc3QgZ2xvYl9qc18xID0gcmVxdWlyZShcIi4vZ2xvYi5qc1wiKTtcbmNvbnN0IGhhc19tYWdpY19qc18xID0gcmVxdWlyZShcIi4vaGFzLW1hZ2ljLmpzXCIpO1xudmFyIG1pbmltYXRjaF8yID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluaW1hdGNoXzIuZXNjYXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5lc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pbmltYXRjaF8yLnVuZXNjYXBlOyB9IH0pO1xudmFyIGdsb2JfanNfMiA9IHJlcXVpcmUoXCIuL2dsb2IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iX2pzXzIuR2xvYjsgfSB9KTtcbnZhciBoYXNfbWFnaWNfanNfMiA9IHJlcXVpcmUoXCIuL2hhcy1tYWdpYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc01hZ2ljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNfbWFnaWNfanNfMi5oYXNNYWdpYzsgfSB9KTtcbnZhciBpZ25vcmVfanNfMSA9IHJlcXVpcmUoXCIuL2lnbm9yZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklnbm9yZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWdub3JlX2pzXzEuSWdub3JlOyB9IH0pO1xuZnVuY3Rpb24gZ2xvYlN0cmVhbVN5bmMocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBnbG9iX2pzXzEuR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5zdHJlYW1TeW5jKCk7XG59XG5mdW5jdGlvbiBnbG9iU3RyZWFtKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykuc3RyZWFtKCk7XG59XG5mdW5jdGlvbiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGtTeW5jKCk7XG59XG5hc3luYyBmdW5jdGlvbiBnbG9iXyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGsoKTtcbn1cbmZ1bmN0aW9uIGdsb2JJdGVyYXRlU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGVTeW5jKCk7XG59XG5mdW5jdGlvbiBnbG9iSXRlcmF0ZShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGUoKTtcbn1cbi8vIGFsaWFzZXM6IGdsb2Iuc3luYy5zdHJlYW0oKSBnbG9iLnN0cmVhbS5zeW5jKCkgZ2xvYi5zeW5jKCkgZXRjXG5leHBvcnRzLnN0cmVhbVN5bmMgPSBnbG9iU3RyZWFtU3luYztcbmV4cG9ydHMuc3RyZWFtID0gT2JqZWN0LmFzc2lnbihnbG9iU3RyZWFtLCB7IHN5bmM6IGdsb2JTdHJlYW1TeW5jIH0pO1xuZXhwb3J0cy5pdGVyYXRlU3luYyA9IGdsb2JJdGVyYXRlU3luYztcbmV4cG9ydHMuaXRlcmF0ZSA9IE9iamVjdC5hc3NpZ24oZ2xvYkl0ZXJhdGUsIHtcbiAgICBzeW5jOiBnbG9iSXRlcmF0ZVN5bmMsXG59KTtcbmV4cG9ydHMuc3luYyA9IE9iamVjdC5hc3NpZ24oZ2xvYlN5bmMsIHtcbiAgICBzdHJlYW06IGdsb2JTdHJlYW1TeW5jLFxuICAgIGl0ZXJhdGU6IGdsb2JJdGVyYXRlU3luYyxcbn0pO1xuZXhwb3J0cy5nbG9iID0gT2JqZWN0LmFzc2lnbihnbG9iXywge1xuICAgIGdsb2I6IGdsb2JfLFxuICAgIGdsb2JTeW5jLFxuICAgIHN5bmM6IGV4cG9ydHMuc3luYyxcbiAgICBnbG9iU3RyZWFtLFxuICAgIHN0cmVhbTogZXhwb3J0cy5zdHJlYW0sXG4gICAgZ2xvYlN0cmVhbVN5bmMsXG4gICAgc3RyZWFtU3luYzogZXhwb3J0cy5zdHJlYW1TeW5jLFxuICAgIGdsb2JJdGVyYXRlLFxuICAgIGl0ZXJhdGU6IGV4cG9ydHMuaXRlcmF0ZSxcbiAgICBnbG9iSXRlcmF0ZVN5bmMsXG4gICAgaXRlcmF0ZVN5bmM6IGV4cG9ydHMuaXRlcmF0ZVN5bmMsXG4gICAgR2xvYjogZ2xvYl9qc18xLkdsb2IsXG4gICAgaGFzTWFnaWM6IGhhc19tYWdpY19qc18xLmhhc01hZ2ljLFxuICAgIGVzY2FwZTogbWluaW1hdGNoXzEuZXNjYXBlLFxuICAgIHVuZXNjYXBlOiBtaW5pbWF0Y2hfMS51bmVzY2FwZSxcbn0pO1xuZXhwb3J0cy5nbG9iLmdsb2IgPSBleHBvcnRzLmdsb2I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/pattern.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/pattern.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// this is just a very light wrapper around 2 arrays with an offset index\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pattern = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\nexports.Pattern = Pattern;\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvcGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHRoaXMgaXMganVzdCBhIHZlcnkgbGlnaHQgd3JhcHBlciBhcm91bmQgMiBhcnJheXMgd2l0aCBhbiBvZmZzZXQgaW5kZXhcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0dGVybiA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbmNvbnN0IGlzUGF0dGVybkxpc3QgPSAocGwpID0+IHBsLmxlbmd0aCA+PSAxO1xuY29uc3QgaXNHbG9iTGlzdCA9IChnbCkgPT4gZ2wubGVuZ3RoID49IDE7XG4vKipcbiAqIEFuIGltbXV0YWJsZS1pc2ggdmlldyBvbiBhbiBhcnJheSBvZiBnbG9iIHBhcnRzIGFuZCB0aGVpciBwYXJzZWRcbiAqIHJlc3VsdHNcbiAqL1xuY2xhc3MgUGF0dGVybiB7XG4gICAgI3BhdHRlcm5MaXN0O1xuICAgICNnbG9iTGlzdDtcbiAgICAjaW5kZXg7XG4gICAgbGVuZ3RoO1xuICAgICNwbGF0Zm9ybTtcbiAgICAjcmVzdDtcbiAgICAjZ2xvYlN0cmluZztcbiAgICAjaXNEcml2ZTtcbiAgICAjaXNVTkM7XG4gICAgI2lzQWJzb2x1dGU7XG4gICAgI2ZvbGxvd0dsb2JzdGFyID0gdHJ1ZTtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuTGlzdCwgZ2xvYkxpc3QsIGluZGV4LCBwbGF0Zm9ybSkge1xuICAgICAgICBpZiAoIWlzUGF0dGVybkxpc3QocGF0dGVybkxpc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbXB0eSBwYXR0ZXJuIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzR2xvYkxpc3QoZ2xvYkxpc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbXB0eSBnbG9iIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYkxpc3QubGVuZ3RoICE9PSBwYXR0ZXJuTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc21hdGNoZWQgcGF0dGVybiBsaXN0IGFuZCBnbG9iIGxpc3QgbGVuZ3RocycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IHBhdHRlcm5MaXN0O1xuICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IGdsb2JMaXN0O1xuICAgICAgICB0aGlzLiNpbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICAvLyBub3JtYWxpemUgcm9vdCBlbnRyaWVzIG9mIGFic29sdXRlIHBhdHRlcm5zIG9uIGluaXRpYWwgY3JlYXRpb24uXG4gICAgICAgIGlmICh0aGlzLiNpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYzogPT4gWydjOi8nXVxuICAgICAgICAgICAgLy8gQzovID0+IFsnQzovJ11cbiAgICAgICAgICAgIC8vIEM6L3ggPT4gWydDOi8nLCAneCddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUgPT4gWycvL2hvc3Qvc2hhcmUvJ11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZS8gPT4gWycvL2hvc3Qvc2hhcmUvJ11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZS94ID0+IFsnLy9ob3N0L3NoYXJlLycsICd4J11cbiAgICAgICAgICAgIC8vIC9ldGMgPT4gWycvJywgJ2V0YyddXG4gICAgICAgICAgICAvLyAvID0+IFsnLyddXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VOQygpKSB7XG4gICAgICAgICAgICAgICAgLy8gJycgLyAnJyAvICdob3N0JyAvICdzaGFyZSdcbiAgICAgICAgICAgICAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDMsIC4uLnByZXN0XSA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtnMCwgZzEsIGcyLCBnMywgLi4uZ3Jlc3RdID0gdGhpcy4jZ2xvYkxpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByZXN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmRzIGluIC9cbiAgICAgICAgICAgICAgICAgICAgcHJlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3Jlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IFtwMCwgcDEsIHAyLCBwMywgJyddLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gW2cwLCBnMSwgZzIsIGczLCAnJ10uam9pbignLycpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gW3AsIC4uLnByZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IFtnLCAuLi5ncmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLiNwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzRHJpdmUoKSB8fCB0aGlzLmlzQWJzb2x1dGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwMSwgLi4ucHJlc3RdID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgICAgICAgICAgY29uc3QgW2cxLCAuLi5ncmVzdF0gPSB0aGlzLiNnbG9iTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZHMgaW4gL1xuICAgICAgICAgICAgICAgICAgICBwcmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBncmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcDEgKyAnLyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGcxICsgJy8nO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gW3AsIC4uLnByZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdCA9IFtnLCAuLi5ncmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLiNwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGVudHJ5IGluIHRoZSBwYXJzZWQgbGlzdCBvZiBwYXR0ZXJuc1xuICAgICAqL1xuICAgIHBhdHRlcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgb2YgaWYgcGF0dGVybigpIHJldHVybnMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIG9mIGlmIHBhdHRlcm4oKSByZXR1cm5zIEdMT0JTVEFSXG4gICAgICovXG4gICAgaXNHbG9ic3RhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSA9PT0gbWluaW1hdGNoXzEuR0xPQlNUQVI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgcGF0dGVybigpIHJldHVybnMgYSByZWdleHBcbiAgICAgKi9cbiAgICBpc1JlZ0V4cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIC8tam9pbmVkIHNldCBvZiBnbG9iIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGlzIHBhdHRlcm5cbiAgICAgKi9cbiAgICBnbG9iU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2dsb2JTdHJpbmcgPVxuICAgICAgICAgICAgdGhpcy4jZ2xvYlN0cmluZyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNpbmRleCA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBYnNvbHV0ZSgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0WzBdICsgdGhpcy4jZ2xvYkxpc3Quc2xpY2UoMSkuam9pbignLycpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI2dsb2JMaXN0LmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI2dsb2JMaXN0LnNsaWNlKHRoaXMuI2luZGV4KS5qb2luKCcvJykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYXR0ZXJuIHBhcnRzIGFmdGVyIHRoaXMgb25lXG4gICAgICovXG4gICAgaGFzTW9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gdGhpcy4jaW5kZXggKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlciB0aGlzIHBhcnQsIG9yIG51bGwgaWYgdGhpcyBpcyB0aGUgZW5kXG4gICAgICovXG4gICAgcmVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jlc3QgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXN0O1xuICAgICAgICBpZiAoIXRoaXMuaGFzTW9yZSgpKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZXN0ID0gbnVsbCk7XG4gICAgICAgIHRoaXMuI3Jlc3QgPSBuZXcgUGF0dGVybih0aGlzLiNwYXR0ZXJuTGlzdCwgdGhpcy4jZ2xvYkxpc3QsIHRoaXMuI2luZGV4ICsgMSwgdGhpcy4jcGxhdGZvcm0pO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc0Fic29sdXRlID0gdGhpcy4jaXNBYnNvbHV0ZTtcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNVTkMgPSB0aGlzLiNpc1VOQztcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNEcml2ZSA9IHRoaXMuI2lzRHJpdmU7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBwYXR0ZXJuIHJlcHJlc2VudHMgYSAvL3VuYy9wYXRoLyBvbiB3aW5kb3dzXG4gICAgICovXG4gICAgaXNVTkMoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc1VOQyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzVU5DXG4gICAgICAgICAgICA6ICh0aGlzLiNpc1VOQyA9XG4gICAgICAgICAgICAgICAgdGhpcy4jcGxhdGZvcm0gPT09ICd3aW4zMicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgcGxbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHBsWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICEhcGxbMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAhIXBsWzNdKTtcbiAgICB9XG4gICAgLy8gcGF0dGVybiBsaWtlIEM6Ly4uLlxuICAgIC8vIHNwbGl0ID0gWydDOicsIC4uLl1cbiAgICAvLyBYWFg6IHdvdWxkIGJlIG5pY2UgdG8gaGFuZGxlIHBhdHRlcm5zIGxpa2UgYGM6KmAgdG8gdGVzdCB0aGUgY3dkXG4gICAgLy8gaW4gYzogZm9yICosIGJ1dCBJIGRvbid0IGtub3cgb2YgYSB3YXkgdG8gZXZlbiBmaWd1cmUgb3V0IHdoYXQgdGhhdFxuICAgIC8vIGN3ZCBpcyB3aXRob3V0IGFjdHVhbGx5IGNoZGlyJ2luZyBpbnRvIGl0P1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggYSBkcml2ZSBsZXR0ZXIgb24gV2luZG93c1xuICAgICAqL1xuICAgIGlzRHJpdmUoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0RyaXZlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNEcml2ZVxuICAgICAgICAgICAgOiAodGhpcy4jaXNEcml2ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy4jcGxhdGZvcm0gPT09ICd3aW4zMicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwbFswXSkpO1xuICAgIH1cbiAgICAvLyBwYXR0ZXJuID0gJy8nIG9yICcvLi4uJyBvciAnL3gvLi4uJ1xuICAgIC8vIHNwbGl0ID0gWycnLCAnJ10gb3IgWycnLCAuLi5dIG9yIFsnJywgJ3gnLCAuLi5dXG4gICAgLy8gRHJpdmUgYW5kIFVOQyBib3RoIGNvbnNpZGVyZWQgYWJzb2x1dGUgb24gd2luZG93c1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHBhdHRlcm4gaXMgcm9vdGVkIG9uIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNBYnNvbHV0ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzQWJzb2x1dGVcbiAgICAgICAgICAgIDogKHRoaXMuI2lzQWJzb2x1dGUgPVxuICAgICAgICAgICAgICAgIChwbFswXSA9PT0gJycgJiYgcGwubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyaXZlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1VOQygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uc3VtZSB0aGUgcm9vdCBvZiB0aGUgcGF0dGVybiwgYW5kIHJldHVybiBpdFxuICAgICAqL1xuICAgIHJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXR0ZXJuTGlzdFswXTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcCA9PT0gJ3N0cmluZycgJiYgdGhpcy5pc0Fic29sdXRlKCkgJiYgdGhpcy4jaW5kZXggPT09IDApID9cbiAgICAgICAgICAgIHBcbiAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCBnbG9ic3RhciBwYXR0ZXJuIGlzIGFsbG93ZWQgdG8gZm9sbG93XG4gICAgICogYSBzeW1ib2xpYyBsaW5rLlxuICAgICAqL1xuICAgIGNoZWNrRm9sbG93R2xvYnN0YXIoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuI2luZGV4ID09PSAwIHx8XG4gICAgICAgICAgICAhdGhpcy5pc0dsb2JzdGFyKCkgfHxcbiAgICAgICAgICAgICF0aGlzLiNmb2xsb3dHbG9ic3Rhcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhhdCB0aGUgY3VycmVudCBnbG9ic3RhciBwYXR0ZXJuIGlzIGZvbGxvd2luZyBhIHN5bWJvbGljIGxpbmtcbiAgICAgKi9cbiAgICBtYXJrRm9sbG93R2xvYnN0YXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNpbmRleCA9PT0gMCB8fCAhdGhpcy5pc0dsb2JzdGFyKCkgfHwgIXRoaXMuI2ZvbGxvd0dsb2JzdGFyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLiNmb2xsb3dHbG9ic3RhciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlBhdHRlcm4gPSBQYXR0ZXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/pattern.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/processor.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/processor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch_1.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch_1.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\nexports.Processor = Processor;\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCO0FBQ25GLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3Byb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHN5bmNocm9ub3VzIHV0aWxpdHkgZm9yIGZpbHRlcmluZyBlbnRyaWVzIGFuZCBjYWxjdWxhdGluZyBzdWJ3YWxrc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9jZXNzb3IgPSBleHBvcnRzLlN1YldhbGtzID0gZXhwb3J0cy5NYXRjaFJlY29yZCA9IGV4cG9ydHMuSGFzV2Fsa2VkQ2FjaGUgPSB2b2lkIDA7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG4vKipcbiAqIEEgY2FjaGUgb2Ygd2hpY2ggcGF0dGVybnMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBmb3IgYSBnaXZlbiBQYXRoXG4gKi9cbmNsYXNzIEhhc1dhbGtlZENhY2hlIHtcbiAgICBzdG9yZTtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSA9IG5ldyBNYXAoKSkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGFzV2Fsa2VkQ2FjaGUobmV3IE1hcCh0aGlzLnN0b3JlKSk7XG4gICAgfVxuICAgIGhhc1dhbGtlZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0KHRhcmdldC5mdWxscGF0aCgpKT8uaGFzKHBhdHRlcm4uZ2xvYlN0cmluZygpKTtcbiAgICB9XG4gICAgc3RvcmVXYWxrZWQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGFyZ2V0LmZ1bGxwYXRoKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuc3RvcmUuZ2V0KGZ1bGxwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICAgIGNhY2hlZC5hZGQocGF0dGVybi5nbG9iU3RyaW5nKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldChmdWxscGF0aCwgbmV3IFNldChbcGF0dGVybi5nbG9iU3RyaW5nKCldKSk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNXYWxrZWRDYWNoZSA9IEhhc1dhbGtlZENhY2hlO1xuLyoqXG4gKiBBIHJlY29yZCBvZiB3aGljaCBwYXRocyBoYXZlIGJlZW4gbWF0Y2hlZCBpbiBhIGdpdmVuIHdhbGsgc3RlcCxcbiAqIGFuZCB3aGV0aGVyIHRoZXkgb25seSBhcmUgY29uc2lkZXJlZCBhIG1hdGNoIGlmIHRoZXkgYXJlIGEgZGlyZWN0b3J5LFxuICogYW5kIHdoZXRoZXIgdGhlaXIgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcGF0aCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKi9cbmNsYXNzIE1hdGNoUmVjb3JkIHtcbiAgICBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICBhZGQodGFyZ2V0LCBhYnNvbHV0ZSwgaWZEaXIpIHtcbiAgICAgICAgY29uc3QgbiA9IChhYnNvbHV0ZSA/IDIgOiAwKSB8IChpZkRpciA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgICAgIHRoaXMuc3RvcmUuc2V0KHRhcmdldCwgY3VycmVudCA9PT0gdW5kZWZpbmVkID8gbiA6IG4gJiBjdXJyZW50KTtcbiAgICB9XG4gICAgLy8gbWF0Y2gsIGFic29sdXRlLCBpZmRpclxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zdG9yZS5lbnRyaWVzKCldLm1hcCgoW3BhdGgsIG5dKSA9PiBbXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgISEobiAmIDIpLFxuICAgICAgICAgICAgISEobiAmIDEpLFxuICAgICAgICBdKTtcbiAgICB9XG59XG5leHBvcnRzLk1hdGNoUmVjb3JkID0gTWF0Y2hSZWNvcmQ7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwYXR0ZXJucyB0aGF0IG11c3QgYmUgcHJvY2Vzc2VkIGluIGEgc3Vic2VxdWVudCBzdGVwXG4gKiBmb3IgYSBnaXZlbiBwYXRoLlxuICovXG5jbGFzcyBTdWJXYWxrcyB7XG4gICAgc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgYWRkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICBpZiAoIXRhcmdldC5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgIGlmICghc3Vicy5maW5kKHAgPT4gcC5nbG9iU3RyaW5nKCkgPT09IHBhdHRlcm4uZ2xvYlN0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHN1YnMucHVzaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldCh0YXJnZXQsIFtwYXR0ZXJuXSk7XG4gICAgfVxuICAgIGdldCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXN1YnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGluZyB0byB3YWxrIHVua25vd24gcGF0aCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiBzdWJzO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzKCkubWFwKGsgPT4gW2ssIHRoaXMuc3RvcmUuZ2V0KGspXSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zdG9yZS5rZXlzKCldLmZpbHRlcih0ID0+IHQuY2FuUmVhZGRpcigpKTtcbiAgICB9XG59XG5leHBvcnRzLlN1YldhbGtzID0gU3ViV2Fsa3M7XG4vKipcbiAqIFRoZSBjbGFzcyB0aGF0IHByb2Nlc3NlcyBwYXR0ZXJucyBmb3IgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEhhbmRsZXMgY2hpbGQgZW50cnkgZmlsdGVyaW5nLCBhbmQgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHBhdGgnc1xuICogZGlyZWN0b3J5IGNvbnRlbnRzIG11c3QgYmUgcmVhZC5cbiAqL1xuY2xhc3MgUHJvY2Vzc29yIHtcbiAgICBoYXNXYWxrZWRDYWNoZTtcbiAgICBtYXRjaGVzID0gbmV3IE1hdGNoUmVjb3JkKCk7XG4gICAgc3Vid2Fsa3MgPSBuZXcgU3ViV2Fsa3MoKTtcbiAgICBwYXR0ZXJucztcbiAgICBmb2xsb3c7XG4gICAgZG90O1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3Iob3B0cywgaGFzV2Fsa2VkQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5mb2xsb3cgPSAhIW9wdHMuZm9sbG93O1xuICAgICAgICB0aGlzLmRvdCA9ICEhb3B0cy5kb3Q7XG4gICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUgPVxuICAgICAgICAgICAgaGFzV2Fsa2VkQ2FjaGUgPyBoYXNXYWxrZWRDYWNoZS5jb3B5KCkgOiBuZXcgSGFzV2Fsa2VkQ2FjaGUoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICAgICAgICBjb25zdCBwcm9jZXNzaW5nU2V0ID0gcGF0dGVybnMubWFwKHAgPT4gW3RhcmdldCwgcF0pO1xuICAgICAgICAvLyBtYXAgb2YgcGF0aHMgdG8gdGhlIG1hZ2ljLXN0YXJ0aW5nIHN1YndhbGtzIHRoZXkgbmVlZCB0byB3YWxrXG4gICAgICAgIC8vIGZpcnN0IGl0ZW0gaW4gcGF0dGVybnMgaXMgdGhlIGZpbHRlclxuICAgICAgICBmb3IgKGxldCBbdCwgcGF0dGVybl0gb2YgcHJvY2Vzc2luZ1NldCkge1xuICAgICAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZS5zdG9yZVdhbGtlZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBwYXR0ZXJuLnJvb3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcGF0dGVybi5pc0Fic29sdXRlKCkgJiYgdGhpcy5vcHRzLmFic29sdXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGFic29sdXRlIHBhdHRlcm5zIGF0IHJvb3RcbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgICAgdCA9IHQucmVzb2x2ZShyb290ID09PSAnLycgJiYgdGhpcy5vcHRzLnJvb3QgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5yb290XG4gICAgICAgICAgICAgICAgICAgIDogcm9vdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodC5pc0VOT0VOVCgpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICBsZXQgcmVzdDtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAodHlwZW9mIChwID0gcGF0dGVybi5wYXR0ZXJuKCkpID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIChyZXN0ID0gcGF0dGVybi5yZXN0KCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHQucmVzb2x2ZShwKTtcbiAgICAgICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcmVzdDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwYXR0ZXJuLnBhdHRlcm4oKTtcbiAgICAgICAgICAgIHJlc3QgPSBwYXR0ZXJuLnJlc3QoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzV2Fsa2VkQ2FjaGUuaGFzV2Fsa2VkKHQsIHBhdHRlcm4pKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlLnN0b3JlV2Fsa2VkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IHdlIGhhdmUgZWl0aGVyIGEgZmluYWwgc3RyaW5nIGZvciBhIGtub3duIGVudHJ5LFxuICAgICAgICAgICAgLy8gbW9yZSBzdHJpbmdzIGZvciBhbiB1bmtub3duIGVudHJ5LFxuICAgICAgICAgICAgLy8gb3IgYSBwYXR0ZXJuIHN0YXJ0aW5nIHdpdGggbWFnaWMsIG1vdW50ZWQgb24gdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IG5vdCBiZSBmaW5hbCBlbnRyeSwgb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBjb25jYXRlbmF0ZWQgaXQgZWFybGllci5cbiAgICAgICAgICAgICAgICBjb25zdCBpZkRpciA9IHAgPT09ICcuLicgfHwgcCA9PT0gJycgfHwgcCA9PT0gJy4nO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodC5yZXNvbHZlKHApLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gbWluaW1hdGNoXzEuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyByZXN0LCBtYXRjaCBhbmQgc3Vid2FsayBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgLy8gaWYgcmVzdCwgcHJvY2VzcyByZXN0IGFuZCBzdWJ3YWxrIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGEgc3ltbGluaywgYnV0IHdlIGRpZG4ndCBnZXQgaGVyZSBieSB3YXkgb2YgYVxuICAgICAgICAgICAgICAgIC8vIGdsb2JzdGFyIG1hdGNoIChtZWFuaW5nIGl0J3MgdGhlIGZpcnN0IHRpbWUgVEhJUyBnbG9ic3RhclxuICAgICAgICAgICAgICAgIC8vIGhhcyB0cmF2ZXJzZWQgYSBzeW1saW5rKSwgdGhlbiB3ZSBmb2xsb3cgaXQuIE90aGVyd2lzZSwgc3RvcC5cbiAgICAgICAgICAgICAgICBpZiAoIXQuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGxvdyB8fFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmNoZWNrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnAgPSByZXN0Py5wYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnJlc3QgPSByZXN0Py5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN0IHx8ICgocnAgPT09ICcnIHx8IHJwID09PSAnLicpICYmICFycmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBIQVMgdG8gYmUgYSBkaXIgaWYgaXQgZW5kcyBpbiAqKi8gb3IgKiovLlxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgZW5kaW5nIGluICoqIHdpbGwgbWF0Y2ggZmlsZXMgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LCBhYnNvbHV0ZSwgcnAgPT09ICcnIHx8IHJwID09PSAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJwID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIG1lYW4geW91J3JlIG1hdGNoaW5nICoqLy4uIGF0IHRoZSBmcyByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vIHRoYW5rcywgSSdtIG5vdCBnb25uYSB0ZXN0IHRoYXQgc3BlY2lmaWMgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHAgPSB0LnBhcmVudCB8fCB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnJlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0cCwgYWJzb2x1dGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzV2Fsa2VkQ2FjaGUuaGFzV2Fsa2VkKHRwLCBycmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZCh0cCwgcnJlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJ3YWxrVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vid2Fsa3Mua2V5cygpO1xuICAgIH1cbiAgICBjaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzb3IodGhpcy5vcHRzLCB0aGlzLmhhc1dhbGtlZENhY2hlKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGEgbmV3IFByb2Nlc3NvciBjb250YWluaW5nIHRoZSBzdWJ3YWxrcyBmb3IgZWFjaFxuICAgIC8vIGNoaWxkIGVudHJ5LCBhbmQgYSBzZXQgb2YgbWF0Y2hlcywgYW5kXG4gICAgLy8gYSBoYXNXYWxrZWRDYWNoZSB0aGF0J3MgYSBjb3B5IG9mIHRoaXMgb25lXG4gICAgLy8gdGhlbiB3ZSdyZSBnb2luZyB0byBjYWxsXG4gICAgZmlsdGVyRW50cmllcyhwYXJlbnQsIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSB0aGlzLnN1YndhbGtzLmdldChwYXJlbnQpO1xuICAgICAgICAvLyBwdXQgbWF0Y2hlcyBhbmQgZW50cnkgd2Fsa3MgaW50byB0aGUgcmVzdWx0cyBwcm9jZXNzb3JcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY2hpbGQoKTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcGF0dGVybi5pc0Fic29sdXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhdHRlcm4ucGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwYXR0ZXJuLnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gbWluaW1hdGNoXzEuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0R2xvYnN0YXIoZSwgcGF0dGVybiwgcmVzdCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdFJlZ0V4cChlLCBwLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RTdHJpbmcoZSwgcCwgcmVzdCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgdGVzdEdsb2JzdGFyKGUsIHBhdHRlcm4sIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvdCB8fCAhZS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLmhhc01vcmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGZvbGxvdyBtb2RlIG9yIGl0J3Mgbm90IGEgc3ltbGluaywganVzdCBrZWVwXG4gICAgICAgICAgICAgICAgLy8gdGVzdGluZyB0aGUgc2FtZSBwYXR0ZXJuLiBJZiB0aGVyZSdzIG1vcmUgYWZ0ZXIgdGhlIGdsb2JzdGFyLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBzeW1saW5rIGNvbnN1bWVzIHRoZSBnbG9ic3Rhci4gSWYgbm90LCB0aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGZvbGxvdyBhdCBtb3N0IE9ORSBzeW1saW5rIGFsb25nIHRoZSB3YXksIHNvIHdlIG1hcmsgaXQsIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBjaGVja3MgdG8gZW5zdXJlIHRoYXQgaXQgd2Fzbid0IGFscmVhZHkgbWFya2VkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdyB8fCAhZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgJiYgcGF0dGVybi5jaGVja0ZvbGxvd0dsb2JzdGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdHRlcm4ubWFya0ZvbGxvd0dsb2JzdGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBORVhUIHRoaW5nIG1hdGNoZXMgdGhpcyBlbnRyeSwgdGhlbiBhbHNvIGFkZFxuICAgICAgICAvLyB0aGUgcmVzdC5cbiAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJwID0gcmVzdC5wYXR0ZXJuKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJwID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIC8vIGRvdHMgYW5kIGVtcHR5IHdlcmUgaGFuZGxlZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgcnAgIT09ICcuLicgJiZcbiAgICAgICAgICAgICAgICBycCAhPT0gJycgJiZcbiAgICAgICAgICAgICAgICBycCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0U3RyaW5nKGUsIHJwLCByZXN0LnJlc3QoKSwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnAgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBlcCA9IGUucGFyZW50IHx8IGU7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlcCwgcmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChycCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdFJlZ0V4cChlLCBycCwgcmVzdC5yZXN0KCksIGFic29sdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0UmVnRXhwKGUsIHAsIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICghcC50ZXN0KGUubmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGVzdFN0cmluZyhlLCBwLCByZXN0LCBhYnNvbHV0ZSkge1xuICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuP1xuICAgICAgICBpZiAoIWUuaXNOYW1lZChwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvY2Vzc29yID0gUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/processor.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/walker.js":
/*!********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/glob/dist/commonjs/walker.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/../node_modules/minipass/dist/commonjs/index.js\");\nconst ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/ignore.js\");\nconst processor_js_1 = __webpack_require__(/*! ./processor.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass_1.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\nexports.GlobStream = GlobStream;\n//# sourceMappingURL=walker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvd2Fsa2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUMxRDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFVO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLHlHQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy93YWxrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdsb2JTdHJlYW0gPSBleHBvcnRzLkdsb2JXYWxrZXIgPSBleHBvcnRzLkdsb2JVdGlsID0gdm9pZCAwO1xuLyoqXG4gKiBTaW5nbGUtdXNlIHV0aWxpdHkgY2xhc3NlcyB0byBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIHtAbGluayBHbG9ifVxuICogbWV0aG9kcy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IG1pbmlwYXNzXzEgPSByZXF1aXJlKFwibWluaXBhc3NcIik7XG5jb25zdCBpZ25vcmVfanNfMSA9IHJlcXVpcmUoXCIuL2lnbm9yZS5qc1wiKTtcbmNvbnN0IHByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vcHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgbWFrZUlnbm9yZSA9IChpZ25vcmUsIG9wdHMpID0+IHR5cGVvZiBpZ25vcmUgPT09ICdzdHJpbmcnID8gbmV3IGlnbm9yZV9qc18xLklnbm9yZShbaWdub3JlXSwgb3B0cylcbiAgICA6IEFycmF5LmlzQXJyYXkoaWdub3JlKSA/IG5ldyBpZ25vcmVfanNfMS5JZ25vcmUoaWdub3JlLCBvcHRzKVxuICAgICAgICA6IGlnbm9yZTtcbi8qKlxuICogYmFzaWMgd2Fsa2luZyB1dGlsaXRpZXMgdGhhdCBhbGwgdGhlIGdsb2Igd2Fsa2VyIHR5cGVzIHVzZVxuICovXG5jbGFzcyBHbG9iVXRpbCB7XG4gICAgcGF0aDtcbiAgICBwYXR0ZXJucztcbiAgICBvcHRzO1xuICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgICNvblJlc3VtZSA9IFtdO1xuICAgICNpZ25vcmU7XG4gICAgI3NlcDtcbiAgICBzaWduYWw7XG4gICAgbWF4RGVwdGg7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuI3NlcCA9ICFvcHRzLnBvc2l4ICYmIG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnXFxcXCcgOiAnLyc7XG4gICAgICAgIHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyA9IG9wdHMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAhPT0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRzLmlnbm9yZSB8fCAhdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLiNpZ25vcmUgPSBtYWtlSWdub3JlKG9wdHMuaWdub3JlID8/IFtdLCBvcHRzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMuI2lnbm9yZS5hZGQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gJ2Nhbm5vdCBpZ25vcmUgY2hpbGQgbWF0Y2hlcywgaWdub3JlIGxhY2tzIGFkZCgpIG1ldGhvZC4nO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZ25vcmUsIGFsd2F5cyBzZXQgd2l0aCBtYXhEZXB0aCwgYnV0IGl0J3Mgb3B0aW9uYWwgb24gdGhlXG4gICAgICAgIC8vIEdsb2JPcHRpb25zIHR5cGVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIHRoaXMubWF4RGVwdGggPSBvcHRzLm1heERlcHRoIHx8IEluZmluaXR5O1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAob3B0cy5zaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvblJlc3VtZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2lnbm9yZWQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWVuLmhhcyhwYXRoKSB8fCAhIXRoaXMuI2lnbm9yZT8uaWdub3JlZD8uKHBhdGgpO1xuICAgIH1cbiAgICAjY2hpbGRyZW5JZ25vcmVkKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jaWdub3JlPy5jaGlsZHJlbklnbm9yZWQ/LihwYXRoKTtcbiAgICB9XG4gICAgLy8gYmFja3ByZXNzdXJlIG1lY2hhbmlzbVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZuID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIChmbiA9IHRoaXMuI29uUmVzdW1lLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVzdW1lKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jb25SZXN1bWUucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gdGhlIHJlcXVpc2l0ZSByZWFscGF0aC9zdGF0IGNoZWNraW5nLCBhbmQgcmV0dXJuIHRoZSBwYXRoXG4gICAgLy8gdG8gYWRkIG9yIHVuZGVmaW5lZCB0byBmaWx0ZXIgaXQgb3V0LlxuICAgIGFzeW5jIG1hdGNoQ2hlY2soZSwgaWZEaXIpIHtcbiAgICAgICAgaWYgKGlmRGlyICYmIHRoaXMub3B0cy5ub2RpcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBycGM7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVhbHBhdGgpIHtcbiAgICAgICAgICAgIHJwYyA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCAoYXdhaXQgZS5yZWFscGF0aCgpKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gYXdhaXQgZS5sc3RhdCgpIDogZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5mb2xsb3cgJiYgdGhpcy5vcHRzLm5vZGlyICYmIHM/LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IHMucmVhbHBhdGgoKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0LmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0KSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRhcmdldC5sc3RhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaENoZWNrVGVzdChzLCBpZkRpcik7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tUZXN0KGUsIGlmRGlyKSB7XG4gICAgICAgIHJldHVybiAoZSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4RGVwdGggPT09IEluZmluaXR5IHx8IGUuZGVwdGgoKSA8PSB0aGlzLm1heERlcHRoKSAmJlxuICAgICAgICAgICAgKCFpZkRpciB8fCBlLmNhblJlYWRkaXIoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5vcHRzLm5vZGlyIHx8ICFlLmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAoIXRoaXMub3B0cy5ub2RpciB8fFxuICAgICAgICAgICAgICAgICF0aGlzLm9wdHMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgIWUuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICAgICAgICAgICAgICAgICFlLnJlYWxwYXRoQ2FjaGVkKCk/LmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAhdGhpcy4jaWdub3JlZChlKSkgP1xuICAgICAgICAgICAgZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tTeW5jKGUsIGlmRGlyKSB7XG4gICAgICAgIGlmIChpZkRpciAmJiB0aGlzLm9wdHMubm9kaXIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcnBjO1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlYWxwYXRoKSB7XG4gICAgICAgICAgICBycGMgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgZS5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gZS5sc3RhdFN5bmMoKSA6IGU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZm9sbG93ICYmIHRoaXMub3B0cy5ub2RpciAmJiBzPy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzLnJlYWxwYXRoU3luYygpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0Py5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hDaGVja1Rlc3QocywgaWZEaXIpO1xuICAgIH1cbiAgICBtYXRjaEZpbmlzaChlLCBhYnNvbHV0ZSkge1xuICAgICAgICBpZiAodGhpcy4jaWdub3JlZChlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gd2Uga25vdyB3ZSBoYXZlIGFuIGlnbm9yZSBpZiB0aGlzIGlzIGZhbHNlLCBidXQgVFMgZG9lc24ndFxuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAmJiB0aGlzLiNpZ25vcmU/LmFkZCkge1xuICAgICAgICAgICAgY29uc3QgaWduID0gYCR7ZS5yZWxhdGl2ZVBvc2l4KCl9LyoqYDtcbiAgICAgICAgICAgIHRoaXMuI2lnbm9yZS5hZGQoaWduKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnMgPSB0aGlzLm9wdHMuYWJzb2x1dGUgPT09IHVuZGVmaW5lZCA/IGFic29sdXRlIDogdGhpcy5vcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLnNlZW4uYWRkKGUpO1xuICAgICAgICBjb25zdCBtYXJrID0gdGhpcy5vcHRzLm1hcmsgJiYgZS5pc0RpcmVjdG9yeSgpID8gdGhpcy4jc2VwIDogJyc7XG4gICAgICAgIC8vIG9rLCB3ZSBoYXZlIHdoYXQgd2UgbmVlZCFcbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFicyA9IHRoaXMub3B0cy5wb3NpeCA/IGUuZnVsbHBhdGhQb3NpeCgpIDogZS5mdWxscGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaEVtaXQoYWJzICsgbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZWwgPSB0aGlzLm9wdHMucG9zaXggPyBlLnJlbGF0aXZlUG9zaXgoKSA6IGUucmVsYXRpdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHRoaXMub3B0cy5kb3RSZWxhdGl2ZSAmJiAhcmVsLnN0YXJ0c1dpdGgoJy4uJyArIHRoaXMuI3NlcCkgP1xuICAgICAgICAgICAgICAgICcuJyArIHRoaXMuI3NlcFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdCghcmVsID8gJy4nICsgbWFyayA6IHByZSArIHJlbCArIG1hcmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1hdGNoKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gYXdhaXQgdGhpcy5tYXRjaENoZWNrKGUsIGlmRGlyKTtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB0aGlzLm1hdGNoRmluaXNoKHAsIGFic29sdXRlKTtcbiAgICB9XG4gICAgbWF0Y2hTeW5jKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5tYXRjaENoZWNrU3luYyhlLCBpZkRpcik7XG4gICAgICAgIGlmIChwKVxuICAgICAgICAgICAgdGhpcy5tYXRjaEZpbmlzaChwLCBhYnNvbHV0ZSk7XG4gICAgfVxuICAgIHdhbGtDQih0YXJnZXQsIHBhdHRlcm5zLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIG5ldyBwcm9jZXNzb3JfanNfMS5Qcm9jZXNzb3IodGhpcy5vcHRzKSwgY2IpO1xuICAgIH1cbiAgICB3YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucyk7XG4gICAgICAgIC8vIGRvbmUgcHJvY2Vzc2luZy4gIGFsbCBvZiB0aGUgYWJvdmUgaXMgc3luYywgY2FuIGJlIGFic3RyYWN0ZWQgb3V0LlxuICAgICAgICAvLyBzdWJ3YWxrcyBpcyBhIG1hcCBvZiBwYXRocyB0byB0aGUgZW50cnkgZmlsdGVycyB0aGV5IG5lZWRcbiAgICAgICAgLy8gbWF0Y2hlcyBpcyBhIG1hcCBvZiBwYXRocyB0byBbYWJzb2x1dGUsIGlmRGlyXSB0dXBsZXMuXG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuQ2FjaGVkID0gdC5yZWFkZGlyQ2FjaGVkKCk7XG4gICAgICAgICAgICBpZiAodC5jYWxsZWRSZWFkZGlyKCkpXG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQ0IzKHQsIGNoaWxkcmVuQ2FjaGVkLCBwcm9jZXNzb3IsIG5leHQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5yZWFkZGlyQ0IoKF8sIGVudHJpZXMpID0+IHRoaXMud2Fsa0NCMyh0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIG5leHQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjModGFyZ2V0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3Nvci5maWx0ZXJFbnRyaWVzKHRhcmdldCwgZW50cmllcyk7XG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3Nvci5jaGlsZCgpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQlN5bmModGFyZ2V0LCBwYXR0ZXJucywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgbmV3IHByb2Nlc3Nvcl9qc18xLlByb2Nlc3Nvcih0aGlzLm9wdHMpLCBjYik7XG4gICAgfVxuICAgIHdhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzb3IucHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpO1xuICAgICAgICAvLyBkb25lIHByb2Nlc3NpbmcuICBhbGwgb2YgdGhlIGFib3ZlIGlzIHN5bmMsIGNhbiBiZSBhYnN0cmFjdGVkIG91dC5cbiAgICAgICAgLy8gc3Vid2Fsa3MgaXMgYSBtYXAgb2YgcGF0aHMgdG8gdGhlIGVudHJ5IGZpbHRlcnMgdGhleSBuZWVkXG4gICAgICAgIC8vIG1hdGNoZXMgaXMgYSBtYXAgb2YgcGF0aHMgdG8gW2Fic29sdXRlLCBpZkRpcl0gdHVwbGVzLlxuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdC5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IzU3luYyh0LCBjaGlsZHJlbiwgcHJvY2Vzc29yLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjNTeW5jKHRhcmdldCwgZW50cmllcywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZmlsdGVyRW50cmllcyh0YXJnZXQsIGVudHJpZXMpO1xuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IuY2hpbGQoKSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2xvYlV0aWwgPSBHbG9iVXRpbDtcbmNsYXNzIEdsb2JXYWxrZXIgZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgbWF0Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1hdGNoRW1pdChlKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXRoLmxzdGF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndhbGtDQih0aGlzLnBhdGgsIHRoaXMucGF0dGVybnMsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqKHRoaXMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXModGhpcy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxuICAgIHdhbGtTeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLnNpZ25hbC5yZWFzb247XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aC5sc3RhdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RoaW5nIGZvciB0aGUgY2FsbGJhY2sgdG8gZG8sIGJlY2F1c2UgdGhpcyBuZXZlciBwYXVzZXNcbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxufVxuZXhwb3J0cy5HbG9iV2Fsa2VyID0gR2xvYldhbGtlcjtcbmNsYXNzIEdsb2JTdHJlYW0gZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgcmVzdWx0cztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBtaW5pcGFzc18xLk1pbmlwYXNzKHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN1bHRzLm9uKCdkcmFpbicsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLnJlc3VsdHMub24oJ3Jlc3VtZScsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgIH1cbiAgICBtYXRjaEVtaXQoZSkge1xuICAgICAgICB0aGlzLnJlc3VsdHMud3JpdGUoZSk7XG4gICAgICAgIGlmICghdGhpcy5yZXN1bHRzLmZsb3dpbmcpXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0YXJnZXQubHN0YXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtDQih0YXJnZXQsIHRoaXMucGF0dGVybnMsICgpID0+IHRoaXMucmVzdWx0cy5lbmQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRhcmdldCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGgubHN0YXRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cztcbiAgICB9XG59XG5leHBvcnRzLkdsb2JTdHJlYW0gPSBHbG9iU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fsa2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/glob/dist/commonjs/walker.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\nexports.assertValidPattern = assertValidPattern;\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRQYXR0ZXJuID0gdm9pZCAwO1xuY29uc3QgTUFYX1BBVFRFUk5fTEVOR1RIID0gMTAyNCAqIDY0O1xuY29uc3QgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gKHBhdHRlcm4pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGF0dGVybicpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfUEFUVEVSTl9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydFZhbGlkUGF0dGVybiA9IGFzc2VydFZhbGlkUGF0dGVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC12YWxpZC1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/ast.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/ast.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsK0JBQStCLG1CQUFPLENBQUMsOEhBQXdCO0FBQy9ELHNCQUFzQixtQkFBTyxDQUFDLDRHQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssTUFBTSxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gcGFyc2UgYSBzaW5nbGUgcGF0aCBwb3J0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFTVCA9IHZvaWQgMDtcbmNvbnN0IGJyYWNlX2V4cHJlc3Npb25zX2pzXzEgPSByZXF1aXJlKFwiLi9icmFjZS1leHByZXNzaW9ucy5qc1wiKTtcbmNvbnN0IHVuZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi91bmVzY2FwZS5qc1wiKTtcbmNvbnN0IHR5cGVzID0gbmV3IFNldChbJyEnLCAnPycsICcrJywgJyonLCAnQCddKTtcbmNvbnN0IGlzRXh0Z2xvYlR5cGUgPSAoYykgPT4gdHlwZXMuaGFzKGMpO1xuLy8gUGF0dGVybnMgdGhhdCBnZXQgcHJlcGVuZGVkIHRvIGJpbmQgdG8gdGhlIHN0YXJ0IG9mIGVpdGhlciB0aGVcbi8vIGVudGlyZSBzdHJpbmcsIG9yIGp1c3QgYSBzaW5nbGUgcGF0aCBwb3J0aW9uLCB0byBwcmV2ZW50IGRvdHNcbi8vIGFuZC9vciB0cmF2ZXJzYWwgcGF0dGVybnMsIHdoZW4gbmVlZGVkLlxuLy8gRXh0cyBkb24ndCBuZWVkIHRoZSBeIG9yIC8gYml0LCBiZWNhdXNlIHRoZSByb290IGJpbmRzIHRoYXQgYWxyZWFkeS5cbmNvbnN0IHN0YXJ0Tm9UcmF2ZXJzYWwgPSAnKD8hKD86XnwvKVxcXFwuXFxcXC4/KD86JHwvKSknO1xuY29uc3Qgc3RhcnROb0RvdCA9ICcoPyFcXFxcLiknO1xuLy8gY2hhcmFjdGVycyB0aGF0IGluZGljYXRlIGEgc3RhcnQgb2YgcGF0dGVybiBuZWVkcyB0aGUgXCJubyBkb3RzXCIgYml0LFxuLy8gYmVjYXVzZSBhIGRvdCAqbWlnaHQqIGJlIG1hdGNoZWQuICggaXMgbm90IGluIHRoZSBsaXN0LCBiZWNhdXNlIGluXG4vLyB0aGUgY2FzZSBvZiBhIGNoaWxkIGV4dGdsb2IsIGl0IHdpbGwgaGFuZGxlIHRoZSBwcmV2ZW50aW9uIGl0c2VsZi5cbmNvbnN0IGFkZFBhdHRlcm5TdGFydCA9IG5ldyBTZXQoWydbJywgJy4nXSk7XG4vLyBjYXNlcyB3aGVyZSB0cmF2ZXJzYWwgaXMgQS1PSywgbm8gZG90IHByZXZlbnRpb24gbmVlZGVkXG5jb25zdCBqdXN0RG90cyA9IG5ldyBTZXQoWycuLicsICcuJ10pO1xuY29uc3QgcmVTcGVjaWFscyA9IG5ldyBTZXQoJygpLip7fSs/W11eJFxcXFwhJyk7XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbmNvbnN0IHFtYXJrID0gJ1teL10nO1xuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbmNvbnN0IHN0YXIgPSBxbWFyayArICcqPyc7XG4vLyB1c2UgKyB3aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgKnNvbWV0aGluZyogbWF0Y2hlcywgYmVjYXVzZSB0aGUgKiBpc1xuLy8gdGhlIG9ubHkgdGhpbmcgaW4gdGhlIHBhdGggcG9ydGlvbi5cbmNvbnN0IHN0YXJOb0VtcHR5ID0gcW1hcmsgKyAnKz8nO1xuLy8gcmVtb3ZlIHRoZSBcXCBjaGFycyB0aGF0IHdlIGFkZGVkIGlmIHdlIGVuZCB1cCBkb2luZyBhIG5vbm1hZ2ljIGNvbXBhcmVcbi8vIGNvbnN0IGRlc2xhc2ggPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbmNsYXNzIEFTVCB7XG4gICAgdHlwZTtcbiAgICAjcm9vdDtcbiAgICAjaGFzTWFnaWM7XG4gICAgI3VmbGFnID0gZmFsc2U7XG4gICAgI3BhcnRzID0gW107XG4gICAgI3BhcmVudDtcbiAgICAjcGFyZW50SW5kZXg7XG4gICAgI25lZ3M7XG4gICAgI2ZpbGxlZE5lZ3MgPSBmYWxzZTtcbiAgICAjb3B0aW9ucztcbiAgICAjdG9TdHJpbmc7XG4gICAgLy8gc2V0IHRvIHRydWUgaWYgaXQncyBhbiBleHRnbG9iIHdpdGggbm8gY2hpbGRyZW5cbiAgICAvLyAod2hpY2ggcmVhbGx5IG1lYW5zIG9uZSBjaGlsZCBvZiAnJylcbiAgICAjZW1wdHlFeHQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyBleHRnbG9icyBhcmUgaW5oZXJlbnRseSBtYWdpY2FsXG4gICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3Jvb3QgOiB0aGlzO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gdGhpcy4jcm9vdCA9PT0gdGhpcyA/IG9wdGlvbnMgOiB0aGlzLiNyb290LiNvcHRpb25zO1xuICAgICAgICB0aGlzLiNuZWdzID0gdGhpcy4jcm9vdCA9PT0gdGhpcyA/IFtdIDogdGhpcy4jcm9vdC4jbmVncztcbiAgICAgICAgaWYgKHR5cGUgPT09ICchJyAmJiAhdGhpcy4jcm9vdC4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHRoaXMuI25lZ3MucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcGFyZW50SW5kZXggPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3BhcnRzLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGdldCBoYXNNYWdpYygpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLiNoYXNNYWdpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy4jcGFydHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocC50eXBlIHx8IHAuaGFzTWFnaWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNoYXNNYWdpYyA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGU6IHdpbGwgYmUgdW5kZWZpbmVkIHVudGlsIHdlIGdlbmVyYXRlIHRoZSByZWdleHAgc3JjIGFuZCBmaW5kIG91dFxuICAgICAgICByZXR1cm4gdGhpcy4jaGFzTWFnaWM7XG4gICAgfVxuICAgIC8vIHJlY29uc3RydWN0cyB0aGUgcGF0dGVyblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy4jdG9TdHJpbmcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN0b1N0cmluZztcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jdG9TdHJpbmcgPSB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jdG9TdHJpbmcgPVxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSArICcoJyArIHRoaXMuI3BhcnRzLm1hcChwID0+IFN0cmluZyhwKSkuam9pbignfCcpICsgJyknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjZmlsbE5lZ3MoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2hvdWxkIG9ubHkgY2FsbCBvbiByb290Jyk7XG4gICAgICAgIGlmICh0aGlzLiNmaWxsZWROZWdzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIC8vIGNhbGwgdG9TdHJpbmcoKSBvbmNlIHRvIGZpbGwgdGhpcyBvdXRcbiAgICAgICAgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLiNmaWxsZWROZWdzID0gdHJ1ZTtcbiAgICAgICAgbGV0IG47XG4gICAgICAgIHdoaWxlICgobiA9IHRoaXMuI25lZ3MucG9wKCkpKSB7XG4gICAgICAgICAgICBpZiAobi50eXBlICE9PSAnIScpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHRoZSB0cmVlLCBhcHBlbmRpbmcgZXZlcnRoaW5nIHRoYXQgY29tZXMgQUZURVIgcGFyZW50SW5kZXhcbiAgICAgICAgICAgIGxldCBwID0gbjtcbiAgICAgICAgICAgIGxldCBwcCA9IHAuI3BhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwcCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwLiNwYXJlbnRJbmRleCArIDE7ICFwcC50eXBlICYmIGkgPCBwcC4jcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG4uI3BhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBwYXJ0IGluIGV4dGdsb2IgQVNUPz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmNvcHlJbihwcC4jcGFydHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBwcDtcbiAgICAgICAgICAgICAgICBwcCA9IHAuI3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaCguLi5wYXJ0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAnJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJyAmJiAhKHAgaW5zdGFuY2VvZiBBU1QgJiYgcC4jcGFyZW50ID09PSB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXJ0OiAnICsgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jcGFydHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMudHlwZSA9PT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLiNwYXJ0cy5zbGljZSgpLm1hcChwID0+ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwIDogcC50b0pTT04oKSkpXG4gICAgICAgICAgICA6IFt0aGlzLnR5cGUsIC4uLnRoaXMuI3BhcnRzLm1hcChwID0+IHAudG9KU09OKCkpXTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmICF0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXQudW5zaGlmdChbXSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW5kKCkgJiZcbiAgICAgICAgICAgICh0aGlzID09PSB0aGlzLiNyb290IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiYgdGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goe30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIGlmICh0aGlzLnR5cGUpIHJldHVybiAhIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpXG4gICAgICAgIGlmICghdGhpcy4jcGFyZW50Py5pc1N0YXJ0KCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnRJbmRleCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIEFIRUFEIG9mIHRoaXMgaXMgYSBuZWdhdGlvbiwgdGhlbiBpdCdzIHN0aWxsIHRoZSBcInN0YXJ0XCJcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuI3BhcmVudDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNwYXJlbnRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHAuI3BhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKCEocHAgaW5zdGFuY2VvZiBBU1QgJiYgcHAudHlwZSA9PT0gJyEnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNFbmQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50Py5pc0VuZCgpO1xuICAgICAgICAvLyBpZiBub3Qgcm9vdCwgaXQnbGwgYWx3YXlzIGhhdmUgYSBwYXJlbnRcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50SW5kZXggPT09IHBsIC0gMTtcbiAgICB9XG4gICAgY29weUluKHBhcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wdXNoKHBhcnQuY2xvbmUodGhpcykpO1xuICAgIH1cbiAgICBjbG9uZShwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgYyA9IG5ldyBBU1QodGhpcy50eXBlLCBwYXJlbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy4jcGFydHMpIHtcbiAgICAgICAgICAgIGMuY29weUluKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBzdGF0aWMgI3BhcnNlQVNUKHN0ciwgYXN0LCBwb3MsIG9wdCkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IGJyYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgbGV0IGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgIGlmIChhc3QudHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiBhIGV4dGdsb2IsIGFwcGVuZCB1bnRpbCB3ZSBmaW5kIGEgc3RhcnRcbiAgICAgICAgICAgIGxldCBpID0gcG9zO1xuICAgICAgICAgICAgbGV0IGFjYyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCBhY2N1bXVsYXRlIGVzY2FwZXMgYXQgdGhpcyBwb2ludCwgYnV0IHdlIGRvIGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwaW5nIHx8IGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9ICFlc2NhcGluZztcbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYnJhY2VTdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgfHwgYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5ub2V4dCAmJiBpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICBhc3QucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gbmV3IEFTVChjLCBhc3QpO1xuICAgICAgICAgICAgICAgICAgICBpID0gQVNULiNwYXJzZUFTVChzdHIsIGV4dCwgaSwgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iLCBwb3MgaXMgYXQgdGhlIChcbiAgICAgICAgLy8gZmluZCB0aGUgbmV4dCB8IG9yIClcbiAgICAgICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgICAgICBsZXQgcGFydCA9IG5ldyBBU1QobnVsbCwgYXN0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IGFjYyA9ICcnO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAvLyBzdGlsbCBhY2N1bXVsYXRlIGVzY2FwZXMgYXQgdGhpcyBwb2ludCwgYnV0IHdlIGRvIGlnbm9yZVxuICAgICAgICAgICAgLy8gc3RhcnRzIHRoYXQgYXJlIGVzY2FwZWRcbiAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9ICFlc2NhcGluZztcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbkJyYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgfHwgYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ10nICYmICEoaSA9PT0gYnJhY2VTdGFydCArIDIgJiYgYnJhY2VOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXh0Z2xvYlR5cGUoYykgJiYgc3RyLmNoYXJBdChpKSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gbmV3IEFTVChjLCBwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goZXh0KTtcbiAgICAgICAgICAgICAgICBpID0gQVNULiNwYXJzZUFTVChzdHIsIGV4dCwgaSwgb3B0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjYyA9PT0gJycgJiYgYXN0LiNwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LiNlbXB0eUV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGFzdC5wdXNoKC4uLnBhcnRzLCBwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuZmluaXNoZWQgZXh0Z2xvYlxuICAgICAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgaXQgd2FzIGEgbWFsZm9ybWVkIGV4dGdsb2IhIG5vdCBhbiBleHRnbG9iLCBidXRcbiAgICAgICAgLy8gbWF5YmUgc29tZXRoaW5nIGVsc2UgaW4gdGhlcmUuXG4gICAgICAgIGFzdC50eXBlID0gbnVsbDtcbiAgICAgICAgYXN0LiNoYXNNYWdpYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXN0LiNwYXJ0cyA9IFtzdHIuc3Vic3RyaW5nKHBvcyAtIDEpXTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tR2xvYihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYXN0ID0gbmV3IEFTVChudWxsLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICBBU1QuI3BhcnNlQVNUKHBhdHRlcm4sIGFzdCwgMCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpZiB0aGVyZSdzIG1hZ2ljLCBvciB0aGUgdW5lc2NhcGVkXG4gICAgLy8gc3RyaW5nIGlmIG5vdC5cbiAgICB0b01NUGF0dGVybigpIHtcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIHJvb3RcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLiNyb290KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3QudG9NTVBhdHRlcm4oKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgY29uc3QgZ2xvYiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgW3JlLCBib2R5LCBoYXNNYWdpYywgdWZsYWddID0gdGhpcy50b1JlZ0V4cFNvdXJjZSgpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBpbiBub2Nhc2UgbW9kZSwgYW5kIG5vdCBub2Nhc2VNYWdpY09ubHksIHRoZW4gd2UgZG9cbiAgICAgICAgLy8gc3RpbGwgbmVlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpZiB3ZSBoYXZlIHRvIGNhc2UtaW5zZW5zaXRpdmVseVxuICAgICAgICAvLyBtYXRjaCBjYXBpdGFsL2xvd2VyY2FzZSBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBhbnlNYWdpYyA9IGhhc01hZ2ljIHx8XG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyB8fFxuICAgICAgICAgICAgKHRoaXMuI29wdGlvbnMubm9jYXNlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI29wdGlvbnMubm9jYXNlTWFnaWNPbmx5ICYmXG4gICAgICAgICAgICAgICAgZ2xvYi50b1VwcGVyQ2FzZSgpICE9PSBnbG9iLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWFueU1hZ2ljKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9ICh0aGlzLiNvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnKSArICh1ZmxhZyA/ICd1JyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFJlZ0V4cChgXiR7cmV9JGAsIGZsYWdzKSwge1xuICAgICAgICAgICAgX3NyYzogcmUsXG4gICAgICAgICAgICBfZ2xvYjogZ2xvYixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgc3RyaW5nIG1hdGNoLCB0aGUgcmVnZXhwIHNvdXJjZSwgd2hldGhlciB0aGVyZSdzIG1hZ2ljXG4gICAgLy8gaW4gdGhlIHJlZ2V4cCAoc28gYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgcmVxdWlyZWQpIGFuZCB3aGV0aGVyIG9yXG4gICAgLy8gbm90IHRoZSB1ZmxhZyBpcyBuZWVkZWQgZm9yIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gKGZvciBwb3NpeCBjbGFzc2VzKVxuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgaW5qZWN0aW5nIHRoZSBzdGFydC9lbmQgYXQgdGhpcyBwb2ludCwganVzdCByZXR1cm5cbiAgICAvLyB0aGUgQk9EWSBvZiB0aGUgcmVnZXhwLCBhbG9uZyB3aXRoIHRoZSBzdGFydC9lbmQgcG9ydGlvbnMgc3VpdGFibGVcbiAgICAvLyBmb3IgYmluZGluZyB0aGUgc3RhcnQvZW5kIGluIGVpdGhlciBhIGpvaW5lZCBmdWxsLXBhdGggbWFrZVJlIGNvbnRleHRcbiAgICAvLyAod2hlcmUgd2UgYmluZCB0byAoXnwvKSwgb3IgYSBzdGFuZGFsb25lIG1hdGNoUGFydCBjb250ZXh0ICh3aGVyZVxuICAgIC8vIHdlIGJpbmQgdG8gXiwgYW5kIG5vdCAvKS4gIE90aGVyd2lzZSBzbGFzaGVzIGdldCBkdXBlZCFcbiAgICAvL1xuICAgIC8vIEluIHBhcnQtbWF0Y2hpbmcgbW9kZSwgdGhlIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiBeKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiBeXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogXig/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBub3QgaXNFbmQoKTogbm90aGluZ1xuICAgIC8vIC0gZWxzZTogJFxuICAgIC8vXG4gICAgLy8gSW4gZnVsbC1wYXRoIG1hdGNoaW5nIG1vZGUsIHdlIHB1dCB0aGUgc2xhc2ggYXQgdGhlIFNUQVJUIG9mIHRoZVxuICAgIC8vIHBhdHRlcm4sIHNvIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgZmlyc3QgcGF0dGVybjogc2FtZSBhcyBwYXJ0LW1hdGNoaW5nIG1vZGVcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0KCk6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAvKD8hXFwuXFwuPyg/OiR8LykpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAvXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogLyg/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBsYXN0IHBhdHRlcm4sIHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBlbHNlIG5vdGhpbmdcbiAgICAvL1xuICAgIC8vIEFsd2F5cyBwdXQgdGhlICg/OiR8Lykgb24gbmVnYXRlZCB0YWlscywgdGhvdWdoLCBiZWNhdXNlIHRoYXQgaGFzIHRvIGJlXG4gICAgLy8gdGhlcmUgdG8gYmluZCB0aGUgZW5kIG9mIHRoZSBuZWdhdGVkIHBhdHRlcm4gcG9ydGlvbiwgYW5kIGl0J3MgZWFzaWVyIHRvXG4gICAgLy8ganVzdCBzdGljayBpdCBpbiBub3cgcmF0aGVyIHRoYW4gdHJ5IHRvIGluamVjdCBpdCBsYXRlciBpbiB0aGUgbWlkZGxlIG9mXG4gICAgLy8gdGhlIHBhdHRlcm4uXG4gICAgLy9cbiAgICAvLyBXZSBjYW4ganVzdCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGVuZCwgYW5kIGxlYXZlIGl0IHVwIHRvIHRoZSBjYWxsZXJcbiAgICAvLyB0byBrbm93IHdoZXRoZXIgaXQncyBnb2luZyB0byBiZSB1c2VkIGpvaW5lZCBvciBpbiBwYXJ0cy5cbiAgICAvLyBBbmQsIGlmIHRoZSBzdGFydCBpcyBhZGp1c3RlZCBzbGlnaHRseSwgY2FuIGRvIHRoZSBzYW1lIHRoZXJlOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAoPzovfF4pKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAoPzovfF4pXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLilcbiAgICAvL1xuICAgIC8vIEJ1dCBpdCdzIGJldHRlciB0byBoYXZlIGEgc2ltcGxlciBiaW5kaW5nIHdpdGhvdXQgYSBjb25kaXRpb25hbCwgZm9yXG4gICAgLy8gcGVyZm9ybWFuY2UsIHNvIHByb2JhYmx5IGJldHRlciB0byByZXR1cm4gYm90aCBzdGFydCBvcHRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlbiB0aGUgY2FsbGVyIGp1c3QgaWdub3JlcyB0aGUgZW5kIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBwYXR0ZXJuLFxuICAgIC8vIGFuZCB0aGUgc3RhcnQgYWx3YXlzIGdldHMgYXBwbGllZC5cbiAgICAvL1xuICAgIC8vIEJ1dCB0aGF0J3MgYWx3YXlzIGdvaW5nIHRvIGJlICQgaWYgaXQncyB0aGUgZW5kaW5nIHBhdHRlcm4sIG9yIG5vdGhpbmcsXG4gICAgLy8gc28gdGhlIGNhbGxlciBjYW4ganVzdCBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gYnVpbGRpbmcuXG4gICAgLy9cbiAgICAvLyBTbyB0aGUgdG9kbyBpczpcbiAgICAvLyAtIGJldHRlciBkZXRlY3Qgd2hhdCBraW5kIG9mIHN0YXJ0IGlzIG5lZWRlZFxuICAgIC8vIC0gcmV0dXJuIGJvdGggZmxhdm9ycyBvZiBzdGFydGluZyBwYXR0ZXJuXG4gICAgLy8gLSBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gY3JlYXRpbmcgdGhlIGFjdHVhbCBSZWdFeHBcbiAgICAvL1xuICAgIC8vIEFoLCBidXQgd2FpdCwgbm8sIHRoYXQgYWxsIG9ubHkgYXBwbGllcyB0byB0aGUgcm9vdCB3aGVuIHRoZSBmaXJzdCBwYXR0ZXJuXG4gICAgLy8gaXMgbm90IGFuIGV4dGdsb2IuIElmIHRoZSBmaXJzdCBwYXR0ZXJuIElTIGFuIGV4dGdsb2IsIHRoZW4gd2UgbmVlZCBhbGxcbiAgICAvLyB0aGF0IGRvdCBwcmV2ZW50aW9uIGJpeiB0byBsaXZlIGluIHRoZSBleHRnbG9iIHBvcnRpb25zLCBiZWNhdXNlIGVnXG4gICAgLy8gKygqfC54KikgY2FuIG1hdGNoIC54eSBidXQgbm90IC55eC5cbiAgICAvL1xuICAgIC8vIFNvLCByZXR1cm4gdGhlIHR3byBmbGF2b3JzIGlmIGl0J3MgI3Jvb3QgYW5kIHRoZSBmaXJzdCBjaGlsZCBpcyBub3QgYW5cbiAgICAvLyBBU1QsIG90aGVyd2lzZSBsZWF2ZSBpdCB0byB0aGUgY2hpbGQgQVNUIHRvIGhhbmRsZSBpdCwgYW5kIHRoZXJlLFxuICAgIC8vIHVzZSB0aGUgKD86XnwvKSBzdHlsZSBvZiBzdGFydCBiaW5kaW5nLlxuICAgIC8vXG4gICAgLy8gRXZlbiBzaW1wbGlmaWVkIGZ1cnRoZXI6XG4gICAgLy8gLSBTaW5jZSB0aGUgc3RhcnQgZm9yIGEgam9pbiBpcyBlZyAvKD8hXFwuKSBhbmQgdGhlIHN0YXJ0IGZvciBhIHBhcnRcbiAgICAvLyBpcyBeKD8hXFwuKSwgd2UgY2FuIGp1c3QgcHJlcGVuZCAoPyFcXC4pIHRvIHRoZSBwYXR0ZXJuIChlaXRoZXIgcm9vdFxuICAgIC8vIG9yIHN0YXJ0IG9yIHdoYXRldmVyKSBhbmQgcHJlcGVuZCBeIG9yIC8gYXQgdGhlIFJlZ2V4cCBjb25zdHJ1Y3Rpb24uXG4gICAgdG9SZWdFeHBTb3VyY2UoYWxsb3dEb3QpIHtcbiAgICAgICAgY29uc3QgZG90ID0gYWxsb3dEb3QgPz8gISF0aGlzLiNvcHRpb25zLmRvdDtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLiNmaWxsTmVncygpO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9FbXB0eSA9IHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAgICAgLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmUsIF8sIGhhc01hZ2ljLCB1ZmxhZ10gPSB0eXBlb2YgcCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBBU1QuI3BhcnNlR2xvYihwLCB0aGlzLiNoYXNNYWdpYywgbm9FbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBwLnRvUmVnRXhwU291cmNlKGFsbG93RG90KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHRoaXMuI2hhc01hZ2ljIHx8IGhhc01hZ2ljO1xuICAgICAgICAgICAgICAgIHRoaXMuI3VmbGFnID0gdGhpcy4jdWZsYWcgfHwgdWZsYWc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcGFydHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHN0cmluZyB0aGF0IHdpbGwgbWF0Y2ggdGhlIHN0YXJ0IG9mIHRoZSBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHByb3RlY3QgYWdhaW5zdCBkb3RzIGFuZCBzdWNoLlxuICAgICAgICAgICAgICAgICAgICAvLyAnLicgYW5kICcuLicgY2Fubm90IG1hdGNoIHVubGVzcyB0aGUgcGF0dGVybiBpcyB0aGF0IGV4YWN0bHksXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQgc3RhcnRzIHdpdGggLiBvciBkb3Q6dHJ1ZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdFRyYXZBbGxvd2VkID0gdGhpcy4jcGFydHMubGVuZ3RoID09PSAxICYmIGp1c3REb3RzLmhhcyh0aGlzLiNwYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG90VHJhdkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcyA9IGFkZFBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYSBwb3NzaWJpbGl0eSBvZiBtYXRjaGluZyAuIG9yIC4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByZXZlbnQgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb1RyYXYgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvdHMgYXJlIGFsbG93ZWQsIGFuZCB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgIChkb3QgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDApKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC4nKSAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMikpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFxcLlxcLiwgYW5kIHRoZW4gWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyYy5zdGFydHNXaXRoKCdcXFxcLlxcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHByZXZlbnQgZG90cyBpZiBpdCBjYW4ndCBtYXRjaCBhIGRvdCwgb3IgaWYgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLXBhdHRlcm4gd2lsbCBiZSBwcmV2ZW50aW5nIGl0IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb0RvdCA9ICFkb3QgJiYgIWFsbG93RG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5lZWROb1RyYXYgPyBzdGFydE5vVHJhdmVyc2FsIDogbmVlZE5vRG90ID8gc3RhcnROb0RvdCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSBcImVuZCBvZiBwYXRoIHBvcnRpb25cIiBwYXR0ZXJuIHRvIG5lZ2F0aW9uIHRhaWxzXG4gICAgICAgICAgICBsZXQgZW5kID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC4jZmlsbGVkTmVncyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gJyg/OiR8XFxcXC8pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsID0gc3RhcnQgKyBzcmMgKyBlbmQ7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgICAgICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKShzcmMpLFxuICAgICAgICAgICAgICAgICh0aGlzLiNoYXNNYWdpYyA9ICEhdGhpcy4jaGFzTWFnaWMpLFxuICAgICAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgYm9keSAqdHdpY2UqIGlmIGl0J3MgYSByZXBlYXQgcGF0dGVyblxuICAgICAgICAvLyBhdCB0aGUgc3RhcnQsIG9uY2UgaW4gbm9kb3QgbW9kZSwgdGhlbiBhZ2FpbiBpbiBkb3QgbW9kZSwgc28gYVxuICAgICAgICAvLyBwYXR0ZXJuIGxpa2UgKig/KSBjYW4gbWF0Y2ggJ3gueSdcbiAgICAgICAgY29uc3QgcmVwZWF0ZWQgPSB0aGlzLnR5cGUgPT09ICcqJyB8fCB0aGlzLnR5cGUgPT09ICcrJztcbiAgICAgICAgLy8gc29tZSBraW5kIG9mIGV4dGdsb2JcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnR5cGUgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/Oic7XG4gICAgICAgIGxldCBib2R5ID0gdGhpcy4jcGFydHNUb1JlZ0V4cChkb3QpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpICYmICFib2R5ICYmIHRoaXMudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIGV4dGdsb2IsIGhhcyB0byBhdCBsZWFzdCBiZSAqc29tZXRoaW5nKiBwcmVzZW50LCBpZiBpdCdzXG4gICAgICAgICAgICAvLyB0aGUgZW50aXJlIHBhdGggcG9ydGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLiNwYXJ0cyA9IFtzXTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBbcywgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKHRoaXMudG9TdHJpbmcoKSksIGZhbHNlLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gWFhYIGFic3RyYWN0IG91dCB0aGlzIG1hcCBtZXRob2RcbiAgICAgICAgbGV0IGJvZHlEb3RBbGxvd2VkID0gIXJlcGVhdGVkIHx8IGFsbG93RG90IHx8IGRvdCB8fCAhc3RhcnROb0RvdFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiB0aGlzLiNwYXJ0c1RvUmVnRXhwKHRydWUpO1xuICAgICAgICBpZiAoYm9keURvdEFsbG93ZWQgPT09IGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHlEb3RBbGxvd2VkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBib2R5ID0gYCg/OiR7Ym9keX0pKD86JHtib2R5RG90QWxsb3dlZH0pKj9gO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIGVtcHR5ICEoKSBpcyBleGFjdGx5IGVxdWl2YWxlbnQgdG8gYSBzdGFyTm9FbXB0eVxuICAgICAgICBsZXQgZmluYWwgPSAnJztcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJyEnICYmIHRoaXMuI2VtcHR5RXh0KSB7XG4gICAgICAgICAgICBmaW5hbCA9ICh0aGlzLmlzU3RhcnQoKSAmJiAhZG90ID8gc3RhcnROb0RvdCA6ICcnKSArIHN0YXJOb0VtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xvc2UgPSB0aGlzLnR5cGUgPT09ICchJ1xuICAgICAgICAgICAgICAgID8gLy8gISgpIG11c3QgbWF0Y2ggc29tZXRoaW5nLGJ1dCAhKHgpIGNhbiBtYXRjaCAnJ1xuICAgICAgICAgICAgICAgICAgICAnKSknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmlzU3RhcnQoKSAmJiAhZG90ICYmICFhbGxvd0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhciArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJ0AnXG4gICAgICAgICAgICAgICAgICAgID8gJyknXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnPydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJyk/J1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICcrJyAmJiBib2R5RG90QWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICcqJyAmJiBib2R5RG90QWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGApP2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgKSR7dGhpcy50eXBlfWA7XG4gICAgICAgICAgICBmaW5hbCA9IHN0YXJ0ICsgYm9keSArIGNsb3NlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKShib2R5KSxcbiAgICAgICAgICAgICh0aGlzLiNoYXNNYWdpYyA9ICEhdGhpcy4jaGFzTWFnaWMpLFxuICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgIF07XG4gICAgfVxuICAgICNwYXJ0c1RvUmVnRXhwKGRvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFydHNcbiAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAvLyBleHRnbG9iIEFTVHMgc2hvdWxkIG9ubHkgY29udGFpbiBwYXJlbnQgQVNUc1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgdHlwZSBpbiBleHRnbG9iIGFzdD8/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgLy8gY2FuIGlnbm9yZSBoYXNNYWdpYywgYmVjYXVzZSBleHRnbG9icyBhcmUgYWxyZWFkeSBhbHdheXMgbWFnaWNcbiAgICAgICAgICAgIGNvbnN0IFtyZSwgXywgX2hhc01hZ2ljLCB1ZmxhZ10gPSBwLnRvUmVnRXhwU291cmNlKGRvdCk7XG4gICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihwID0+ICEodGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpKSB8fCAhIXApXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgIH1cbiAgICBzdGF0aWMgI3BhcnNlR2xvYihnbG9iLCBoYXNNYWdpYywgbm9FbXB0eSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmUgPSAnJztcbiAgICAgICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZSArPSAocmVTcGVjaWFscy5oYXMoYykgPyAnXFxcXCcgOiAnJykgKyBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBnbG9iLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gJ1xcXFxcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NyYywgbmVlZFVmbGFnLCBjb25zdW1lZCwgbWFnaWNdID0gKDAsIGJyYWNlX2V4cHJlc3Npb25zX2pzXzEucGFyc2VDbGFzcykoZ2xvYiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCBuZWVkVWZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY29uc3VtZWQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IG1hZ2ljO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vRW1wdHkgJiYgZ2xvYiA9PT0gJyonKVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyTm9FbXB0eTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHN0YXI7XG4gICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgIHJlICs9IHFtYXJrO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlICs9IHJlZ0V4cEVzY2FwZShjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3JlLCAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoZ2xvYiksICEhaGFzTWFnaWMsIHVmbGFnXTtcbiAgICB9XG59XG5leHBvcnRzLkFTVCA9IEFTVDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/ast.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/brace-expressions.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/brace-expressions.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9icmFjZS1leHByZXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixFQUFFLElBQUksR0FBRyxJQUFJLEdBQUc7QUFDdkMsdUJBQXVCLEVBQUUsSUFBSSxHQUFHO0FBQ2hDO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEVBQUUsSUFBSSxFQUFFO0FBQy9CLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixFQUFFO0FBQ3pCLHVCQUF1QixFQUFFO0FBQ3pCLHVCQUF1QixFQUFFO0FBQ3pCLHVCQUF1QixHQUFHO0FBQzFCLHNCQUFzQixFQUFFLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2JyYWNlLWV4cHJlc3Npb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHJhbnNsYXRlIHRoZSB2YXJpb3VzIHBvc2l4IGNoYXJhY3RlciBjbGFzc2VzIGludG8gdW5pY29kZSBwcm9wZXJ0aWVzXG4vLyB0aGlzIHdvcmtzIGFjcm9zcyBhbGwgdW5pY29kZSBsb2NhbGVzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQ2xhc3MgPSB2b2lkIDA7XG4vLyB7IDxwb3NpeCBjbGFzcz46IFs8dHJhbnNsYXRpb24+LCAvdSBmbGFnIHJlcXVpcmVkLCBuZWdhdGVkXVxuY29uc3QgcG9zaXhDbGFzc2VzID0ge1xuICAgICdbOmFsbnVtOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6YWxwaGE6XSc6IFsnXFxcXHB7TH1cXFxccHtObH0nLCB0cnVlXSxcbiAgICAnWzphc2NpaTpdJzogWydcXFxceCcgKyAnMDAtXFxcXHgnICsgJzdmJywgZmFsc2VdLFxuICAgICdbOmJsYW5rOl0nOiBbJ1xcXFxwe1pzfVxcXFx0JywgdHJ1ZV0sXG4gICAgJ1s6Y250cmw6XSc6IFsnXFxcXHB7Q2N9JywgdHJ1ZV0sXG4gICAgJ1s6ZGlnaXQ6XSc6IFsnXFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6Z3JhcGg6XSc6IFsnXFxcXHB7Wn1cXFxccHtDfScsIHRydWUsIHRydWVdLFxuICAgICdbOmxvd2VyOl0nOiBbJ1xcXFxwe0xsfScsIHRydWVdLFxuICAgICdbOnByaW50Ol0nOiBbJ1xcXFxwe0N9JywgdHJ1ZV0sXG4gICAgJ1s6cHVuY3Q6XSc6IFsnXFxcXHB7UH0nLCB0cnVlXSxcbiAgICAnWzpzcGFjZTpdJzogWydcXFxccHtafVxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLCB0cnVlXSxcbiAgICAnWzp1cHBlcjpdJzogWydcXFxccHtMdX0nLCB0cnVlXSxcbiAgICAnWzp3b3JkOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9XFxcXHB7UGN9JywgdHJ1ZV0sXG4gICAgJ1s6eGRpZ2l0Ol0nOiBbJ0EtRmEtZjAtOScsIGZhbHNlXSxcbn07XG4vLyBvbmx5IG5lZWQgdG8gZXNjYXBlIGEgZmV3IHRoaW5ncyBpbnNpZGUgb2YgYnJhY2UgZXhwcmVzc2lvbnNcbi8vIGVzY2FwZXM6IFsgXFwgXSAtXG5jb25zdCBicmFjZUVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXC1dL2csICdcXFxcJCYnKTtcbi8vIGVzY2FwZSBhbGwgcmVnZXhwIG1hZ2ljIGNoYXJhY3RlcnNcbmNvbnN0IHJlZ2V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBldmVyeXRoaW5nIGhhcyBhbHJlYWR5IGJlZW4gZXNjYXBlZCwgd2UganVzdCBoYXZlIHRvIGpvaW5cbmNvbnN0IHJhbmdlc1RvU3RyaW5nID0gKHJhbmdlcykgPT4gcmFuZ2VzLmpvaW4oJycpO1xuLy8gdGFrZXMgYSBnbG9iIHN0cmluZyBhdCBhIHBvc2l4IGJyYWNlIGV4cHJlc3Npb24sIGFuZCByZXR1cm5zXG4vLyBhbiBlcXVpdmFsZW50IHJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2UsIGFuZCBib29sZWFuIGluZGljYXRpbmdcbi8vIHdoZXRoZXIgdGhlIC91IGZsYWcgbmVlZHMgdG8gYmUgYXBwbGllZCwgYW5kIHRoZSBudW1iZXIgb2YgY2hhcnNcbi8vIGNvbnN1bWVkIHRvIHBhcnNlIHRoZSBjaGFyYWN0ZXIgY2xhc3MuXG4vLyBUaGlzIGFsc28gcmVtb3ZlcyBvdXQgb2Ygb3JkZXIgcmFuZ2VzLCBhbmQgcmV0dXJucyAoJC4pIGlmIHRoZVxuLy8gZW50aXJlIGNsYXNzIGp1c3Qgbm8gZ29vZC5cbmNvbnN0IHBhcnNlQ2xhc3MgPSAoZ2xvYiwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbjtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoZ2xvYi5jaGFyQXQocG9zKSAhPT0gJ1snKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGluIGEgYnJhY2UgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IG5lZ3MgPSBbXTtcbiAgICBsZXQgaSA9IHBvcyArIDE7XG4gICAgbGV0IHNhd1N0YXJ0ID0gZmFsc2U7XG4gICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgIGxldCBlbmRQb3MgPSBwb3M7XG4gICAgbGV0IHJhbmdlU3RhcnQgPSAnJztcbiAgICBXSElMRTogd2hpbGUgKGkgPCBnbG9iLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gZ2xvYi5jaGFyQXQoaSk7XG4gICAgICAgIGlmICgoYyA9PT0gJyEnIHx8IGMgPT09ICdeJykgJiYgaSA9PT0gcG9zICsgMSkge1xuICAgICAgICAgICAgbmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnXScgJiYgc2F3U3RhcnQgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICBlbmRQb3MgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNhd1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKCFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVkIFxcIGNoYXIsIGZhbGwgdGhyb3VnaCBhbmQgdHJlYXQgbGlrZSBub3JtYWwgY2hhclxuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnWycgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYSBwb3NpeCBjbGFzcywgYSBjb2xsYXRpb24gZXF1aXZhbGVudCwgb3IganVzdCBhIFtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NscywgW3VuaXAsIHUsIG5lZ11dIG9mIE9iamVjdC5lbnRyaWVzKHBvc2l4Q2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKGNscywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCwgW2EtW10gaXMgZmluZSwgYnV0IG5vdCBbYS1bOmFscGhhXV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpICs9IGNscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdzLnB1c2godW5pcCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IHU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIFdISUxFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgaXQncyBqdXN0IGEgbm9ybWFsIGNoYXJhY3RlciwgZWZmZWN0aXZlbHlcbiAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHRoaXMgcmFuZ2UgYXdheSBpZiBpdCdzIG5vdCB2YWxpZCwgYnV0IG90aGVyc1xuICAgICAgICAgICAgLy8gY2FuIHN0aWxsIG1hdGNoLlxuICAgICAgICAgICAgaWYgKGMgPiByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUocmFuZ2VTdGFydCkgKyAnLScgKyBicmFjZUVzY2FwZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2VTdGFydCA9ICcnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IG1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIHJhbmdlLlxuICAgICAgICAvLyBjYW4gYmUgZWl0aGVyIGMtZCBvciBjLV0gb3IgYzxtb3JlLi4uPl0gb3IgY10gYXQgdGhpcyBwb2ludFxuICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKCctXScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYyArICctJykpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IGM7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgdGhlIHN0YXJ0IG9mIGEgcmFuZ2UsIGp1c3QgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoZW5kUG9zIDwgaSkge1xuICAgICAgICAvLyBkaWRuJ3Qgc2VlIHRoZSBlbmQgb2YgdGhlIGNsYXNzLCBub3QgYSB2YWxpZCBjbGFzcyxcbiAgICAgICAgLy8gYnV0IG1pZ2h0IHN0aWxsIGJlIHZhbGlkIGFzIGEgbGl0ZXJhbCBtYXRjaC5cbiAgICAgICAgcmV0dXJuIFsnJywgZmFsc2UsIDAsIGZhbHNlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG5vIHJhbmdlcyBhbmQgbm8gbmVnYXRlcywgdGhlbiB3ZSBoYXZlIGEgcmFuZ2UgdGhhdFxuICAgIC8vIGNhbm5vdCBwb3NzaWJseSBtYXRjaCBhbnl0aGluZywgYW5kIHRoYXQgcG9pc29ucyB0aGUgd2hvbGUgZ2xvYlxuICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiAhbmVncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsnJC4nLCBmYWxzZSwgZ2xvYi5sZW5ndGggLSBwb3MsIHRydWVdO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3Qgb25lIHBvc2l0aXZlIHJhbmdlLCBhbmQgaXQncyBhIHNpbmdsZSBjaGFyYWN0ZXIsIHRoZW4gdGhhdCdzXG4gICAgLy8gbm90IGFjdHVhbGx5IGEgbWFnaWMgcGF0dGVybiwgaXQncyBqdXN0IHRoYXQgb25lIGxpdGVyYWwgY2hhcmFjdGVyLlxuICAgIC8vIHdlIHNob3VsZCBub3QgdHJlYXQgdGhhdCBhcyBcIm1hZ2ljXCIsIHdlIHNob3VsZCBqdXN0IHJldHVybiB0aGUgbGl0ZXJhbFxuICAgIC8vIGNoYXJhY3Rlci4gW19dIGlzIGEgcGVyZmVjdGx5IHZhbGlkIHdheSB0byBlc2NhcGUgZ2xvYiBtYWdpYyBjaGFycy5cbiAgICBpZiAobmVncy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgcmFuZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAvXlxcXFw/LiQvLnRlc3QocmFuZ2VzWzBdKSAmJlxuICAgICAgICAhbmVnYXRlKSB7XG4gICAgICAgIGNvbnN0IHIgPSByYW5nZXNbMF0ubGVuZ3RoID09PSAyID8gcmFuZ2VzWzBdLnNsaWNlKC0xKSA6IHJhbmdlc1swXTtcbiAgICAgICAgcmV0dXJuIFtyZWdleHBFc2NhcGUociksIGZhbHNlLCBlbmRQb3MgLSBwb3MsIGZhbHNlXTtcbiAgICB9XG4gICAgY29uc3Qgc3JhbmdlcyA9ICdbJyArIChuZWdhdGUgPyAnXicgOiAnJykgKyByYW5nZXNUb1N0cmluZyhyYW5nZXMpICsgJ10nO1xuICAgIGNvbnN0IHNuZWdzID0gJ1snICsgKG5lZ2F0ZSA/ICcnIDogJ14nKSArIHJhbmdlc1RvU3RyaW5nKG5lZ3MpICsgJ10nO1xuICAgIGNvbnN0IGNvbWIgPSByYW5nZXMubGVuZ3RoICYmIG5lZ3MubGVuZ3RoXG4gICAgICAgID8gJygnICsgc3JhbmdlcyArICd8JyArIHNuZWdzICsgJyknXG4gICAgICAgIDogcmFuZ2VzLmxlbmd0aFxuICAgICAgICAgICAgPyBzcmFuZ2VzXG4gICAgICAgICAgICA6IHNuZWdzO1xuICAgIHJldHVybiBbY29tYiwgdWZsYWcsIGVuZFBvcyAtIHBvcywgdHJ1ZV07XG59O1xuZXhwb3J0cy5wYXJzZUNsYXNzID0gcGFyc2VDbGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyYWNlLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/escape.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/escape.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9lc2NhcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9lc2NhcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzY2FwZSA9IHZvaWQgMDtcbi8qKlxuICogRXNjYXBlIGFsbCBtYWdpYyBjaGFyYWN0ZXJzIGluIGEgZ2xvYiBwYXR0ZXJuLlxuICpcbiAqIElmIHRoZSB7QGxpbmsgd2luZG93c1BhdGhzTm9Fc2NhcGUgfCBHbG9iT3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZX1cbiAqIG9wdGlvbiBpcyB1c2VkLCB0aGVuIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgaW4gYFtdYCwgYmVjYXVzZVxuICogYSBtYWdpYyBjaGFyYWN0ZXIgd3JhcHBlZCBpbiBhIGNoYXJhY3RlciBjbGFzcyBjYW4gb25seSBiZSBzYXRpc2ZpZWQgYnlcbiAqIHRoYXQgZXhhY3QgY2hhcmFjdGVyLiAgSW4gdGhpcyBtb2RlLCBgXFxgIGlzIF9ub3RfIGVzY2FwZWQsIGJlY2F1c2UgaXQgaXNcbiAqIG5vdCBpbnRlcnByZXRlZCBhcyBhIG1hZ2ljIGNoYXJhY3RlciwgYnV0IGluc3RlYWQgYXMgYSBwYXRoIHNlcGFyYXRvci5cbiAqL1xuY29uc3QgZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgK0AhIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZSBwYXJlbnNcbiAgICAvLyB0aGF0IG1ha2UgdGhvc2UgbWFnaWMsIGFuZCBlc2NhcGluZyAhIGFzIFshXSBpc24ndCB2YWxpZCxcbiAgICAvLyBiZWNhdXNlIFshXV0gaXMgYSB2YWxpZCBnbG9iIGNsYXNzIG1lYW5pbmcgbm90ICddJy5cbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1s/KigpW1xcXV0vZywgJ1skJl0nKVxuICAgICAgICA6IHMucmVwbGFjZSgvWz8qKClbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/escape.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js":
/*!************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"(rsc)/../node_modules/archiver-utils/node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = __webpack_require__(/*! ./ast.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGlCQUFpQjtBQUNuTiwwQ0FBMEMsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDbkUsa0NBQWtDLG1CQUFPLENBQUMsb0lBQTJCO0FBQ3JFLGlCQUFpQixtQkFBTyxDQUFDLGtHQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFhO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLDRHQUFlO0FBQzdDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsY0FBYztBQUNkLHdCQUF3QjtBQUN4QixzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEM7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUssSUFBSTtBQUNULEtBQUssR0FBRztBQUNSLEtBQUssS0FBSztBQUNWLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDZixLQUFLLElBQUksRUFBRSxJQUFJO0FBQ2Y7QUFDQTtBQUNBLEtBQUssSUFBSSxPQUFPLElBQUk7QUFDcEIsS0FBSyxFQUFFLE9BQU8sRUFBRTtBQUNoQiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEsOEJBQThCO0FBQ3RDO0FBQ0EsUUFBUSxxQ0FBcUM7QUFDN0M7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0Esd0VBQXdFLG9CQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrR0FBVTtBQUNqQyx1Q0FBc0MsRUFBRSxxQ0FBcUMsd0JBQXdCLEVBQUM7QUFDdEcsa0JBQWtCLG1CQUFPLENBQUMsd0dBQWE7QUFDdkMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLG9CQUFvQixtQkFBTyxDQUFDLDRHQUFlO0FBQzNDLDRDQUEyQyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUNySDtBQUNBLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuZXNjYXBlID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLkFTVCA9IGV4cG9ydHMuTWluaW1hdGNoID0gZXhwb3J0cy5tYXRjaCA9IGV4cG9ydHMubWFrZVJlID0gZXhwb3J0cy5icmFjZUV4cGFuZCA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLmZpbHRlciA9IGV4cG9ydHMuR0xPQlNUQVIgPSBleHBvcnRzLnNlcCA9IGV4cG9ydHMubWluaW1hdGNoID0gdm9pZCAwO1xuY29uc3QgYnJhY2VfZXhwYW5zaW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJyYWNlLWV4cGFuc2lvblwiKSk7XG5jb25zdCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4vYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanNcIik7XG5jb25zdCBhc3RfanNfMSA9IHJlcXVpcmUoXCIuL2FzdC5qc1wiKTtcbmNvbnN0IGVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vZXNjYXBlLmpzXCIpO1xuY29uc3QgdW5lc2NhcGVfanNfMSA9IHJlcXVpcmUoXCIuL3VuZXNjYXBlLmpzXCIpO1xuY29uc3QgbWluaW1hdGNoID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICgwLCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xLmFzc2VydFZhbGlkUGF0dGVybikocGF0dGVybik7XG4gICAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocCk7XG59O1xuZXhwb3J0cy5taW5pbWF0Y2ggPSBtaW5pbWF0Y2g7XG4vLyBPcHRpbWl6ZWQgY2hlY2tpbmcgZm9yIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm5zLlxuY29uc3Qgc3RhckRvdEV4dFJFID0gL15cXCorKFteK0AhP1xcKlxcW1xcKF0qKSQvO1xuY29uc3Qgc3RhckRvdEV4dFRlc3QgPSAoZXh0KSA9PiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0RG90ID0gKGV4dCkgPT4gKGYpID0+IGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90ID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdFN0YXJSRSA9IC9eXFwqK1xcLlxcKiskLztcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdCA9IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0RG90ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IGRvdFN0YXJSRSA9IC9eXFwuXFwqKyQvO1xuY29uc3QgZG90U3RhclRlc3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyUkUgPSAvXlxcKiskLztcbmNvbnN0IHN0YXJUZXN0ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJUZXN0RG90ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xuY29uc3QgcW1hcmtzUkUgPSAvXlxcPysoW14rQCE/XFwqXFxbXFwoXSopPyQvO1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZSA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlRG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3REb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHREb3QgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG59O1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/ICh0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fXykgfHxcbiAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ3Bvc2l4Jyk7XG5jb25zdCBwYXRoID0ge1xuICAgIHdpbjMyOiB7IHNlcDogJ1xcXFwnIH0sXG4gICAgcG9zaXg6IHsgc2VwOiAnLycgfSxcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0cy5zZXAgPSBkZWZhdWx0UGxhdGZvcm0gPT09ICd3aW4zMicgPyBwYXRoLndpbjMyLnNlcCA6IHBhdGgucG9zaXguc2VwO1xuZXhwb3J0cy5taW5pbWF0Y2guc2VwID0gZXhwb3J0cy5zZXA7XG5leHBvcnRzLkdMT0JTVEFSID0gU3ltYm9sKCdnbG9ic3RhciAqKicpO1xuZXhwb3J0cy5taW5pbWF0Y2guR0xPQlNUQVIgPSBleHBvcnRzLkdMT0JTVEFSO1xuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbmNvbnN0IHFtYXJrID0gJ1teL10nO1xuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbmNvbnN0IHN0YXIgPSBxbWFyayArICcqPyc7XG4vLyAqKiB3aGVuIGRvdHMgYXJlIGFsbG93ZWQuICBBbnl0aGluZyBnb2VzLCBleGNlcHQgLi4gYW5kIC5cbi8vIG5vdCAoXiBvciAvIGZvbGxvd2VkIGJ5IG9uZSBvciB0d28gZG90cyBmb2xsb3dlZCBieSAkIG9yIC8pLFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pKD86XFxcXC57MSwyfSkoJHxcXFxcLykpLikqPyc7XG4vLyBub3QgYSBeIG9yIC8gZm9sbG93ZWQgYnkgYSBkb3QsXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcL3xeKVxcXFwuKS4pKj8nO1xuY29uc3QgZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gKHApID0+ICgwLCBleHBvcnRzLm1pbmltYXRjaCkocCwgcGF0dGVybiwgb3B0aW9ucyk7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMubWluaW1hdGNoLmZpbHRlciA9IGV4cG9ydHMuZmlsdGVyO1xuY29uc3QgZXh0ID0gKGEsIGIgPSB7fSkgPT4gT2JqZWN0LmFzc2lnbih7fSwgYSwgYik7XG5jb25zdCBkZWZhdWx0cyA9IChkZWYpID0+IHtcbiAgICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWluaW1hdGNoO1xuICAgIH1cbiAgICBjb25zdCBvcmlnID0gZXhwb3J0cy5taW5pbWF0Y2g7XG4gICAgY29uc3QgbSA9IChwLCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG0sIHtcbiAgICAgICAgTWluaW1hdGNoOiBjbGFzcyBNaW5pbWF0Y2ggZXh0ZW5kcyBvcmlnLk1pbmltYXRjaCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICBzdXBlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0aWMgZGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEFTVDogY2xhc3MgQVNUIGV4dGVuZHMgb3JpZy5BU1Qge1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHR5cGUsIHBhcmVudCwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHN0YXRpYyBmcm9tR2xvYihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZy5BU1QuZnJvbUdsb2IocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmVzY2FwZTogKHMsIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy51bmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGVzY2FwZTogKHMsIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5lc2NhcGUocywgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBmaWx0ZXI6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZGVmYXVsdHM6IChvcHRpb25zKSA9PiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgbWFrZVJlOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGJyYWNlRXhwYW5kOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgbWF0Y2g6IChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBzZXA6IG9yaWcuc2VwLFxuICAgICAgICBHTE9CU1RBUjogZXhwb3J0cy5HTE9CU1RBUixcbiAgICB9KTtcbn07XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLm1pbmltYXRjaC5kZWZhdWx0cyA9IGV4cG9ydHMuZGVmYXVsdHM7XG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbmNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICgwLCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xLmFzc2VydFZhbGlkUGF0dGVybikocGF0dGVybik7XG4gICAgLy8gVGhhbmtzIHRvIFlldGluZyBMaSA8aHR0cHM6Ly9naXRodWIuY29tL3lldGluZ2xpPiBmb3JcbiAgICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICAgIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICAgICAgcmV0dXJuIFtwYXR0ZXJuXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBicmFjZV9leHBhbnNpb25fMS5kZWZhdWx0KShwYXR0ZXJuKTtcbn07XG5leHBvcnRzLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmQ7XG5leHBvcnRzLm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGV4cG9ydHMuYnJhY2VFeHBhbmQ7XG4vLyBwYXJzZSBhIGNvbXBvbmVudCBvZiB0aGUgZXhwYW5kZWQgc2V0LlxuLy8gQXQgdGhpcyBwb2ludCwgbm8gcGF0dGVybiBtYXkgY29udGFpbiBcIi9cIiBpbiBpdFxuLy8gc28gd2UncmUgZ29pbmcgdG8gcmV0dXJuIGEgMmQgYXJyYXksIHdoZXJlIGVhY2ggZW50cnkgaXMgdGhlIGZ1bGxcbi8vIHBhdHRlcm4sIHNwbGl0IG9uICcvJywgYW5kIHRoZW4gdHVybmVkIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4vLyBBIHJlZ2V4cCBpcyBtYWRlIGF0IHRoZSBlbmQgd2hpY2ggam9pbnMgZWFjaCBhcnJheSB3aXRoIGFuXG4vLyBlc2NhcGVkIC8sIGFuZCBhbm90aGVyIGZ1bGwgb25lIHdoaWNoIGpvaW5zIGVhY2ggcmVnZXhwIHdpdGggfC5cbi8vXG4vLyBGb2xsb3dpbmcgdGhlIGxlYWQgb2YgQmFzaCA0LjEsIG5vdGUgdGhhdCBcIioqXCIgb25seSBoYXMgc3BlY2lhbCBtZWFuaW5nXG4vLyB3aGVuIGl0IGlzIHRoZSAqb25seSogdGhpbmcgaW4gYSBwYXRoIHBvcnRpb24uICBPdGhlcndpc2UsIGFueSBzZXJpZXNcbi8vIG9mICogaXMgZXF1aXZhbGVudCB0byBhIHNpbmdsZSAqLiAgR2xvYnN0YXIgYmVoYXZpb3IgaXMgZW5hYmxlZCBieVxuLy8gZGVmYXVsdCwgYW5kIGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nIG9wdGlvbnMubm9nbG9ic3Rhci5cbmNvbnN0IG1ha2VSZSA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWFrZVJlKCk7XG5leHBvcnRzLm1ha2VSZSA9IG1ha2VSZTtcbmV4cG9ydHMubWluaW1hdGNoLm1ha2VSZSA9IGV4cG9ydHMubWFrZVJlO1xuY29uc3QgbWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmID0+IG1tLm1hdGNoKGYpKTtcbiAgICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QucHVzaChwYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuZXhwb3J0cy5taW5pbWF0Y2gubWF0Y2ggPSBleHBvcnRzLm1hdGNoO1xuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmNvbnN0IGdsb2JNYWdpYyA9IC9bPypdfFsrQCFdXFwoLio/XFwpfFxcW3xcXF0vO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbmNsYXNzIE1pbmltYXRjaCB7XG4gICAgb3B0aW9ucztcbiAgICBzZXQ7XG4gICAgcGF0dGVybjtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICBub25lZ2F0ZTtcbiAgICBuZWdhdGU7XG4gICAgY29tbWVudDtcbiAgICBlbXB0eTtcbiAgICBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICBwYXJ0aWFsO1xuICAgIGdsb2JTZXQ7XG4gICAgZ2xvYlBhcnRzO1xuICAgIG5vY2FzZTtcbiAgICBpc1dpbmRvd3M7XG4gICAgcGxhdGZvcm07XG4gICAgd2luZG93c05vTWFnaWNSb290O1xuICAgIHJlZ2V4cDtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBvcHRpb25zLnBsYXRmb3JtIHx8IGRlZmF1bHRQbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5pc1dpbmRvd3MgPSB0aGlzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlID1cbiAgICAgICAgICAgICEhb3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fCBvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSA9PT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLnBhdHRlcm4ucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMgPSAhIW9wdGlvbnMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXM7XG4gICAgICAgIHRoaXMucmVnZXhwID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub25lZ2F0ZSA9ICEhb3B0aW9ucy5ub25lZ2F0ZTtcbiAgICAgICAgdGhpcy5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsID0gISFvcHRpb25zLnBhcnRpYWw7XG4gICAgICAgIHRoaXMubm9jYXNlID0gISF0aGlzLm9wdGlvbnMubm9jYXNlO1xuICAgICAgICB0aGlzLndpbmRvd3NOb01hZ2ljUm9vdCA9XG4gICAgICAgICAgICBvcHRpb25zLndpbmRvd3NOb01hZ2ljUm9vdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLndpbmRvd3NOb01hZ2ljUm9vdFxuICAgICAgICAgICAgICAgIDogISEodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy5ub2Nhc2UpO1xuICAgICAgICB0aGlzLmdsb2JTZXQgPSBbXTtcbiAgICAgICAgdGhpcy5nbG9iUGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXQgPSBbXTtcbiAgICAgICAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICAgICAgICB0aGlzLm1ha2UoKTtcbiAgICB9XG4gICAgaGFzTWFnaWMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWFnaWNhbEJyYWNlcyAmJiB0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5fKSB7IH1cbiAgICBtYWtlKCkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBlbXB0eSBwYXR0ZXJucyBhbmQgY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICAgICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgICAgdGhpcy5lbXB0eSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gICAgICAgIHRoaXMucGFyc2VOZWdhdGUoKTtcbiAgICAgICAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFsuLi5uZXcgU2V0KHRoaXMuYnJhY2VFeHBhbmQoKSldO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyA9ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLmdsb2JTZXQpO1xuICAgICAgICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2ZcbiAgICAgICAgLy8gcGF0aC1wb3J0aW9uIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAgICAgICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gICAgICAgIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICAgICAgICAvL1xuICAgICAgICAvLyBGaXJzdCwgd2UgcHJlcHJvY2VzcyB0byBtYWtlIHRoZSBnbG9iIHBhdHRlcm4gc2V0cyBhIGJpdCBzaW1wbGVyXG4gICAgICAgIC8vIGFuZCBkZWR1cGVkLiAgVGhlcmUgYXJlIHNvbWUgcGVyZi1raWxsaW5nIHBhdHRlcm5zIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgIC8vIHByb2JsZW1zIHdpdGggYSBnbG9iIHdhbGssIGJ1dCB3ZSBjYW4gc2ltcGxpZnkgdGhlbSBkb3duIGEgYml0LlxuICAgICAgICBjb25zdCByYXdHbG9iUGFydHMgPSB0aGlzLmdsb2JTZXQubWFwKHMgPT4gdGhpcy5zbGFzaFNwbGl0KHMpKTtcbiAgICAgICAgdGhpcy5nbG9iUGFydHMgPSB0aGlzLnByZXByb2Nlc3MocmF3R2xvYlBhcnRzKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlBhcnRzKTtcbiAgICAgICAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5nbG9iUGFydHMubWFwKChzLCBfLCBfXykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzICYmIHRoaXMud2luZG93c05vTWFnaWNSb290KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBhIGRyaXZlIG9yIHVuYyBwYXRoLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVU5DID0gc1swXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgc1sxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNbMl0gPT09ICc/JyB8fCAhZ2xvYk1hZ2ljLnRlc3Qoc1syXSkpICYmXG4gICAgICAgICAgICAgICAgICAgICFnbG9iTWFnaWMudGVzdChzWzNdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RyaXZlID0gL15bYS16XTovaS50ZXN0KHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1VOQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnMuc2xpY2UoMCwgNCksIC4uLnMuc2xpY2UoNCkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRHJpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzWzBdLCAuLi5zLnNsaWNlKDEpLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KTtcbiAgICAgICAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gICAgICAgIHRoaXMuc2V0ID0gc2V0LmZpbHRlcihzID0+IHMuaW5kZXhPZihmYWxzZSkgPT09IC0xKTtcbiAgICAgICAgLy8gZG8gbm90IHRyZWF0IHRoZSA/IGluIFVOQyBwYXRocyBhcyBtYWdpY1xuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5zZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYlBhcnRzW2ldWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBbM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QocFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9ICc/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuc2V0KTtcbiAgICB9XG4gICAgLy8gdmFyaW91cyB0cmFuc2Zvcm1zIHRvIGVxdWl2YWxlbnQgcGF0dGVybiBzZXRzIHRoYXQgYXJlXG4gICAgLy8gZmFzdGVyIHRvIHByb2Nlc3MgaW4gYSBmaWxlc3lzdGVtIHdhbGsuICBUaGUgZ29hbCBpcyB0b1xuICAgIC8vIGVsaW1pbmF0ZSB3aGF0IHdlIGNhbiwgYW5kIHB1c2ggYWxsICoqIHBhdHRlcm5zIGFzIGZhclxuICAgIC8vIHRvIHRoZSByaWdodCBhcyBwb3NzaWJsZSwgZXZlbiBpZiBpdCBpbmNyZWFzZXMgdGhlIG51bWJlclxuICAgIC8vIG9mIHBhdHRlcm5zIHRoYXQgd2UgaGF2ZSB0byBwcm9jZXNzLlxuICAgIHByZXByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBpbiBnbG9ic3RhciBtb2RlLCB0aGVuIHR1cm4gYWxsICoqIGludG8gKlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnbG9iUGFydHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JQYXJ0c1tpXVtqXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2ldW2pdID0gJyonO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBhZ2dyZXNzaXZlIG9wdGltaXphdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2YgZnMgd2Fsa2luZ1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5maXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5zZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBqdXN0IGJhc2ljIG9wdGltaXphdGlvbnMgdG8gcmVtb3ZlIHNvbWUgLi4gcGFydHNcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMubGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8ganVzdCBjb2xsYXBzZSBtdWx0aXBsZSAqKiBwb3J0aW9ucyBpbnRvIG9uZVxuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5hZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8ganVzdCBnZXQgcmlkIG9mIGFkamFzY2VudCAqKiBwb3J0aW9uc1xuICAgIGFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKSB7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMubWFwKHBhcnRzID0+IHtcbiAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZ3MgPSBwYXJ0cy5pbmRleE9mKCcqKicsIGdzICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBncztcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFydHNbaSArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncywgaSAtIGdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBnZXQgcmlkIG9mIGFkamFzY2VudCAqKiBhbmQgcmVzb2x2ZSAuLiBwb3J0aW9uc1xuICAgIGxldmVsT25lT3B0aW1pemUoZ2xvYlBhcnRzKSB7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMubWFwKHBhcnRzID0+IHtcbiAgICAgICAgICAgIHBhcnRzID0gcGFydHMucmVkdWNlKChzZXQsIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gc2V0W3NldC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJyoqJyAmJiBwcmV2ID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09ICcuLicgJiYgcHJldiAhPT0gJy4nICYmIHByZXYgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXZlbFR3b0ZpbGVPcHRpbWl6ZShwYXJ0cykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHRoaXMuc2xhc2hTcGxpdChwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNxdWVlemUgb3V0IFVOQyBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiBwID09PSAnJyAmJiBwYXJ0c1swXSA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09ICcuJyB8fCBwID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGRkID0gcGFydHMuaW5kZXhPZignLi4nLCBkZCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tkZCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGRkIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGRkIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRTb21ldGhpbmcpO1xuICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gWycnXSA6IHBhcnRzO1xuICAgIH1cbiAgICAvLyBGaXJzdCBwaGFzZTogc2luZ2xlLXBhdHRlcm4gcHJvY2Vzc2luZ1xuICAgIC8vIDxwcmU+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxyZXN0PiBpcyAxIG9yIG1vcmUgcG9ydGlvbnNcbiAgICAvLyA8cD4gaXMgYW55IHBvcnRpb24gb3RoZXIgdGhhbiAuLCAuLiwgJycsIG9yICoqXG4gICAgLy8gPGU+IGlzIC4gb3IgJydcbiAgICAvL1xuICAgIC8vICoqLy4uIGlzICpicnV0YWwqIGZvciBmaWxlc3lzdGVtIHdhbGtpbmcgcGVyZm9ybWFuY2UsIGJlY2F1c2VcbiAgICAvLyBpdCBlZmZlY3RpdmVseSByZXNldHMgdGhlIHJlY3Vyc2l2ZSB3YWxrIGVhY2ggdGltZSBpdCBvY2N1cnMsXG4gICAgLy8gYW5kICoqIGNhbm5vdCBiZSByZWR1Y2VkIG91dCBieSBhIC4uIHBhdHRlcm4gcGFydCBsaWtlIGEgcmVnZXhwXG4gICAgLy8gb3IgbW9zdCBzdHJpbmdzIChvdGhlciB0aGFuIC4uLCAuLCBhbmQgJycpIGNhbiBiZS5cbiAgICAvL1xuICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gKiovKiovPHJlc3Q+IC0+ICoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gKiovKi88cmVzdD4gLT4gKi8qKi88cmVzdD4gPD09IG5vdCB2YWxpZCBiZWNhdXNlICoqIGRvZXNuJ3QgZm9sbG93XG4gICAgLy8gdGhpcyBXT1VMRCBiZSBhbGxvd2VkIGlmICoqIGRpZCBmb2xsb3cgc3ltbGlua3MsIG9yICogZGlkbid0XG4gICAgZmlyc3RQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGxldCBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyA8cHJlPi8qKi8uLi88cD4vPHA+LzxyZXN0PiAtPiB7PHByZT4vLi4vPHA+LzxwPi88cmVzdD4sPHByZT4vKiovPHA+LzxwPi88cmVzdD59XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0cyBvZiBnbG9iUGFydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3MgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdzcyA9IGdzO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFydHNbZ3NzICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxwcmU+LyoqLyoqLzxyZXN0PiAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdzcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVnLCBpZiBncyBpcyAyIGFuZCBnc3MgaXMgNCwgdGhhdCBtZWFucyB3ZSBoYXZlIDMgKipcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydHMsIGFuZCBjYW4gcmVtb3ZlIDIgb2YgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdzcyA+IGdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MgKyAxLCBnc3MgLSBncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0c1tncyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZ3MgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcDIgPSBwYXJ0c1tncyArIDNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gJy4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXAyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWRpdCBwYXJ0cyBpbiBwbGFjZSwgYW5kIHB1c2ggdGhlIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBwYXJ0cy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJbZ3NdID0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgICAgICAgICBncy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiBwID09PSAnJyAmJiBwYXJ0c1swXSA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0c1sxXSA9PT0gJy4nIHx8IHBhcnRzWzFdID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgICAgIGxldCBkZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tkZCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJyAmJiBwICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZERvdCA9IGRkID09PSAxICYmIHBhcnRzW2RkICsgMV0gPT09ICcqKic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpbiA9IG5lZWREb3QgPyBbJy4nXSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGRkIC0gMSwgMiwgLi4uc3BsaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkIC09IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHM7XG4gICAgfVxuICAgIC8vIHNlY29uZCBwaGFzZTogbXVsdGktcGF0dGVybiBkZWR1cGVzXG4gICAgLy8gezxwcmU+LyovPHJlc3Q+LDxwcmU+LzxwPi88cmVzdD59IC0+IDxwcmU+LyovPHJlc3Q+XG4gICAgLy8gezxwcmU+LzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vIHs8cHJlPi8qKi88cmVzdD4sPHByZT4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvL1xuICAgIC8vIHs8cHJlPi8qKi88cmVzdD4sPHByZT4vKiovPHA+LzxyZXN0Pn0gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgLy8gXi0tIG5vdCB2YWxpZCBiZWNhdXNlICoqIGRvZW5zJ3QgZm9sbG93IHN5bWxpbmtzXG4gICAgc2Vjb25kUGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JQYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdsb2JQYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSB0aGlzLnBhcnRzTWF0Y2goZ2xvYlBhcnRzW2ldLCBnbG9iUGFydHNbal0sICF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2pdID0gbWF0Y2hlZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMuZmlsdGVyKGdzID0+IGdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHBhcnRzTWF0Y2goYSwgYiwgZW1wdHlHU01hdGNoID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGFpID0gMDtcbiAgICAgICAgbGV0IGJpID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgd2hpY2ggPSAnJztcbiAgICAgICAgd2hpbGUgKGFpIDwgYS5sZW5ndGggJiYgYmkgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGFbYWldID09PSBiW2JpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdoaWNoID09PSAnYicgPyBiW2JpXSA6IGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYVthaV0gPT09ICcqKicgJiYgYltiaV0gPT09IGFbYWkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlHU01hdGNoICYmIGJbYmldID09PSAnKionICYmIGFbYWldID09PSBiW2JpICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiW2JpXSk7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFbYWldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFiW2JpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYltiaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdiJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2EnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFbYWldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiW2JpXSA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgYVthaV0gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmRvdCB8fCAhYVthaV0uc3RhcnRzV2l0aCgnLicpKSAmJlxuICAgICAgICAgICAgICAgIGFbYWldICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaWNoID09PSAnYScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGljaCA9ICdiJztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiW2JpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGZhbGwgb3V0IG9mIHRoZSBsb29wLCBpdCBtZWFucyB0aGV5IHR3byBhcmUgaWRlbnRpY2FsXG4gICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlaXIgbGVuZ3RocyBtYXRjaFxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VOZWdhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmVnYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgICAgICBsZXQgbmVnYXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBuZWdhdGVPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISc7IGkrKykge1xuICAgICAgICAgICAgbmVnYXRlID0gIW5lZ2F0ZTtcbiAgICAgICAgICAgIG5lZ2F0ZU9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWdhdGVPZmZzZXQpXG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKG5lZ2F0ZU9mZnNldCk7XG4gICAgICAgIHRoaXMubmVnYXRlID0gbmVnYXRlO1xuICAgIH1cbiAgICAvLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuICAgIC8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuICAgIC8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbiAgICAvLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbiAgICAvLyB0aGUgcGFydHMgbWF0Y2guXG4gICAgbWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIFVOQyBwYXRocyBsaWtlIC8vPy9YOi8uLi4gY2FuIG1hdGNoIFg6Ly4uLiBhbmQgdmljZSB2ZXJzYVxuICAgICAgICAvLyBEcml2ZSBsZXR0ZXJzIGluIGFic29sdXRlIGRyaXZlIG9yIHVuYyBwYXRocyBhcmUgYWx3YXlzIGNvbXBhcmVkXG4gICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlRHJpdmUgPSB0eXBlb2YgZmlsZVswXSA9PT0gJ3N0cmluZycgJiYgL15bYS16XTokL2kudGVzdChmaWxlWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVVTkMgPSAhZmlsZURyaXZlICYmXG4gICAgICAgICAgICAgICAgZmlsZVswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QoZmlsZVszXSk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuRHJpdmUgPSB0eXBlb2YgcGF0dGVyblswXSA9PT0gJ3N0cmluZycgJiYgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5VTkMgPSAhcGF0dGVybkRyaXZlICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXR0ZXJuWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QocGF0dGVyblszXSk7XG4gICAgICAgICAgICBjb25zdCBmZGkgPSBmaWxlVU5DID8gMyA6IGZpbGVEcml2ZSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBwZGkgPSBwYXR0ZXJuVU5DID8gMyA6IHBhdHRlcm5Ecml2ZSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZkaSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHBkaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmQsIHBkXSA9IFtmaWxlW2ZkaV0sIHBhdHRlcm5bcGRpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZkLnRvTG93ZXJDYXNlKCkgPT09IHBkLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybltwZGldID0gZmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZGkgPiBmZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKHBkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmRpID4gcGRpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gZmlsZS5zbGljZShmZGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgYW5kIHJlZHVjZSAuIGFuZCAuLiBwb3J0aW9ucyBpbiB0aGUgZmlsZSBhcyB3ZWxsLlxuICAgICAgICAvLyBkb250JyBuZWVkIHRvIGRvIHRoZSBzZWNvbmQgcGhhc2UsIGJlY2F1c2UgaXQncyBvbmx5IG9uZSBzdHJpbmdbXVxuICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbkxldmVsID0gMSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMikge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMubGV2ZWxUd29GaWxlT3B0aW1pemUoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCB0aGlzLCB7IGZpbGUsIHBhdHRlcm4gfSk7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwLCBwaSA9IDAsIGZsID0gZmlsZS5sZW5ndGgsIHBsID0gcGF0dGVybi5sZW5ndGg7IGZpIDwgZmwgJiYgcGkgPCBwbDsgZmkrKywgcGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpO1xuICAgICAgICAgICAgdmFyIHAgPSBwYXR0ZXJuW3BpXTtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZVtmaV07XG4gICAgICAgICAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgICAgICAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBpZiAocCA9PT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKTtcbiAgICAgICAgICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgICAgICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi9jXG4gICAgICAgICAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgICAgICAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgICAgICAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgICAgICAgICAgdmFyIGZyID0gZmk7XG4gICAgICAgICAgICAgICAgdmFyIHByID0gcGkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmciA9PT0gZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgICAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgICAgICAgIGxldCBoaXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gZiA9PT0gcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gcC50ZXN0KGYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgICAgICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgICAgICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgICAgIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG4gICAgICAgIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgICAgICAgIHJldHVybiBmaSA9PT0gZmwgLSAxICYmIGZpbGVbZmldID09PSAnJztcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB9XG4gICAgYnJhY2VFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5icmFjZUV4cGFuZCkodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBwYXJzZShwYXR0ZXJuKSB7XG4gICAgICAgICgwLCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xLmFzc2VydFZhbGlkUGF0dGVybikocGF0dGVybik7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHNob3J0Y3V0c1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyoqJylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkdMT0JTVEFSO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJycpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIC8vIGZhciBhbmQgYXdheSwgdGhlIG1vc3QgY29tbW9uIGdsb2IgcGF0dGVybiBwYXJ0cyBhcmVcbiAgICAgICAgLy8gKiwgKi4qLCBhbmQgKi48ZXh0PiAgQWRkIGEgZmFzdCBjaGVjayBtZXRob2QgZm9yIHRob3NlLlxuICAgICAgICBsZXQgbTtcbiAgICAgICAgbGV0IGZhc3RUZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBvcHRpb25zLmRvdCA/IHN0YXJUZXN0RG90IDogc3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJEb3RFeHRSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IChvcHRpb25zLm5vY2FzZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFyRG90RXh0VGVzdE5vY2FzZURvdFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJEb3RFeHRUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0RG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3QpKG1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChxbWFya3NSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IChvcHRpb25zLm5vY2FzZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBxbWFya3NUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogcW1hcmtzVGVzdE5vY2FzZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBxbWFya3NUZXN0RG90XG4gICAgICAgICAgICAgICAgICAgIDogcW1hcmtzVGVzdCkobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJEb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBvcHRpb25zLmRvdCA/IHN0YXJEb3RTdGFyVGVzdERvdCA6IHN0YXJEb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goZG90U3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gZG90U3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmUgPSBhc3RfanNfMS5BU1QuZnJvbUdsb2IocGF0dGVybiwgdGhpcy5vcHRpb25zKS50b01NUGF0dGVybigpO1xuICAgICAgICBpZiAoZmFzdFRlc3QgJiYgdHlwZW9mIHJlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gQXZvaWRzIG92ZXJyaWRpbmcgaW4gZnJvemVuIGVudmlyb25tZW50c1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShyZSwgJ3Rlc3QnLCB7IHZhbHVlOiBmYXN0VGVzdCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmU7XG4gICAgfVxuICAgIG1ha2VSZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnZXhwIHx8IHRoaXMucmVnZXhwID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gICAgICAgIC8vIHBhdHRlcm4gc3RyaW5ncywgb3IgXCIqKlwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAgICAgICAvLyBiZSB1c2VkLCByZWFsbHksIGJ1dCBpdCdzIHByZXR0eSBjb252ZW5pZW50IHNvbWV0aW1lcyxcbiAgICAgICAgLy8gd2hlbiB5b3UganVzdCB3YW50IHRvIHdvcmsgd2l0aCBhIHJlZ2V4LlxuICAgICAgICBjb25zdCBzZXQgPSB0aGlzLnNldDtcbiAgICAgICAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXJcbiAgICAgICAgICAgID8gc3RhclxuICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgID8gdHdvU3RhckRvdFxuICAgICAgICAgICAgICAgIDogdHdvU3Rhck5vRG90O1xuICAgICAgICBjb25zdCBmbGFncyA9IG5ldyBTZXQob3B0aW9ucy5ub2Nhc2UgPyBbJ2knXSA6IFtdKTtcbiAgICAgICAgLy8gcmVnZXhwaWZ5IG5vbi1nbG9ic3RhciBwYXR0ZXJuc1xuICAgICAgICAvLyBpZiAqKiBpcyBvbmx5IGl0ZW0sIHRoZW4gd2UganVzdCBkbyBvbmUgdHdvU3RhclxuICAgICAgICAvLyBpZiAqKiBpcyBmaXJzdCwgYW5kIHRoZXJlIGFyZSBtb3JlLCBwcmVwZW5kIChcXC98dHdvU3RhclxcLyk/IHRvIG5leHRcbiAgICAgICAgLy8gaWYgKiogaXMgbGFzdCwgYXBwZW5kIChcXC90d29TdGFyfCkgdG8gcHJldmlvdXNcbiAgICAgICAgLy8gaWYgKiogaXMgaW4gdGhlIG1pZGRsZSwgYXBwZW5kIChcXC98XFwvdHdvU3RhclxcLykgdG8gcHJldmlvdXNcbiAgICAgICAgLy8gdGhlbiBmaWx0ZXIgb3V0IEdMT0JTVEFSIHN5bWJvbHNcbiAgICAgICAgbGV0IHJlID0gc2V0XG4gICAgICAgICAgICAubWFwKHBhdHRlcm4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwYXR0ZXJuLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgcC5mbGFncy5zcGxpdCgnJykpXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5hZGQoZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyByZWdFeHBFc2NhcGUocClcbiAgICAgICAgICAgICAgICAgICAgOiBwID09PSBleHBvcnRzLkdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMuR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC5fc3JjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcC5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBwW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHBbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwICE9PSBleHBvcnRzLkdMT0JTVEFSIHx8IHByZXYgPT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHBbaSArIDFdID0gJyg/OlxcXFwvfCcgKyB0d29TdGFyICsgJ1xcXFwvKT8nICsgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2ldID0gdHdvU3RhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSAtIDFdID0gcHJldiArICcoPzpcXFxcL3wnICsgdHdvU3RhciArICcpPyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgIT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSAtIDFdID0gcHJldiArICcoPzpcXFxcL3xcXFxcLycgKyB0d29TdGFyICsgJ1xcXFwvKScgKyBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBwcFtpICsgMV0gPSBleHBvcnRzLkdMT0JTVEFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBwLmZpbHRlcihwID0+IHAgIT09IGV4cG9ydHMuR0xPQlNUQVIpLmpvaW4oJy8nKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgIC8vIG5lZWQgdG8gd3JhcCBpbiBwYXJlbnMgaWYgd2UgaGFkIG1vcmUgdGhhbiBvbmUgdGhpbmcgd2l0aCB8LFxuICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBhbmNob3JlZCB0byBeIGFuZCB0aGUgbGFzdCB0byAkXG4gICAgICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBzZXQubGVuZ3RoID4gMSA/IFsnKD86JywgJyknXSA6IFsnJywgJyddO1xuICAgICAgICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gICAgICAgIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICAgICAgICByZSA9ICdeJyArIG9wZW4gKyByZSArIGNsb3NlICsgJyQnO1xuICAgICAgICAvLyBjYW4gbWF0Y2ggYW55dGhpbmcsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhpcy5cbiAgICAgICAgaWYgKHRoaXMubmVnYXRlKVxuICAgICAgICAgICAgcmUgPSAnXig/IScgKyByZSArICcpLiskJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgWy4uLmZsYWdzXS5qb2luKCcnKSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlXG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICB9XG4gICAgc2xhc2hTcGxpdChwKSB7XG4gICAgICAgIC8vIGlmIHAgc3RhcnRzIHdpdGggLy8gb24gd2luZG93cywgd2UgcHJlc2VydmUgdGhhdFxuICAgICAgICAvLyBzbyB0aGF0IFVOQyBwYXRocyBhcmVuJ3QgYnJva2VuLiAgT3RoZXJ3aXNlLCBhbnkgbnVtYmVyIG9mXG4gICAgICAgIC8vIC8gY2hhcmFjdGVycyBhcmUgY29hbGVzY2VkIGludG8gb25lLCB1bmxlc3NcbiAgICAgICAgLy8gcHJlc2VydmVNdWx0aXBsZVNsYXNoZXMgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgIGlmICh0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5zcGxpdCgnLycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNXaW5kb3dzICYmIC9eXFwvXFwvW15cXC9dKy8udGVzdChwKSkge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGV4dHJhICcnIGZvciB0aGUgb25lIHdlIGxvc2VcbiAgICAgICAgICAgIHJldHVybiBbJycsIC4uLnAuc3BsaXQoL1xcLysvKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcC5zcGxpdCgvXFwvKy8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGYsIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pO1xuICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gICAgICAgIC8vIGNvbW1lbnRzLCBldGMuXG4gICAgICAgIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGYgPT09ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZiA9IGYuc3BsaXQoJ1xcXFwnKS5qb2luKCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJlYXQgdGhlIHRlc3QgcGF0aCBhcyBhIHNldCBvZiBwYXRocGFydHMuXG4gICAgICAgIGNvbnN0IGZmID0gdGhpcy5zbGFzaFNwbGl0KGYpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZmYpO1xuICAgICAgICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gICAgICAgIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gICAgICAgIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuICAgICAgICBjb25zdCBzZXQgPSB0aGlzLnNldDtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpO1xuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICAgICAgICBsZXQgZmlsZW5hbWUgPSBmZltmZi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZmLmxlbmd0aCAtIDI7ICFmaWxlbmFtZSAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmZbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzZXRbaV07XG4gICAgICAgICAgICBsZXQgZmlsZSA9IGZmO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IFtmaWxlbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpO1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5uZWdhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgICAgICAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gICAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGU7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0cyhkZWYpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoO1xuICAgIH1cbn1cbmV4cG9ydHMuTWluaW1hdGNoID0gTWluaW1hdGNoO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG52YXIgYXN0X2pzXzIgPSByZXF1aXJlKFwiLi9hc3QuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBU1RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdF9qc18yLkFTVDsgfSB9KTtcbnZhciBlc2NhcGVfanNfMiA9IHJlcXVpcmUoXCIuL2VzY2FwZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXNjYXBlX2pzXzIuZXNjYXBlOyB9IH0pO1xudmFyIHVuZXNjYXBlX2pzXzIgPSByZXF1aXJlKFwiLi91bmVzY2FwZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmVzY2FwZV9qc18yLnVuZXNjYXBlOyB9IH0pO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmV4cG9ydHMubWluaW1hdGNoLkFTVCA9IGFzdF9qc18xLkFTVDtcbmV4cG9ydHMubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaDtcbmV4cG9ydHMubWluaW1hdGNoLmVzY2FwZSA9IGVzY2FwZV9qc18xLmVzY2FwZTtcbmV4cG9ydHMubWluaW1hdGNoLnVuZXNjYXBlID0gdW5lc2NhcGVfanNfMS51bmVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy91bmVzY2FwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy91bmVzY2FwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5lc2NhcGUgPSB2b2lkIDA7XG4vKipcbiAqIFVuLWVzY2FwZSBhIHN0cmluZyB0aGF0IGhhcyBiZWVuIGVzY2FwZWQgd2l0aCB7QGxpbmsgZXNjYXBlfS5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlfSBvcHRpb24gaXMgdXNlZCwgdGhlbiBzcXVhcmUtYnJhY2VcbiAqIGVzY2FwZXMgYXJlIHJlbW92ZWQsIGJ1dCBub3QgYmFja3NsYXNoIGVzY2FwZXMuICBGb3IgZXhhbXBsZSwgaXQgd2lsbCB0dXJuXG4gKiB0aGUgc3RyaW5nIGAnWypdJ2AgaW50byBgKmAsIGJ1dCBpdCB3aWxsIG5vdCB0dXJuIGAnXFxcXConYCBpbnRvIGAnKidgLFxuICogYmVjdWFzZSBgXFxgIGlzIGEgcGF0aCBzZXBhcmF0b3IgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlLlxuICpcbiAqIFdoZW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBpcyBub3Qgc2V0LCB0aGVuIGJvdGggYnJhY2UgZXNjYXBlcyBhbmRcbiAqIGJhY2tzbGFzaCBlc2NhcGVzIGFyZSByZW1vdmVkLlxuICpcbiAqIFNsYXNoZXMgKGFuZCBiYWNrc2xhc2hlcyBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUpIGNhbm5vdCBiZSBlc2NhcGVkXG4gKiBvciB1bmVzY2FwZWQuXG4gKi9cbmNvbnN0IHVuZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvd3NQYXRoc05vRXNjYXBlXG4gICAgICAgID8gcy5yZXBsYWNlKC9cXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJylcbiAgICAgICAgOiBzLnJlcGxhY2UoLygoPyFcXFxcKS58XilcXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJDInKS5yZXBsYWNlKC9cXFxcKFteXFwvXSkvZywgJyQxJyk7XG59O1xuZXhwb3J0cy51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5lc2NhcGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/archiver-utils/node_modules/minimatch/dist/commonjs/unescape.js\n");

/***/ })

};
;