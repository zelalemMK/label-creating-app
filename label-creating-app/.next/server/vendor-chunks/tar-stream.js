/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar-stream";
exports.ids = ["vendor-chunks/tar-stream"];
exports.modules = {

/***/ "(rsc)/../node_modules/tar-stream/constants.js":
/*!***********************************************!*\
  !*** ../node_modules/tar-stream/constants.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const constants = { // just for envs without fs\n  S_IFMT: 61440,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960\n}\n\ntry {\n  module.exports = (__webpack_require__(/*! fs */ \"fs\").constants) || constants\n} catch {\n  module.exports = constants\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQ0FBdUI7QUFDMUMsRUFBRTtBQUNGO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29uc3RhbnRzID0geyAvLyBqdXN0IGZvciBlbnZzIHdpdGhvdXQgZnNcbiAgU19JRk1UOiA2MTQ0MCxcbiAgU19JRkRJUjogMTYzODQsXG4gIFNfSUZDSFI6IDgxOTIsXG4gIFNfSUZCTEs6IDI0NTc2LFxuICBTX0lGSUZPOiA0MDk2LFxuICBTX0lGTE5LOiA0MDk2MFxufVxuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2ZzJykuY29uc3RhbnRzIHx8IGNvbnN0YW50c1xufSBjYXRjaCB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29uc3RhbnRzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/tar-stream/constants.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/tar-stream/extract.js":
/*!*********************************************!*\
  !*** ../node_modules/tar-stream/extract.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Writable, Readable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/../node_modules/streamx/index.js\")\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/../node_modules/fast-fifo/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/../node_modules/b4a/index.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/../node_modules/tar-stream/headers.js\")\n\nconst EMPTY = b4a.alloc(0)\n\nclass BufferList {\n  constructor () {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push (buffer) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst (size) {\n    return this._buffered === 0 ? null : this._next(size)\n  }\n\n  shift (size) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return b4a.concat(chunks)\n  }\n\n  _next (size) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n\nclass Source extends Readable {\n  constructor (self, header, offset) {\n    super()\n\n    this.header = header\n    this.offset = offset\n\n    this._parent = self\n  }\n\n  _read (cb) {\n    if (this.header.size === 0) {\n      this.push(null)\n    }\n    if (this._parent._stream === this) {\n      this._parent._update()\n    }\n    cb(null)\n  }\n\n  _predestroy () {\n    this._parent.destroy(getStreamError(this))\n  }\n\n  _detach () {\n    if (this._parent._stream === this) {\n      this._parent._stream = null\n      this._parent._missing = overflow(this.header.size)\n      this._parent._update()\n    }\n  }\n\n  _destroy (cb) {\n    this._detach()\n    cb(null)\n  }\n}\n\nclass Extract extends Writable {\n  constructor (opts) {\n    super(opts)\n\n    if (!opts) opts = {}\n\n    this._buffer = new BufferList()\n    this._offset = 0\n    this._header = null\n    this._stream = null\n    this._missing = 0\n    this._longHeader = false\n    this._callback = noop\n    this._locked = false\n    this._finished = false\n    this._pax = null\n    this._paxGlobal = null\n    this._gnuLongPath = null\n    this._gnuLongLinkPath = null\n    this._filenameEncoding = opts.filenameEncoding || 'utf-8'\n    this._allowUnknownFormat = !!opts.allowUnknownFormat\n    this._unlockBound = this._unlock.bind(this)\n  }\n\n  _unlock (err) {\n    this._locked = false\n\n    if (err) {\n      this.destroy(err)\n      this._continueWrite(err)\n      return\n    }\n\n    this._update()\n  }\n\n  _consumeHeader () {\n    if (this._locked) return false\n\n    this._offset = this._buffer.shifted\n\n    try {\n      this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    if (!this._header) return true\n\n    switch (this._header.type) {\n      case 'gnu-long-path':\n      case 'gnu-long-link-path':\n      case 'pax-global-header':\n      case 'pax-header':\n        this._longHeader = true\n        this._missing = this._header.size\n        return true\n    }\n\n    this._locked = true\n    this._applyLongHeaders()\n\n    if (this._header.size === 0 || this._header.type === 'directory') {\n      this.emit('entry', this._header, this._createStream(), this._unlockBound)\n      return true\n    }\n\n    this._stream = this._createStream()\n    this._missing = this._header.size\n\n    this.emit('entry', this._header, this._stream, this._unlockBound)\n    return true\n  }\n\n  _applyLongHeaders () {\n    if (this._gnuLongPath) {\n      this._header.name = this._gnuLongPath\n      this._gnuLongPath = null\n    }\n\n    if (this._gnuLongLinkPath) {\n      this._header.linkname = this._gnuLongLinkPath\n      this._gnuLongLinkPath = null\n    }\n\n    if (this._pax) {\n      if (this._pax.path) this._header.name = this._pax.path\n      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath\n      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10)\n      this._header.pax = this._pax\n      this._pax = null\n    }\n  }\n\n  _decodeLongHeader (buf) {\n    switch (this._header.type) {\n      case 'gnu-long-path':\n        this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'gnu-long-link-path':\n        this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'pax-global-header':\n        this._paxGlobal = headers.decodePax(buf)\n        break\n      case 'pax-header':\n        this._pax = this._paxGlobal === null\n          ? headers.decodePax(buf)\n          : Object.assign({}, this._paxGlobal, headers.decodePax(buf))\n        break\n    }\n  }\n\n  _consumeLongHeader () {\n    this._longHeader = false\n    this._missing = overflow(this._header.size)\n\n    const buf = this._buffer.shift(this._header.size)\n\n    try {\n      this._decodeLongHeader(buf)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    return true\n  }\n\n  _consumeStream () {\n    const buf = this._buffer.shiftFirst(this._missing)\n    if (buf === null) return false\n\n    this._missing -= buf.byteLength\n    const drained = this._stream.push(buf)\n\n    if (this._missing === 0) {\n      this._stream.push(null)\n      if (drained) this._stream._detach()\n      return drained && this._locked === false\n    }\n\n    return drained\n  }\n\n  _createStream () {\n    return new Source(this, this._header, this._offset)\n  }\n\n  _update () {\n    while (this._buffer.buffered > 0 && !this.destroying) {\n      if (this._missing > 0) {\n        if (this._stream !== null) {\n          if (this._consumeStream() === false) return\n          continue\n        }\n\n        if (this._longHeader === true) {\n          if (this._missing > this._buffer.buffered) break\n          if (this._consumeLongHeader() === false) return false\n          continue\n        }\n\n        const ignore = this._buffer.shiftFirst(this._missing)\n        if (ignore !== null) this._missing -= ignore.byteLength\n        continue\n      }\n\n      if (this._buffer.buffered < 512) break\n      if (this._stream !== null || this._consumeHeader() === false) return\n    }\n\n    this._continueWrite(null)\n  }\n\n  _continueWrite (err) {\n    const cb = this._callback\n    this._callback = noop\n    cb(err)\n  }\n\n  _write (data, cb) {\n    this._callback = cb\n    this._buffer.push(data)\n    this._update()\n  }\n\n  _final (cb) {\n    this._finished = this._missing === 0 && this._buffer.buffered === 0\n    cb(this._finished ? null : new Error('Unexpected end of data'))\n  }\n\n  _predestroy () {\n    this._continueWrite(null)\n  }\n\n  _destroy (cb) {\n    if (this._stream) this._stream.destroy(getStreamError(this))\n    cb(null)\n  }\n\n  [Symbol.asyncIterator] () {\n    let error = null\n\n    let promiseResolve = null\n    let promiseReject = null\n\n    let entryStream = null\n    let entryCallback = null\n\n    const extract = this\n\n    this.on('entry', onentry)\n    this.on('error', (err) => { error = err })\n    this.on('close', onclose)\n\n    return {\n      [Symbol.asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(onnext)\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function consumeCallback (err) {\n      if (!entryCallback) return\n      const cb = entryCallback\n      entryCallback = null\n      cb(err)\n    }\n\n    function onnext (resolve, reject) {\n      if (error) {\n        return reject(error)\n      }\n\n      if (entryStream) {\n        resolve({ value: entryStream, done: false })\n        entryStream = null\n        return\n      }\n\n      promiseResolve = resolve\n      promiseReject = reject\n\n      consumeCallback(null)\n\n      if (extract._finished && promiseResolve) {\n        promiseResolve({ value: undefined, done: true })\n        promiseResolve = promiseReject = null\n      }\n    }\n\n    function onentry (header, stream, callback) {\n      entryCallback = callback\n      stream.on('error', noop) // no way around this due to tick sillyness\n\n      if (promiseResolve) {\n        promiseResolve({ value: stream, done: false })\n        promiseResolve = promiseReject = null\n      } else {\n        entryStream = stream\n      }\n    }\n\n    function onclose () {\n      consumeCallback(error)\n      if (!promiseResolve) return\n      if (error) promiseReject(error)\n      else promiseResolve({ value: undefined, done: true })\n      promiseResolve = promiseReject = null\n    }\n\n    function destroy (err) {\n      extract.destroy(err)\n      consumeCallback(err)\n      return new Promise((resolve, reject) => {\n        if (extract.destroyed) return resolve({ value: undefined, done: true })\n        extract.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nmodule.exports = function extract (opts) {\n  return new Extract(opts)\n}\n\nfunction noop () {}\n\nfunction overflow (size) {\n  size &= 511\n  return size && 512 - size\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vZXh0cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMsdURBQVM7QUFDaEUsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDLFlBQVksbUJBQU8sQ0FBQywrQ0FBSztBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBVzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhCQUE4QjtBQUM5RTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9leHRyYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgV3JpdGFibGUsIFJlYWRhYmxlLCBnZXRTdHJlYW1FcnJvciB9ID0gcmVxdWlyZSgnc3RyZWFteCcpXG5jb25zdCBGSUZPID0gcmVxdWlyZSgnZmFzdC1maWZvJylcbmNvbnN0IGI0YSA9IHJlcXVpcmUoJ2I0YScpXG5jb25zdCBoZWFkZXJzID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcblxuY29uc3QgRU1QVFkgPSBiNGEuYWxsb2MoMClcblxuY2xhc3MgQnVmZmVyTGlzdCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gMFxuICAgIHRoaXMuc2hpZnRlZCA9IDBcbiAgICB0aGlzLnF1ZXVlID0gbmV3IEZJRk8oKVxuXG4gICAgdGhpcy5fb2Zmc2V0ID0gMFxuICB9XG5cbiAgcHVzaCAoYnVmZmVyKSB7XG4gICAgdGhpcy5idWZmZXJlZCArPSBidWZmZXIuYnl0ZUxlbmd0aFxuICAgIHRoaXMucXVldWUucHVzaChidWZmZXIpXG4gIH1cblxuICBzaGlmdEZpcnN0IChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkID09PSAwID8gbnVsbCA6IHRoaXMuX25leHQoc2l6ZSlcbiAgfVxuXG4gIHNoaWZ0IChzaXplKSB7XG4gICAgaWYgKHNpemUgPiB0aGlzLmJ1ZmZlcmVkKSByZXR1cm4gbnVsbFxuICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gRU1QVFlcblxuICAgIGxldCBjaHVuayA9IHRoaXMuX25leHQoc2l6ZSlcblxuICAgIGlmIChzaXplID09PSBjaHVuay5ieXRlTGVuZ3RoKSByZXR1cm4gY2h1bmsgLy8gbGlrZWx5IGNhc2VcblxuICAgIGNvbnN0IGNodW5rcyA9IFtjaHVua11cblxuICAgIHdoaWxlICgoc2l6ZSAtPSBjaHVuay5ieXRlTGVuZ3RoKSA+IDApIHtcbiAgICAgIGNodW5rID0gdGhpcy5fbmV4dChzaXplKVxuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgfVxuXG4gICAgcmV0dXJuIGI0YS5jb25jYXQoY2h1bmtzKVxuICB9XG5cbiAgX25leHQgKHNpemUpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLnF1ZXVlLnBlZWsoKVxuICAgIGNvbnN0IHJlbSA9IGJ1Zi5ieXRlTGVuZ3RoIC0gdGhpcy5fb2Zmc2V0XG5cbiAgICBpZiAoc2l6ZSA+PSByZW0pIHtcbiAgICAgIGNvbnN0IHN1YiA9IHRoaXMuX29mZnNldCA/IGJ1Zi5zdWJhcnJheSh0aGlzLl9vZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSA6IGJ1ZlxuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpXG4gICAgICB0aGlzLl9vZmZzZXQgPSAwXG4gICAgICB0aGlzLmJ1ZmZlcmVkIC09IHJlbVxuICAgICAgdGhpcy5zaGlmdGVkICs9IHJlbVxuICAgICAgcmV0dXJuIHN1YlxuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyZWQgLT0gc2l6ZVxuICAgIHRoaXMuc2hpZnRlZCArPSBzaXplXG5cbiAgICByZXR1cm4gYnVmLnN1YmFycmF5KHRoaXMuX29mZnNldCwgKHRoaXMuX29mZnNldCArPSBzaXplKSlcbiAgfVxufVxuXG5jbGFzcyBTb3VyY2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChzZWxmLCBoZWFkZXIsIG9mZnNldCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcblxuICAgIHRoaXMuX3BhcmVudCA9IHNlbGZcbiAgfVxuXG4gIF9yZWFkIChjYikge1xuICAgIGlmICh0aGlzLmhlYWRlci5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnB1c2gobnVsbClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcmVudC5fc3RyZWFtID09PSB0aGlzKSB7XG4gICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZSgpXG4gICAgfVxuICAgIGNiKG51bGwpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fcGFyZW50LmRlc3Ryb3koZ2V0U3RyZWFtRXJyb3IodGhpcykpXG4gIH1cblxuICBfZGV0YWNoICgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Ll9zdHJlYW0gPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5fc3RyZWFtID0gbnVsbFxuICAgICAgdGhpcy5fcGFyZW50Ll9taXNzaW5nID0gb3ZlcmZsb3codGhpcy5oZWFkZXIuc2l6ZSlcbiAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlKClcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSAoY2IpIHtcbiAgICB0aGlzLl9kZXRhY2goKVxuICAgIGNiKG51bGwpXG4gIH1cbn1cblxuY2xhc3MgRXh0cmFjdCBleHRlbmRzIFdyaXRhYmxlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KClcbiAgICB0aGlzLl9vZmZzZXQgPSAwXG4gICAgdGhpcy5faGVhZGVyID0gbnVsbFxuICAgIHRoaXMuX3N0cmVhbSA9IG51bGxcbiAgICB0aGlzLl9taXNzaW5nID0gMFxuICAgIHRoaXMuX2xvbmdIZWFkZXIgPSBmYWxzZVxuICAgIHRoaXMuX2NhbGxiYWNrID0gbm9vcFxuICAgIHRoaXMuX2xvY2tlZCA9IGZhbHNlXG4gICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZVxuICAgIHRoaXMuX3BheCA9IG51bGxcbiAgICB0aGlzLl9wYXhHbG9iYWwgPSBudWxsXG4gICAgdGhpcy5fZ251TG9uZ1BhdGggPSBudWxsXG4gICAgdGhpcy5fZ251TG9uZ0xpbmtQYXRoID0gbnVsbFxuICAgIHRoaXMuX2ZpbGVuYW1lRW5jb2RpbmcgPSBvcHRzLmZpbGVuYW1lRW5jb2RpbmcgfHwgJ3V0Zi04J1xuICAgIHRoaXMuX2FsbG93VW5rbm93bkZvcm1hdCA9ICEhb3B0cy5hbGxvd1Vua25vd25Gb3JtYXRcbiAgICB0aGlzLl91bmxvY2tCb3VuZCA9IHRoaXMuX3VubG9jay5iaW5kKHRoaXMpXG4gIH1cblxuICBfdW5sb2NrIChlcnIpIHtcbiAgICB0aGlzLl9sb2NrZWQgPSBmYWxzZVxuXG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVycilcbiAgICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgfVxuXG4gIF9jb25zdW1lSGVhZGVyICgpIHtcbiAgICBpZiAodGhpcy5fbG9ja2VkKSByZXR1cm4gZmFsc2VcblxuICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX2J1ZmZlci5zaGlmdGVkXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5faGVhZGVyID0gaGVhZGVycy5kZWNvZGUodGhpcy5fYnVmZmVyLnNoaWZ0KDUxMiksIHRoaXMuX2ZpbGVuYW1lRW5jb2RpbmcsIHRoaXMuX2FsbG93VW5rbm93bkZvcm1hdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9oZWFkZXIpIHJldHVybiB0cnVlXG5cbiAgICBzd2l0Y2ggKHRoaXMuX2hlYWRlci50eXBlKSB7XG4gICAgICBjYXNlICdnbnUtbG9uZy1wYXRoJzpcbiAgICAgIGNhc2UgJ2dudS1sb25nLWxpbmstcGF0aCc6XG4gICAgICBjYXNlICdwYXgtZ2xvYmFsLWhlYWRlcic6XG4gICAgICBjYXNlICdwYXgtaGVhZGVyJzpcbiAgICAgICAgdGhpcy5fbG9uZ0hlYWRlciA9IHRydWVcbiAgICAgICAgdGhpcy5fbWlzc2luZyA9IHRoaXMuX2hlYWRlci5zaXplXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja2VkID0gdHJ1ZVxuICAgIHRoaXMuX2FwcGx5TG9uZ0hlYWRlcnMoKVxuXG4gICAgaWYgKHRoaXMuX2hlYWRlci5zaXplID09PSAwIHx8IHRoaXMuX2hlYWRlci50eXBlID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgdGhpcy5lbWl0KCdlbnRyeScsIHRoaXMuX2hlYWRlciwgdGhpcy5fY3JlYXRlU3RyZWFtKCksIHRoaXMuX3VubG9ja0JvdW5kKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJlYW0gPSB0aGlzLl9jcmVhdGVTdHJlYW0oKVxuICAgIHRoaXMuX21pc3NpbmcgPSB0aGlzLl9oZWFkZXIuc2l6ZVxuXG4gICAgdGhpcy5lbWl0KCdlbnRyeScsIHRoaXMuX2hlYWRlciwgdGhpcy5fc3RyZWFtLCB0aGlzLl91bmxvY2tCb3VuZClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2FwcGx5TG9uZ0hlYWRlcnMgKCkge1xuICAgIGlmICh0aGlzLl9nbnVMb25nUGF0aCkge1xuICAgICAgdGhpcy5faGVhZGVyLm5hbWUgPSB0aGlzLl9nbnVMb25nUGF0aFxuICAgICAgdGhpcy5fZ251TG9uZ1BhdGggPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2dudUxvbmdMaW5rUGF0aCkge1xuICAgICAgdGhpcy5faGVhZGVyLmxpbmtuYW1lID0gdGhpcy5fZ251TG9uZ0xpbmtQYXRoXG4gICAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheCkge1xuICAgICAgaWYgKHRoaXMuX3BheC5wYXRoKSB0aGlzLl9oZWFkZXIubmFtZSA9IHRoaXMuX3BheC5wYXRoXG4gICAgICBpZiAodGhpcy5fcGF4LmxpbmtwYXRoKSB0aGlzLl9oZWFkZXIubGlua25hbWUgPSB0aGlzLl9wYXgubGlua3BhdGhcbiAgICAgIGlmICh0aGlzLl9wYXguc2l6ZSkgdGhpcy5faGVhZGVyLnNpemUgPSBwYXJzZUludCh0aGlzLl9wYXguc2l6ZSwgMTApXG4gICAgICB0aGlzLl9oZWFkZXIucGF4ID0gdGhpcy5fcGF4XG4gICAgICB0aGlzLl9wYXggPSBudWxsXG4gICAgfVxuICB9XG5cbiAgX2RlY29kZUxvbmdIZWFkZXIgKGJ1Zikge1xuICAgIHN3aXRjaCAodGhpcy5faGVhZGVyLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2dudS1sb25nLXBhdGgnOlxuICAgICAgICB0aGlzLl9nbnVMb25nUGF0aCA9IGhlYWRlcnMuZGVjb2RlTG9uZ1BhdGgoYnVmLCB0aGlzLl9maWxlbmFtZUVuY29kaW5nKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZ251LWxvbmctbGluay1wYXRoJzpcbiAgICAgICAgdGhpcy5fZ251TG9uZ0xpbmtQYXRoID0gaGVhZGVycy5kZWNvZGVMb25nUGF0aChidWYsIHRoaXMuX2ZpbGVuYW1lRW5jb2RpbmcpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXgtZ2xvYmFsLWhlYWRlcic6XG4gICAgICAgIHRoaXMuX3BheEdsb2JhbCA9IGhlYWRlcnMuZGVjb2RlUGF4KGJ1ZilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BheC1oZWFkZXInOlxuICAgICAgICB0aGlzLl9wYXggPSB0aGlzLl9wYXhHbG9iYWwgPT09IG51bGxcbiAgICAgICAgICA/IGhlYWRlcnMuZGVjb2RlUGF4KGJ1ZilcbiAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3BheEdsb2JhbCwgaGVhZGVycy5kZWNvZGVQYXgoYnVmKSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBfY29uc3VtZUxvbmdIZWFkZXIgKCkge1xuICAgIHRoaXMuX2xvbmdIZWFkZXIgPSBmYWxzZVxuICAgIHRoaXMuX21pc3NpbmcgPSBvdmVyZmxvdyh0aGlzLl9oZWFkZXIuc2l6ZSlcblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlci5zaGlmdCh0aGlzLl9oZWFkZXIuc2l6ZSlcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9kZWNvZGVMb25nSGVhZGVyKGJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9jb25zdW1lU3RyZWFtICgpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXIuc2hpZnRGaXJzdCh0aGlzLl9taXNzaW5nKVxuICAgIGlmIChidWYgPT09IG51bGwpIHJldHVybiBmYWxzZVxuXG4gICAgdGhpcy5fbWlzc2luZyAtPSBidWYuYnl0ZUxlbmd0aFxuICAgIGNvbnN0IGRyYWluZWQgPSB0aGlzLl9zdHJlYW0ucHVzaChidWYpXG5cbiAgICBpZiAodGhpcy5fbWlzc2luZyA9PT0gMCkge1xuICAgICAgdGhpcy5fc3RyZWFtLnB1c2gobnVsbClcbiAgICAgIGlmIChkcmFpbmVkKSB0aGlzLl9zdHJlYW0uX2RldGFjaCgpXG4gICAgICByZXR1cm4gZHJhaW5lZCAmJiB0aGlzLl9sb2NrZWQgPT09IGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGRyYWluZWRcbiAgfVxuXG4gIF9jcmVhdGVTdHJlYW0gKCkge1xuICAgIHJldHVybiBuZXcgU291cmNlKHRoaXMsIHRoaXMuX2hlYWRlciwgdGhpcy5fb2Zmc2V0KVxuICB9XG5cbiAgX3VwZGF0ZSAoKSB7XG4gICAgd2hpbGUgKHRoaXMuX2J1ZmZlci5idWZmZXJlZCA+IDAgJiYgIXRoaXMuZGVzdHJveWluZykge1xuICAgICAgaWYgKHRoaXMuX21pc3NpbmcgPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW0gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZVN0cmVhbSgpID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9sb25nSGVhZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21pc3NpbmcgPiB0aGlzLl9idWZmZXIuYnVmZmVyZWQpIGJyZWFrXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbnN1bWVMb25nSGVhZGVyKCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWdub3JlID0gdGhpcy5fYnVmZmVyLnNoaWZ0Rmlyc3QodGhpcy5fbWlzc2luZylcbiAgICAgICAgaWYgKGlnbm9yZSAhPT0gbnVsbCkgdGhpcy5fbWlzc2luZyAtPSBpZ25vcmUuYnl0ZUxlbmd0aFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYnVmZmVyLmJ1ZmZlcmVkIDwgNTEyKSBicmVha1xuICAgICAgaWYgKHRoaXMuX3N0cmVhbSAhPT0gbnVsbCB8fCB0aGlzLl9jb25zdW1lSGVhZGVyKCkgPT09IGZhbHNlKSByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZVdyaXRlKG51bGwpXG4gIH1cblxuICBfY29udGludWVXcml0ZSAoZXJyKSB7XG4gICAgY29uc3QgY2IgPSB0aGlzLl9jYWxsYmFja1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbm9vcFxuICAgIGNiKGVycilcbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNiXG4gICAgdGhpcy5fYnVmZmVyLnB1c2goZGF0YSlcbiAgICB0aGlzLl91cGRhdGUoKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIHRoaXMuX2ZpbmlzaGVkID0gdGhpcy5fbWlzc2luZyA9PT0gMCAmJiB0aGlzLl9idWZmZXIuYnVmZmVyZWQgPT09IDBcbiAgICBjYih0aGlzLl9maW5pc2hlZCA/IG51bGwgOiBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKSlcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9jb250aW51ZVdyaXRlKG51bGwpXG4gIH1cblxuICBfZGVzdHJveSAoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZGVzdHJveShnZXRTdHJlYW1FcnJvcih0aGlzKSlcbiAgICBjYihudWxsKVxuICB9XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbFxuXG4gICAgbGV0IHByb21pc2VSZXNvbHZlID0gbnVsbFxuICAgIGxldCBwcm9taXNlUmVqZWN0ID0gbnVsbFxuXG4gICAgbGV0IGVudHJ5U3RyZWFtID0gbnVsbFxuICAgIGxldCBlbnRyeUNhbGxiYWNrID0gbnVsbFxuXG4gICAgY29uc3QgZXh0cmFjdCA9IHRoaXNcblxuICAgIHRoaXMub24oJ2VudHJ5Jywgb25lbnRyeSlcbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHsgZXJyb3IgPSBlcnIgfSlcbiAgICB0aGlzLm9uKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgbmV4dCAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShvbm5leHQpXG4gICAgICB9LFxuICAgICAgcmV0dXJuICgpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3kobnVsbClcbiAgICAgIH0sXG4gICAgICB0aHJvdyAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkZXN0cm95KGVycilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdW1lQ2FsbGJhY2sgKGVycikge1xuICAgICAgaWYgKCFlbnRyeUNhbGxiYWNrKSByZXR1cm5cbiAgICAgIGNvbnN0IGNiID0gZW50cnlDYWxsYmFja1xuICAgICAgZW50cnlDYWxsYmFjayA9IG51bGxcbiAgICAgIGNiKGVycilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbm5leHQgKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpXG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeVN0cmVhbSkge1xuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IGVudHJ5U3RyZWFtLCBkb25lOiBmYWxzZSB9KVxuICAgICAgICBlbnRyeVN0cmVhbSA9IG51bGxcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdFxuXG4gICAgICBjb25zdW1lQ2FsbGJhY2sobnVsbClcblxuICAgICAgaWYgKGV4dHJhY3QuX2ZpbmlzaGVkICYmIHByb21pc2VSZXNvbHZlKSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZWplY3QgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lbnRyeSAoaGVhZGVyLCBzdHJlYW0sIGNhbGxiYWNrKSB7XG4gICAgICBlbnRyeUNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBub29wKSAvLyBubyB3YXkgYXJvdW5kIHRoaXMgZHVlIHRvIHRpY2sgc2lsbHluZXNzXG5cbiAgICAgIGlmIChwcm9taXNlUmVzb2x2ZSkge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh7IHZhbHVlOiBzdHJlYW0sIGRvbmU6IGZhbHNlIH0pXG4gICAgICAgIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlamVjdCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5U3RyZWFtID0gc3RyZWFtXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgICBjb25zdW1lQ2FsbGJhY2soZXJyb3IpXG4gICAgICBpZiAoIXByb21pc2VSZXNvbHZlKSByZXR1cm5cbiAgICAgIGlmIChlcnJvcikgcHJvbWlzZVJlamVjdChlcnJvcilcbiAgICAgIGVsc2UgcHJvbWlzZVJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZWplY3QgPSBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveSAoZXJyKSB7XG4gICAgICBleHRyYWN0LmRlc3Ryb3koZXJyKVxuICAgICAgY29uc3VtZUNhbGxiYWNrKGVycilcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChleHRyYWN0LmRlc3Ryb3llZCkgcmV0dXJuIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIGV4dHJhY3Qub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgICAgICBlbHNlIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dHJhY3QgKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBFeHRyYWN0KG9wdHMpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gb3ZlcmZsb3cgKHNpemUpIHtcbiAgc2l6ZSAmPSA1MTFcbiAgcmV0dXJuIHNpemUgJiYgNTEyIC0gc2l6ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/tar-stream/extract.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/tar-stream/headers.js":
/*!*********************************************!*\
  !*** ../node_modules/tar-stream/headers.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const b4a = __webpack_require__(/*! b4a */ \"(rsc)/../node_modules/b4a/index.js\")\n\nconst ZEROS = '0000000000000000000'\nconst SEVENS = '7777777777777777777'\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET])\nconst GNU_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = b4a.from([0x20, 0x00])\nconst MASK = 0o7777\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexports.decodeLongPath = function decodeLongPath (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax\n  let result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  const pax = opts.pax\n  if (pax) {\n    for (const key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return b4a.from(result)\n}\n\nexports.decodePax = function decodePax (buf) {\n  const result = {}\n\n  while (buf.length) {\n    let i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    const len = parseInt(b4a.toString(buf.subarray(0, i)), 10)\n    if (!len) return result\n\n    const b = b4a.toString(buf.subarray(i + 1, len - 1))\n    const keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.subarray(len)\n  }\n\n  return result\n}\n\nexports.encode = function encode (opts) {\n  const buf = b4a.alloc(512)\n  let name = opts.name\n  let prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (b4a.byteLength(name) !== name.length) return null // utf-8\n\n  while (b4a.byteLength(name) > 100) {\n    const i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null\n  if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null\n\n  b4a.write(buf, name)\n  b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100)\n  b4a.write(buf, encodeOct(opts.uid, 6), 108)\n  b4a.write(buf, encodeOct(opts.gid, 6), 116)\n  encodeSize(opts.size, buf, 124)\n  b4a.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) b4a.write(buf, opts.linkname, 157)\n\n  b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET)\n  b4a.copy(USTAR_VER, buf, VERSION_OFFSET)\n  if (opts.uname) b4a.write(buf, opts.uname, 265)\n  if (opts.gname) b4a.write(buf, opts.gname, 297)\n  b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329)\n  b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) b4a.write(buf, prefix, 345)\n\n  b4a.write(buf, encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n    pax: null\n  }\n}\n\nfunction isUSTAR (buf) {\n  return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU (buf) {\n  return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n}\n\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction toType (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nfunction toTypeflag (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nfunction indexOf (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum (block) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nfunction encodeOct (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\nfunction encodeSizeBin (num, buf, off) {\n  buf[off] = 0x80\n  for (let i = 11; i > 0; i--) {\n    buf[off + i] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nfunction encodeSize (num, buf, off) {\n  if (num.toString(8).length > 11) {\n    encodeSizeBin(num, buf, off)\n  } else {\n    b4a.write(buf, encodeOct(num, 11), off)\n  }\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction decodeOct (val, offset, length) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(b4a.toString(val.subarray(offset, end)), 8)\n  }\n}\n\nfunction decodeStr (val, offset, length, encoding) {\n  return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n\nfunction addLength (str) {\n  const len = b4a.byteLength(str)\n  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsK0NBQUs7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2hlYWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYjRhID0gcmVxdWlyZSgnYjRhJylcblxuY29uc3QgWkVST1MgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMCdcbmNvbnN0IFNFVkVOUyA9ICc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3J1xuY29uc3QgWkVST19PRkZTRVQgPSAnMCcuY2hhckNvZGVBdCgwKVxuY29uc3QgVVNUQVJfTUFHSUMgPSBiNGEuZnJvbShbMHg3NSwgMHg3MywgMHg3NCwgMHg2MSwgMHg3MiwgMHgwMF0pIC8vIHVzdGFyXFx4MDBcbmNvbnN0IFVTVEFSX1ZFUiA9IGI0YS5mcm9tKFtaRVJPX09GRlNFVCwgWkVST19PRkZTRVRdKVxuY29uc3QgR05VX01BR0lDID0gYjRhLmZyb20oWzB4NzUsIDB4NzMsIDB4NzQsIDB4NjEsIDB4NzIsIDB4MjBdKSAvLyB1c3RhclxceDIwXG5jb25zdCBHTlVfVkVSID0gYjRhLmZyb20oWzB4MjAsIDB4MDBdKVxuY29uc3QgTUFTSyA9IDBvNzc3N1xuY29uc3QgTUFHSUNfT0ZGU0VUID0gMjU3XG5jb25zdCBWRVJTSU9OX09GRlNFVCA9IDI2M1xuXG5leHBvcnRzLmRlY29kZUxvbmdQYXRoID0gZnVuY3Rpb24gZGVjb2RlTG9uZ1BhdGggKGJ1ZiwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGRlY29kZVN0cihidWYsIDAsIGJ1Zi5sZW5ndGgsIGVuY29kaW5nKVxufVxuXG5leHBvcnRzLmVuY29kZVBheCA9IGZ1bmN0aW9uIGVuY29kZVBheCAob3B0cykgeyAvLyBUT0RPOiBlbmNvZGUgbW9yZSBzdHVmZiBpbiBwYXhcbiAgbGV0IHJlc3VsdCA9ICcnXG4gIGlmIChvcHRzLm5hbWUpIHJlc3VsdCArPSBhZGRMZW5ndGgoJyBwYXRoPScgKyBvcHRzLm5hbWUgKyAnXFxuJylcbiAgaWYgKG9wdHMubGlua25hbWUpIHJlc3VsdCArPSBhZGRMZW5ndGgoJyBsaW5rcGF0aD0nICsgb3B0cy5saW5rbmFtZSArICdcXG4nKVxuICBjb25zdCBwYXggPSBvcHRzLnBheFxuICBpZiAocGF4KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF4KSB7XG4gICAgICByZXN1bHQgKz0gYWRkTGVuZ3RoKCcgJyArIGtleSArICc9JyArIHBheFtrZXldICsgJ1xcbicpXG4gICAgfVxuICB9XG4gIHJldHVybiBiNGEuZnJvbShyZXN1bHQpXG59XG5cbmV4cG9ydHMuZGVjb2RlUGF4ID0gZnVuY3Rpb24gZGVjb2RlUGF4IChidWYpIHtcbiAgY29uc3QgcmVzdWx0ID0ge31cblxuICB3aGlsZSAoYnVmLmxlbmd0aCkge1xuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChpIDwgYnVmLmxlbmd0aCAmJiBidWZbaV0gIT09IDMyKSBpKytcbiAgICBjb25zdCBsZW4gPSBwYXJzZUludChiNGEudG9TdHJpbmcoYnVmLnN1YmFycmF5KDAsIGkpKSwgMTApXG4gICAgaWYgKCFsZW4pIHJldHVybiByZXN1bHRcblxuICAgIGNvbnN0IGIgPSBiNGEudG9TdHJpbmcoYnVmLnN1YmFycmF5KGkgKyAxLCBsZW4gLSAxKSlcbiAgICBjb25zdCBrZXlJbmRleCA9IGIuaW5kZXhPZignPScpXG4gICAgaWYgKGtleUluZGV4ID09PSAtMSkgcmV0dXJuIHJlc3VsdFxuICAgIHJlc3VsdFtiLnNsaWNlKDAsIGtleUluZGV4KV0gPSBiLnNsaWNlKGtleUluZGV4ICsgMSlcblxuICAgIGJ1ZiA9IGJ1Zi5zdWJhcnJheShsZW4pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlIChvcHRzKSB7XG4gIGNvbnN0IGJ1ZiA9IGI0YS5hbGxvYyg1MTIpXG4gIGxldCBuYW1lID0gb3B0cy5uYW1lXG4gIGxldCBwcmVmaXggPSAnJ1xuXG4gIGlmIChvcHRzLnR5cGVmbGFnID09PSA1ICYmIG5hbWVbbmFtZS5sZW5ndGggLSAxXSAhPT0gJy8nKSBuYW1lICs9ICcvJ1xuICBpZiAoYjRhLmJ5dGVMZW5ndGgobmFtZSkgIT09IG5hbWUubGVuZ3RoKSByZXR1cm4gbnVsbCAvLyB1dGYtOFxuXG4gIHdoaWxlIChiNGEuYnl0ZUxlbmd0aChuYW1lKSA+IDEwMCkge1xuICAgIGNvbnN0IGkgPSBuYW1lLmluZGV4T2YoJy8nKVxuICAgIGlmIChpID09PSAtMSkgcmV0dXJuIG51bGxcbiAgICBwcmVmaXggKz0gcHJlZml4ID8gJy8nICsgbmFtZS5zbGljZSgwLCBpKSA6IG5hbWUuc2xpY2UoMCwgaSlcbiAgICBuYW1lID0gbmFtZS5zbGljZShpICsgMSlcbiAgfVxuXG4gIGlmIChiNGEuYnl0ZUxlbmd0aChuYW1lKSA+IDEwMCB8fCBiNGEuYnl0ZUxlbmd0aChwcmVmaXgpID4gMTU1KSByZXR1cm4gbnVsbFxuICBpZiAob3B0cy5saW5rbmFtZSAmJiBiNGEuYnl0ZUxlbmd0aChvcHRzLmxpbmtuYW1lKSA+IDEwMCkgcmV0dXJuIG51bGxcblxuICBiNGEud3JpdGUoYnVmLCBuYW1lKVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy5tb2RlICYgTUFTSywgNiksIDEwMClcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMudWlkLCA2KSwgMTA4KVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy5naWQsIDYpLCAxMTYpXG4gIGVuY29kZVNpemUob3B0cy5zaXplLCBidWYsIDEyNClcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KChvcHRzLm10aW1lLmdldFRpbWUoKSAvIDEwMDApIHwgMCwgMTEpLCAxMzYpXG5cbiAgYnVmWzE1Nl0gPSBaRVJPX09GRlNFVCArIHRvVHlwZWZsYWcob3B0cy50eXBlKVxuXG4gIGlmIChvcHRzLmxpbmtuYW1lKSBiNGEud3JpdGUoYnVmLCBvcHRzLmxpbmtuYW1lLCAxNTcpXG5cbiAgYjRhLmNvcHkoVVNUQVJfTUFHSUMsIGJ1ZiwgTUFHSUNfT0ZGU0VUKVxuICBiNGEuY29weShVU1RBUl9WRVIsIGJ1ZiwgVkVSU0lPTl9PRkZTRVQpXG4gIGlmIChvcHRzLnVuYW1lKSBiNGEud3JpdGUoYnVmLCBvcHRzLnVuYW1lLCAyNjUpXG4gIGlmIChvcHRzLmduYW1lKSBiNGEud3JpdGUoYnVmLCBvcHRzLmduYW1lLCAyOTcpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLmRldm1ham9yIHx8IDAsIDYpLCAzMjkpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLmRldm1pbm9yIHx8IDAsIDYpLCAzMzcpXG5cbiAgaWYgKHByZWZpeCkgYjRhLndyaXRlKGJ1ZiwgcHJlZml4LCAzNDUpXG5cbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KGNrc3VtKGJ1ZiksIDYpLCAxNDgpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBmaWxlbmFtZUVuY29kaW5nLCBhbGxvd1Vua25vd25Gb3JtYXQpIHtcbiAgbGV0IHR5cGVmbGFnID0gYnVmWzE1Nl0gPT09IDAgPyAwIDogYnVmWzE1Nl0gLSBaRVJPX09GRlNFVFxuXG4gIGxldCBuYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMCwgMTAwLCBmaWxlbmFtZUVuY29kaW5nKVxuICBjb25zdCBtb2RlID0gZGVjb2RlT2N0KGJ1ZiwgMTAwLCA4KVxuICBjb25zdCB1aWQgPSBkZWNvZGVPY3QoYnVmLCAxMDgsIDgpXG4gIGNvbnN0IGdpZCA9IGRlY29kZU9jdChidWYsIDExNiwgOClcbiAgY29uc3Qgc2l6ZSA9IGRlY29kZU9jdChidWYsIDEyNCwgMTIpXG4gIGNvbnN0IG10aW1lID0gZGVjb2RlT2N0KGJ1ZiwgMTM2LCAxMilcbiAgY29uc3QgdHlwZSA9IHRvVHlwZSh0eXBlZmxhZylcbiAgY29uc3QgbGlua25hbWUgPSBidWZbMTU3XSA9PT0gMCA/IG51bGwgOiBkZWNvZGVTdHIoYnVmLCAxNTcsIDEwMCwgZmlsZW5hbWVFbmNvZGluZylcbiAgY29uc3QgdW5hbWUgPSBkZWNvZGVTdHIoYnVmLCAyNjUsIDMyKVxuICBjb25zdCBnbmFtZSA9IGRlY29kZVN0cihidWYsIDI5NywgMzIpXG4gIGNvbnN0IGRldm1ham9yID0gZGVjb2RlT2N0KGJ1ZiwgMzI5LCA4KVxuICBjb25zdCBkZXZtaW5vciA9IGRlY29kZU9jdChidWYsIDMzNywgOClcblxuICBjb25zdCBjID0gY2tzdW0oYnVmKVxuXG4gIC8vIGNoZWNrc3VtIGlzIHN0aWxsIGluaXRpYWwgdmFsdWUgaWYgaGVhZGVyIHdhcyBudWxsLlxuICBpZiAoYyA9PT0gOCAqIDMyKSByZXR1cm4gbnVsbFxuXG4gIC8vIHZhbGlkIGNoZWNrc3VtXG4gIGlmIChjICE9PSBkZWNvZGVPY3QoYnVmLCAxNDgsIDgpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyIGhlYWRlci4gTWF5YmUgdGhlIHRhciBpcyBjb3JydXB0ZWQgb3IgaXQgbmVlZHMgdG8gYmUgZ3VuemlwcGVkPycpXG5cbiAgaWYgKGlzVVNUQVIoYnVmKSkge1xuICAgIC8vIHVzdGFyIChwb3NpeCkgZm9ybWF0LlxuICAgIC8vIHByZXBlbmQgcHJlZml4LCBpZiBwcmVzZW50LlxuICAgIGlmIChidWZbMzQ1XSkgbmFtZSA9IGRlY29kZVN0cihidWYsIDM0NSwgMTU1LCBmaWxlbmFtZUVuY29kaW5nKSArICcvJyArIG5hbWVcbiAgfSBlbHNlIGlmIChpc0dOVShidWYpKSB7XG4gICAgLy8gJ2dudScvJ29sZGdudScgZm9ybWF0LiBTaW1pbGFyIHRvIHVzdGFyLCBidXQgaGFzIHN1cHBvcnQgZm9yIGluY3JlbWVudGFsIGFuZFxuICAgIC8vIG11bHRpLXZvbHVtZSB0YXJiYWxscy5cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWFsbG93VW5rbm93bkZvcm1hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhciBoZWFkZXI6IHVua25vd24gZm9ybWF0LicpXG4gICAgfVxuICB9XG5cbiAgLy8gdG8gc3VwcG9ydCBvbGQgdGFyIHZlcnNpb25zIHRoYXQgdXNlIHRyYWlsaW5nIC8gdG8gaW5kaWNhdGUgZGlyc1xuICBpZiAodHlwZWZsYWcgPT09IDAgJiYgbmFtZSAmJiBuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcvJykgdHlwZWZsYWcgPSA1XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIG1vZGUsXG4gICAgdWlkLFxuICAgIGdpZCxcbiAgICBzaXplLFxuICAgIG10aW1lOiBuZXcgRGF0ZSgxMDAwICogbXRpbWUpLFxuICAgIHR5cGUsXG4gICAgbGlua25hbWUsXG4gICAgdW5hbWUsXG4gICAgZ25hbWUsXG4gICAgZGV2bWFqb3IsXG4gICAgZGV2bWlub3IsXG4gICAgcGF4OiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVU1RBUiAoYnVmKSB7XG4gIHJldHVybiBiNGEuZXF1YWxzKFVTVEFSX01BR0lDLCBidWYuc3ViYXJyYXkoTUFHSUNfT0ZGU0VULCBNQUdJQ19PRkZTRVQgKyA2KSlcbn1cblxuZnVuY3Rpb24gaXNHTlUgKGJ1Zikge1xuICByZXR1cm4gYjRhLmVxdWFscyhHTlVfTUFHSUMsIGJ1Zi5zdWJhcnJheShNQUdJQ19PRkZTRVQsIE1BR0lDX09GRlNFVCArIDYpKSAmJlxuICAgIGI0YS5lcXVhbHMoR05VX1ZFUiwgYnVmLnN1YmFycmF5KFZFUlNJT05fT0ZGU0VULCBWRVJTSU9OX09GRlNFVCArIDIpKVxufVxuXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleCAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIHRvVHlwZSAoZmxhZykge1xuICBzd2l0Y2ggKGZsYWcpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gJ2ZpbGUnXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuICdsaW5rJ1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAnc3ltbGluaydcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gJ2NoYXJhY3Rlci1kZXZpY2UnXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICdibG9jay1kZXZpY2UnXG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuICdkaXJlY3RvcnknXG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuICdmaWZvJ1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiAnY29udGlndW91cy1maWxlJ1xuICAgIGNhc2UgNzI6XG4gICAgICByZXR1cm4gJ3BheC1oZWFkZXInXG4gICAgY2FzZSA1NTpcbiAgICAgIHJldHVybiAncGF4LWdsb2JhbC1oZWFkZXInXG4gICAgY2FzZSAyNzpcbiAgICAgIHJldHVybiAnZ251LWxvbmctbGluay1wYXRoJ1xuICAgIGNhc2UgMjg6XG4gICAgY2FzZSAzMDpcbiAgICAgIHJldHVybiAnZ251LWxvbmctcGF0aCdcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHRvVHlwZWZsYWcgKGZsYWcpIHtcbiAgc3dpdGNoIChmbGFnKSB7XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gMFxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgcmV0dXJuIDFcbiAgICBjYXNlICdzeW1saW5rJzpcbiAgICAgIHJldHVybiAyXG4gICAgY2FzZSAnY2hhcmFjdGVyLWRldmljZSc6XG4gICAgICByZXR1cm4gM1xuICAgIGNhc2UgJ2Jsb2NrLWRldmljZSc6XG4gICAgICByZXR1cm4gNFxuICAgIGNhc2UgJ2RpcmVjdG9yeSc6XG4gICAgICByZXR1cm4gNVxuICAgIGNhc2UgJ2ZpZm8nOlxuICAgICAgcmV0dXJuIDZcbiAgICBjYXNlICdjb250aWd1b3VzLWZpbGUnOlxuICAgICAgcmV0dXJuIDdcbiAgICBjYXNlICdwYXgtaGVhZGVyJzpcbiAgICAgIHJldHVybiA3MlxuICB9XG5cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoYmxvY2ssIG51bSwgb2Zmc2V0LCBlbmQpIHtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYmxvY2tbb2Zmc2V0XSA9PT0gbnVtKSByZXR1cm4gb2Zmc2V0XG4gIH1cbiAgcmV0dXJuIGVuZFxufVxuXG5mdW5jdGlvbiBja3N1bSAoYmxvY2spIHtcbiAgbGV0IHN1bSA9IDggKiAzMlxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE0ODsgaSsrKSBzdW0gKz0gYmxvY2tbaV1cbiAgZm9yIChsZXQgaiA9IDE1NjsgaiA8IDUxMjsgaisrKSBzdW0gKz0gYmxvY2tbal1cbiAgcmV0dXJuIHN1bVxufVxuXG5mdW5jdGlvbiBlbmNvZGVPY3QgKHZhbCwgbikge1xuICB2YWwgPSB2YWwudG9TdHJpbmcoOClcbiAgaWYgKHZhbC5sZW5ndGggPiBuKSByZXR1cm4gU0VWRU5TLnNsaWNlKDAsIG4pICsgJyAnXG4gIHJldHVybiBaRVJPUy5zbGljZSgwLCBuIC0gdmFsLmxlbmd0aCkgKyB2YWwgKyAnICdcbn1cblxuZnVuY3Rpb24gZW5jb2RlU2l6ZUJpbiAobnVtLCBidWYsIG9mZikge1xuICBidWZbb2ZmXSA9IDB4ODBcbiAgZm9yIChsZXQgaSA9IDExOyBpID4gMDsgaS0tKSB7XG4gICAgYnVmW29mZiArIGldID0gbnVtICYgMHhmZlxuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlU2l6ZSAobnVtLCBidWYsIG9mZikge1xuICBpZiAobnVtLnRvU3RyaW5nKDgpLmxlbmd0aCA+IDExKSB7XG4gICAgZW5jb2RlU2l6ZUJpbihudW0sIGJ1Ziwgb2ZmKVxuICB9IGVsc2Uge1xuICAgIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChudW0sIDExKSwgb2ZmKVxuICB9XG59XG5cbi8qIENvcGllZCBmcm9tIHRoZSBub2RlLXRhciByZXBvIGFuZCBtb2RpZmllZCB0byBtZWV0XG4gKiB0YXItc3RyZWFtIGNvZGluZyBzdGFuZGFyZC5cbiAqXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vbm9kZS10YXIvYmxvYi81MWI2NjI3YTFmMzU3ZDJlYjQzM2U3Mzc4ZTVmMDVlODNiN2FhNmNkL2xpYi9oZWFkZXIuanMjTDM0OVxuICovXG5mdW5jdGlvbiBwYXJzZTI1NiAoYnVmKSB7XG4gIC8vIGZpcnN0IGJ5dGUgTVVTVCBiZSBlaXRoZXIgODAgb3IgRkZcbiAgLy8gODAgZm9yIHBvc2l0aXZlLCBGRiBmb3IgMidzIGNvbXBcbiAgbGV0IHBvc2l0aXZlXG4gIGlmIChidWZbMF0gPT09IDB4ODApIHBvc2l0aXZlID0gdHJ1ZVxuICBlbHNlIGlmIChidWZbMF0gPT09IDB4RkYpIHBvc2l0aXZlID0gZmFsc2VcbiAgZWxzZSByZXR1cm4gbnVsbFxuXG4gIC8vIGJ1aWxkIHVwIGEgYmFzZS0yNTYgdHVwbGUgZnJvbSB0aGUgbGVhc3Qgc2lnIHRvIHRoZSBoaWdoZXN0XG4gIGNvbnN0IHR1cGxlID0gW11cbiAgbGV0IGlcbiAgZm9yIChpID0gYnVmLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBieXRlID0gYnVmW2ldXG4gICAgaWYgKHBvc2l0aXZlKSB0dXBsZS5wdXNoKGJ5dGUpXG4gICAgZWxzZSB0dXBsZS5wdXNoKDB4RkYgLSBieXRlKVxuICB9XG5cbiAgbGV0IHN1bSA9IDBcbiAgY29uc3QgbCA9IHR1cGxlLmxlbmd0aFxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgc3VtICs9IHR1cGxlW2ldICogTWF0aC5wb3coMjU2LCBpKVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aXZlID8gc3VtIDogLTEgKiBzdW1cbn1cblxuZnVuY3Rpb24gZGVjb2RlT2N0ICh2YWwsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhbCA9IHZhbC5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aClcbiAgb2Zmc2V0ID0gMFxuXG4gIC8vIElmIHByZWZpeGVkIHdpdGggMHg4MCB0aGVuIHBhcnNlIGFzIGEgYmFzZS0yNTYgaW50ZWdlclxuICBpZiAodmFsW29mZnNldF0gJiAweDgwKSB7XG4gICAgcmV0dXJuIHBhcnNlMjU2KHZhbClcbiAgfSBlbHNlIHtcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiB0YXIgY2FuIHByZWZpeCB3aXRoIHNwYWNlc1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWwubGVuZ3RoICYmIHZhbFtvZmZzZXRdID09PSAzMikgb2Zmc2V0KytcbiAgICBjb25zdCBlbmQgPSBjbGFtcChpbmRleE9mKHZhbCwgMzIsIG9mZnNldCwgdmFsLmxlbmd0aCksIHZhbC5sZW5ndGgsIHZhbC5sZW5ndGgpXG4gICAgd2hpbGUgKG9mZnNldCA8IGVuZCAmJiB2YWxbb2Zmc2V0XSA9PT0gMCkgb2Zmc2V0KytcbiAgICBpZiAoZW5kID09PSBvZmZzZXQpIHJldHVybiAwXG4gICAgcmV0dXJuIHBhcnNlSW50KGI0YS50b1N0cmluZyh2YWwuc3ViYXJyYXkob2Zmc2V0LCBlbmQpKSwgOClcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVTdHIgKHZhbCwgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiNGEudG9TdHJpbmcodmFsLnN1YmFycmF5KG9mZnNldCwgaW5kZXhPZih2YWwsIDAsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSksIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhZGRMZW5ndGggKHN0cikge1xuICBjb25zdCBsZW4gPSBiNGEuYnl0ZUxlbmd0aChzdHIpXG4gIGxldCBkaWdpdHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKGxlbikgLyBNYXRoLmxvZygxMCkpICsgMVxuICBpZiAobGVuICsgZGlnaXRzID49IE1hdGgucG93KDEwLCBkaWdpdHMpKSBkaWdpdHMrK1xuXG4gIHJldHVybiAobGVuICsgZGlnaXRzKSArIHN0clxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/tar-stream/headers.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/tar-stream/index.js":
/*!*******************************************!*\
  !*** ../node_modules/tar-stream/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.extract = __webpack_require__(/*! ./extract */ \"(rsc)/../node_modules/tar-stream/extract.js\")\nexports.pack = __webpack_require__(/*! ./pack */ \"(rsc)/../node_modules/tar-stream/pack.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEscUdBQXNDO0FBQ3RDLDRGQUFnQyIsInNvdXJjZXMiOlsiL1VzZXJzL3plbGFsZW1tZWtvbm5lbi9EZXNrdG9wL1BpeGVsUGVhay9wcm9qZWN0cy9sYWJlbC1jcmVhdGluZy1hcHAvbGFiZWwtY3JlYXRpbmctYXBwL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZXh0cmFjdCA9IHJlcXVpcmUoJy4vZXh0cmFjdCcpXG5leHBvcnRzLnBhY2sgPSByZXF1aXJlKCcuL3BhY2snKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/tar-stream/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/tar-stream/pack.js":
/*!******************************************!*\
  !*** ../node_modules/tar-stream/pack.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Readable, Writable, getStreamError } = __webpack_require__(/*! streamx */ \"(rsc)/../node_modules/streamx/index.js\")\nconst b4a = __webpack_require__(/*! b4a */ \"(rsc)/../node_modules/b4a/index.js\")\n\nconst constants = __webpack_require__(/*! ./constants */ \"(rsc)/../node_modules/tar-stream/constants.js\")\nconst headers = __webpack_require__(/*! ./headers */ \"(rsc)/../node_modules/tar-stream/headers.js\")\n\nconst DMODE = 0o755\nconst FMODE = 0o644\n\nconst END_OF_TAR = b4a.alloc(1024)\n\nclass Sink extends Writable {\n  constructor (pack, header, callback) {\n    super({ mapWritable, eagerOpen: true })\n\n    this.written = 0\n    this.header = header\n\n    this._callback = callback\n    this._linkname = null\n    this._isLinkname = header.type === 'symlink' && !header.linkname\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'\n    this._finished = false\n    this._pack = pack\n    this._openCallback = null\n\n    if (this._pack._stream === null) this._pack._stream = this\n    else this._pack._pending.push(this)\n  }\n\n  _open (cb) {\n    this._openCallback = cb\n    if (this._pack._stream === this) this._continueOpen()\n  }\n\n  _continuePack (err) {\n    if (this._callback === null) return\n\n    const callback = this._callback\n    this._callback = null\n\n    callback(err)\n  }\n\n  _continueOpen () {\n    if (this._pack._stream === null) this._pack._stream = this\n\n    const cb = this._openCallback\n    this._openCallback = null\n    if (cb === null) return\n\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))\n\n    this._pack._stream = this\n\n    if (!this._isLinkname) {\n      this._pack._encode(this.header)\n    }\n\n    if (this._isVoid) {\n      this._finish()\n      this._continuePack(null)\n    }\n\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data\n      return cb(null)\n    }\n\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'))\n      }\n      return cb()\n    }\n\n    this.written += data.byteLength\n    if (this._pack.push(data)) return cb()\n    this._pack._drain = cb\n  }\n\n  _finish () {\n    if (this._finished) return\n    this._finished = true\n\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''\n      this._pack._encode(this.header)\n    }\n\n    overflow(this._pack, this.header.size)\n\n    this._pack._done(this)\n  }\n\n  _final (cb) {\n    if (this.written !== this.header.size) { // corrupting tar\n      return cb(new Error('Size mismatch'))\n    }\n\n    this._finish()\n    cb(null)\n  }\n\n  _getError () {\n    return getStreamError(this) || new Error('tar entry destroyed')\n  }\n\n  _predestroy () {\n    this._pack.destroy(this._getError())\n  }\n\n  _destroy (cb) {\n    this._pack._done(this)\n\n    this._continuePack(this._finished ? null : this._getError())\n\n    cb()\n  }\n}\n\nclass Pack extends Readable {\n  constructor (opts) {\n    super(opts)\n    this._drain = noop\n    this._finalized = false\n    this._finalizing = false\n    this._pending = []\n    this._stream = null\n  }\n\n  entry (header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')\n\n    if (typeof buffer === 'function') {\n      callback = buffer\n      buffer = null\n    }\n\n    if (!callback) callback = noop\n\n    if (!header.size || header.type === 'symlink') header.size = 0\n    if (!header.type) header.type = modeToType(header.mode)\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n    if (!header.uid) header.uid = 0\n    if (!header.gid) header.gid = 0\n    if (!header.mtime) header.mtime = new Date()\n\n    if (typeof buffer === 'string') buffer = b4a.from(buffer)\n\n    const sink = new Sink(this, header, callback)\n\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength\n      sink.write(buffer)\n      sink.end()\n      return sink\n    }\n\n    if (sink._isVoid) {\n      return sink\n    }\n\n    return sink\n  }\n\n  finalize () {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true\n      return\n    }\n\n    if (this._finalized) return\n    this._finalized = true\n\n    this.push(END_OF_TAR)\n    this.push(null)\n  }\n\n  _done (stream) {\n    if (stream !== this._stream) return\n\n    this._stream = null\n\n    if (this._finalizing) this.finalize()\n    if (this._pending.length) this._pending.shift()._continueOpen()\n  }\n\n  _encode (header) {\n    if (!header.pax) {\n      const buf = headers.encode(header)\n      if (buf) {\n        this.push(buf)\n        return\n      }\n    }\n    this._encodePax(header)\n  }\n\n  _encodePax (header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    })\n\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    }\n\n    this.push(headers.encode(newHeader))\n    this.push(paxHeader)\n    overflow(this, paxHeader.byteLength)\n\n    newHeader.size = header.size\n    newHeader.type = header.type\n    this.push(headers.encode(newHeader))\n  }\n\n  _doDrain () {\n    const drain = this._drain\n    this._drain = noop\n    drain()\n  }\n\n  _predestroy () {\n    const err = getStreamError(this)\n\n    if (this._stream) this._stream.destroy(err)\n\n    while (this._pending.length) {\n      const stream = this._pending.shift()\n      stream.destroy(err)\n      stream._continueOpen()\n    }\n\n    this._doDrain()\n  }\n\n  _read (cb) {\n    this._doDrain()\n    cb()\n  }\n}\n\nmodule.exports = function pack (opts) {\n  return new Pack(opts)\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nfunction noop () {}\n\nfunction overflow (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))\n}\n\nfunction mapWritable (buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vcGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMsdURBQVM7QUFDaEUsWUFBWSxtQkFBTyxDQUFDLCtDQUFLOztBQUV6QixrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBVzs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemVsYWxlbW1la29ubmVuL0Rlc2t0b3AvUGl4ZWxQZWFrL3Byb2plY3RzL2xhYmVsLWNyZWF0aW5nLWFwcC9sYWJlbC1jcmVhdGluZy1hcHAvbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vcGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFJlYWRhYmxlLCBXcml0YWJsZSwgZ2V0U3RyZWFtRXJyb3IgfSA9IHJlcXVpcmUoJ3N0cmVhbXgnKVxuY29uc3QgYjRhID0gcmVxdWlyZSgnYjRhJylcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgaGVhZGVycyA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5cbmNvbnN0IERNT0RFID0gMG83NTVcbmNvbnN0IEZNT0RFID0gMG82NDRcblxuY29uc3QgRU5EX09GX1RBUiA9IGI0YS5hbGxvYygxMDI0KVxuXG5jbGFzcyBTaW5rIGV4dGVuZHMgV3JpdGFibGUge1xuICBjb25zdHJ1Y3RvciAocGFjaywgaGVhZGVyLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKHsgbWFwV3JpdGFibGUsIGVhZ2VyT3BlbjogdHJ1ZSB9KVxuXG4gICAgdGhpcy53cml0dGVuID0gMFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG5cbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5fbGlua25hbWUgPSBudWxsXG4gICAgdGhpcy5faXNMaW5rbmFtZSA9IGhlYWRlci50eXBlID09PSAnc3ltbGluaycgJiYgIWhlYWRlci5saW5rbmFtZVxuICAgIHRoaXMuX2lzVm9pZCA9IGhlYWRlci50eXBlICE9PSAnZmlsZScgJiYgaGVhZGVyLnR5cGUgIT09ICdjb250aWd1b3VzLWZpbGUnXG4gICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZVxuICAgIHRoaXMuX3BhY2sgPSBwYWNrXG4gICAgdGhpcy5fb3BlbkNhbGxiYWNrID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuX3BhY2suX3N0cmVhbSA9PT0gbnVsbCkgdGhpcy5fcGFjay5fc3RyZWFtID0gdGhpc1xuICAgIGVsc2UgdGhpcy5fcGFjay5fcGVuZGluZy5wdXNoKHRoaXMpXG4gIH1cblxuICBfb3BlbiAoY2IpIHtcbiAgICB0aGlzLl9vcGVuQ2FsbGJhY2sgPSBjYlxuICAgIGlmICh0aGlzLl9wYWNrLl9zdHJlYW0gPT09IHRoaXMpIHRoaXMuX2NvbnRpbnVlT3BlbigpXG4gIH1cblxuICBfY29udGludWVQYWNrIChlcnIpIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2sgPT09IG51bGwpIHJldHVyblxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFja1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG5cbiAgX2NvbnRpbnVlT3BlbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhY2suX3N0cmVhbSA9PT0gbnVsbCkgdGhpcy5fcGFjay5fc3RyZWFtID0gdGhpc1xuXG4gICAgY29uc3QgY2IgPSB0aGlzLl9vcGVuQ2FsbGJhY2tcbiAgICB0aGlzLl9vcGVuQ2FsbGJhY2sgPSBudWxsXG4gICAgaWYgKGNiID09PSBudWxsKSByZXR1cm5cblxuICAgIGlmICh0aGlzLl9wYWNrLmRlc3Ryb3lpbmcpIHJldHVybiBjYihuZXcgRXJyb3IoJ3BhY2sgc3RyZWFtIGRlc3Ryb3llZCcpKVxuICAgIGlmICh0aGlzLl9wYWNrLl9maW5hbGl6ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ3BhY2sgc3RyZWFtIGlzIGFscmVhZHkgZmluYWxpemVkJykpXG5cbiAgICB0aGlzLl9wYWNrLl9zdHJlYW0gPSB0aGlzXG5cbiAgICBpZiAoIXRoaXMuX2lzTGlua25hbWUpIHtcbiAgICAgIHRoaXMuX3BhY2suX2VuY29kZSh0aGlzLmhlYWRlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNWb2lkKSB7XG4gICAgICB0aGlzLl9maW5pc2goKVxuICAgICAgdGhpcy5fY29udGludWVQYWNrKG51bGwpXG4gICAgfVxuXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICBpZiAodGhpcy5faXNMaW5rbmFtZSkge1xuICAgICAgdGhpcy5fbGlua25hbWUgPSB0aGlzLl9saW5rbmFtZSA/IGI0YS5jb25jYXQoW3RoaXMuX2xpbmtuYW1lLCBkYXRhXSkgOiBkYXRhXG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNWb2lkKSB7XG4gICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdObyBib2R5IGFsbG93ZWQgZm9yIHRoaXMgZW50cnknKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYigpXG4gICAgfVxuXG4gICAgdGhpcy53cml0dGVuICs9IGRhdGEuYnl0ZUxlbmd0aFxuICAgIGlmICh0aGlzLl9wYWNrLnB1c2goZGF0YSkpIHJldHVybiBjYigpXG4gICAgdGhpcy5fcGFjay5fZHJhaW4gPSBjYlxuICB9XG5cbiAgX2ZpbmlzaCAoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm5cbiAgICB0aGlzLl9maW5pc2hlZCA9IHRydWVcblxuICAgIGlmICh0aGlzLl9pc0xpbmtuYW1lKSB7XG4gICAgICB0aGlzLmhlYWRlci5saW5rbmFtZSA9IHRoaXMuX2xpbmtuYW1lID8gYjRhLnRvU3RyaW5nKHRoaXMuX2xpbmtuYW1lLCAndXRmLTgnKSA6ICcnXG4gICAgICB0aGlzLl9wYWNrLl9lbmNvZGUodGhpcy5oZWFkZXIpXG4gICAgfVxuXG4gICAgb3ZlcmZsb3codGhpcy5fcGFjaywgdGhpcy5oZWFkZXIuc2l6ZSlcblxuICAgIHRoaXMuX3BhY2suX2RvbmUodGhpcylcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICBpZiAodGhpcy53cml0dGVuICE9PSB0aGlzLmhlYWRlci5zaXplKSB7IC8vIGNvcnJ1cHRpbmcgdGFyXG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdTaXplIG1pc21hdGNoJykpXG4gICAgfVxuXG4gICAgdGhpcy5fZmluaXNoKClcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX2dldEVycm9yICgpIHtcbiAgICByZXR1cm4gZ2V0U3RyZWFtRXJyb3IodGhpcykgfHwgbmV3IEVycm9yKCd0YXIgZW50cnkgZGVzdHJveWVkJylcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9wYWNrLmRlc3Ryb3kodGhpcy5fZ2V0RXJyb3IoKSlcbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIHRoaXMuX3BhY2suX2RvbmUodGhpcylcblxuICAgIHRoaXMuX2NvbnRpbnVlUGFjayh0aGlzLl9maW5pc2hlZCA/IG51bGwgOiB0aGlzLl9nZXRFcnJvcigpKVxuXG4gICAgY2IoKVxuICB9XG59XG5cbmNsYXNzIFBhY2sgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9kcmFpbiA9IG5vb3BcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxuICAgIHRoaXMuX2ZpbmFsaXppbmcgPSBmYWxzZVxuICAgIHRoaXMuX3BlbmRpbmcgPSBbXVxuICAgIHRoaXMuX3N0cmVhbSA9IG51bGxcbiAgfVxuXG4gIGVudHJ5IChoZWFkZXIsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fZmluYWxpemVkIHx8IHRoaXMuZGVzdHJveWluZykgdGhyb3cgbmV3IEVycm9yKCdhbHJlYWR5IGZpbmFsaXplZCBvciBkZXN0cm95ZWQnKVxuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYnVmZmVyXG4gICAgICBidWZmZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wXG5cbiAgICBpZiAoIWhlYWRlci5zaXplIHx8IGhlYWRlci50eXBlID09PSAnc3ltbGluaycpIGhlYWRlci5zaXplID0gMFxuICAgIGlmICghaGVhZGVyLnR5cGUpIGhlYWRlci50eXBlID0gbW9kZVRvVHlwZShoZWFkZXIubW9kZSlcbiAgICBpZiAoIWhlYWRlci5tb2RlKSBoZWFkZXIubW9kZSA9IGhlYWRlci50eXBlID09PSAnZGlyZWN0b3J5JyA/IERNT0RFIDogRk1PREVcbiAgICBpZiAoIWhlYWRlci51aWQpIGhlYWRlci51aWQgPSAwXG4gICAgaWYgKCFoZWFkZXIuZ2lkKSBoZWFkZXIuZ2lkID0gMFxuICAgIGlmICghaGVhZGVyLm10aW1lKSBoZWFkZXIubXRpbWUgPSBuZXcgRGF0ZSgpXG5cbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIGJ1ZmZlciA9IGI0YS5mcm9tKGJ1ZmZlcilcblxuICAgIGNvbnN0IHNpbmsgPSBuZXcgU2luayh0aGlzLCBoZWFkZXIsIGNhbGxiYWNrKVxuXG4gICAgaWYgKGI0YS5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICBoZWFkZXIuc2l6ZSA9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICBzaW5rLndyaXRlKGJ1ZmZlcilcbiAgICAgIHNpbmsuZW5kKClcbiAgICAgIHJldHVybiBzaW5rXG4gICAgfVxuXG4gICAgaWYgKHNpbmsuX2lzVm9pZCkge1xuICAgICAgcmV0dXJuIHNpbmtcbiAgICB9XG5cbiAgICByZXR1cm4gc2lua1xuICB9XG5cbiAgZmluYWxpemUgKCkge1xuICAgIGlmICh0aGlzLl9zdHJlYW0gfHwgdGhpcy5fcGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9maW5hbGl6aW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgcmV0dXJuXG4gICAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuXG4gICAgdGhpcy5wdXNoKEVORF9PRl9UQVIpXG4gICAgdGhpcy5wdXNoKG51bGwpXG4gIH1cblxuICBfZG9uZSAoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbSAhPT0gdGhpcy5fc3RyZWFtKSByZXR1cm5cblxuICAgIHRoaXMuX3N0cmVhbSA9IG51bGxcblxuICAgIGlmICh0aGlzLl9maW5hbGl6aW5nKSB0aGlzLmZpbmFsaXplKClcbiAgICBpZiAodGhpcy5fcGVuZGluZy5sZW5ndGgpIHRoaXMuX3BlbmRpbmcuc2hpZnQoKS5fY29udGludWVPcGVuKClcbiAgfVxuXG4gIF9lbmNvZGUgKGhlYWRlcikge1xuICAgIGlmICghaGVhZGVyLnBheCkge1xuICAgICAgY29uc3QgYnVmID0gaGVhZGVycy5lbmNvZGUoaGVhZGVyKVxuICAgICAgaWYgKGJ1Zikge1xuICAgICAgICB0aGlzLnB1c2goYnVmKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZW5jb2RlUGF4KGhlYWRlcilcbiAgfVxuXG4gIF9lbmNvZGVQYXggKGhlYWRlcikge1xuICAgIGNvbnN0IHBheEhlYWRlciA9IGhlYWRlcnMuZW5jb2RlUGF4KHtcbiAgICAgIG5hbWU6IGhlYWRlci5uYW1lLFxuICAgICAgbGlua25hbWU6IGhlYWRlci5saW5rbmFtZSxcbiAgICAgIHBheDogaGVhZGVyLnBheFxuICAgIH0pXG5cbiAgICBjb25zdCBuZXdIZWFkZXIgPSB7XG4gICAgICBuYW1lOiAnUGF4SGVhZGVyJyxcbiAgICAgIG1vZGU6IGhlYWRlci5tb2RlLFxuICAgICAgdWlkOiBoZWFkZXIudWlkLFxuICAgICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgICAgc2l6ZTogcGF4SGVhZGVyLmJ5dGVMZW5ndGgsXG4gICAgICBtdGltZTogaGVhZGVyLm10aW1lLFxuICAgICAgdHlwZTogJ3BheC1oZWFkZXInLFxuICAgICAgbGlua25hbWU6IGhlYWRlci5saW5rbmFtZSAmJiAnUGF4SGVhZGVyJyxcbiAgICAgIHVuYW1lOiBoZWFkZXIudW5hbWUsXG4gICAgICBnbmFtZTogaGVhZGVyLmduYW1lLFxuICAgICAgZGV2bWFqb3I6IGhlYWRlci5kZXZtYWpvcixcbiAgICAgIGRldm1pbm9yOiBoZWFkZXIuZGV2bWlub3JcbiAgICB9XG5cbiAgICB0aGlzLnB1c2goaGVhZGVycy5lbmNvZGUobmV3SGVhZGVyKSlcbiAgICB0aGlzLnB1c2gocGF4SGVhZGVyKVxuICAgIG92ZXJmbG93KHRoaXMsIHBheEhlYWRlci5ieXRlTGVuZ3RoKVxuXG4gICAgbmV3SGVhZGVyLnNpemUgPSBoZWFkZXIuc2l6ZVxuICAgIG5ld0hlYWRlci50eXBlID0gaGVhZGVyLnR5cGVcbiAgICB0aGlzLnB1c2goaGVhZGVycy5lbmNvZGUobmV3SGVhZGVyKSlcbiAgfVxuXG4gIF9kb0RyYWluICgpIHtcbiAgICBjb25zdCBkcmFpbiA9IHRoaXMuX2RyYWluXG4gICAgdGhpcy5fZHJhaW4gPSBub29wXG4gICAgZHJhaW4oKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIGNvbnN0IGVyciA9IGdldFN0cmVhbUVycm9yKHRoaXMpXG5cbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZGVzdHJveShlcnIpXG5cbiAgICB3aGlsZSAodGhpcy5fcGVuZGluZy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3BlbmRpbmcuc2hpZnQoKVxuICAgICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgICAgc3RyZWFtLl9jb250aW51ZU9wZW4oKVxuICAgIH1cblxuICAgIHRoaXMuX2RvRHJhaW4oKVxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgdGhpcy5fZG9EcmFpbigpXG4gICAgY2IoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFjayAob3B0cykge1xuICByZXR1cm4gbmV3IFBhY2sob3B0cylcbn1cblxuZnVuY3Rpb24gbW9kZVRvVHlwZSAobW9kZSkge1xuICBzd2l0Y2ggKG1vZGUgJiBjb25zdGFudHMuU19JRk1UKSB7XG4gICAgY2FzZSBjb25zdGFudHMuU19JRkJMSzogcmV0dXJuICdibG9jay1kZXZpY2UnXG4gICAgY2FzZSBjb25zdGFudHMuU19JRkNIUjogcmV0dXJuICdjaGFyYWN0ZXItZGV2aWNlJ1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZESVI6IHJldHVybiAnZGlyZWN0b3J5J1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZJRk86IHJldHVybiAnZmlmbydcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGTE5LOiByZXR1cm4gJ3N5bWxpbmsnXG4gIH1cblxuICByZXR1cm4gJ2ZpbGUnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gb3ZlcmZsb3cgKHNlbGYsIHNpemUpIHtcbiAgc2l6ZSAmPSA1MTFcbiAgaWYgKHNpemUpIHNlbGYucHVzaChFTkRfT0ZfVEFSLnN1YmFycmF5KDAsIDUxMiAtIHNpemUpKVxufVxuXG5mdW5jdGlvbiBtYXBXcml0YWJsZSAoYnVmKSB7XG4gIHJldHVybiBiNGEuaXNCdWZmZXIoYnVmKSA/IGJ1ZiA6IGI0YS5mcm9tKGJ1Zilcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/tar-stream/pack.js\n");

/***/ })

};
;