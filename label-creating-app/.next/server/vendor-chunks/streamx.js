/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/streamx";
exports.ids = ["vendor-chunks/streamx"];
exports.modules = {

/***/ "(rsc)/../node_modules/streamx/index.js":
/*!****************************************!*\
  !*** ../node_modules/streamx/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { EventEmitter } = __webpack_require__(/*! events */ \"events\")\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = __webpack_require__(/*! queue-tick */ \"(rsc)/../node_modules/queue-tick/process-next-tick.js\")\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/../node_modules/fast-fifo/index.js\")\nconst TextDecoder = __webpack_require__(/*! text-decoder */ \"(rsc)/../node_modules/text-decoder/index.js\")\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbXgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN6QztBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyxpRUFBYzs7QUFFMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLGlGQUFpRixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixpRkFBaUYsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsOEJBQThCO0FBQzVGO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvc3RyZWFteC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFNUUkVBTV9ERVNUUk9ZRUQgPSBuZXcgRXJyb3IoJ1N0cmVhbSB3YXMgZGVzdHJveWVkJylcbmNvbnN0IFBSRU1BVFVSRV9DTE9TRSA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJylcblxuY29uc3QgcXVldWVUaWNrID0gcmVxdWlyZSgncXVldWUtdGljaycpXG5jb25zdCBGSUZPID0gcmVxdWlyZSgnZmFzdC1maWZvJylcbmNvbnN0IFRleHREZWNvZGVyID0gcmVxdWlyZSgndGV4dC1kZWNvZGVyJylcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzICovXG5cbi8vIDI5IGJpdHMgdXNlZCB0b3RhbCAoNCBmcm9tIHNoYXJlZCwgMTQgZnJvbSByZWFkLCBhbmQgMTEgZnJvbSB3cml0ZSlcbmNvbnN0IE1BWCA9ICgoMSA8PCAyOSkgLSAxKVxuXG4vLyBTaGFyZWQgc3RhdGVcbmNvbnN0IE9QRU5JTkcgICAgICAgPSAwYjAwMDFcbmNvbnN0IFBSRURFU1RST1lJTkcgPSAwYjAwMTBcbmNvbnN0IERFU1RST1lJTkcgICAgPSAwYjAxMDBcbmNvbnN0IERFU1RST1lFRCAgICAgPSAwYjEwMDBcblxuY29uc3QgTk9UX09QRU5JTkcgPSBNQVggXiBPUEVOSU5HXG5jb25zdCBOT1RfUFJFREVTVFJPWUlORyA9IE1BWCBeIFBSRURFU1RST1lJTkdcblxuLy8gUmVhZCBzdGF0ZSAoNCBiaXQgb2Zmc2V0IGZyb20gc2hhcmVkIHN0YXRlKVxuY29uc3QgUkVBRF9BQ1RJVkUgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMDAwMSA8PCA0XG5jb25zdCBSRUFEX1VQREFUSU5HICAgICAgICAgPSAwYjAwMDAwMDAwMDAwMDEwIDw8IDRcbmNvbnN0IFJFQURfUFJJTUFSWSAgICAgICAgICA9IDBiMDAwMDAwMDAwMDAxMDAgPDwgNFxuY29uc3QgUkVBRF9RVUVVRUQgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMTAwMCA8PCA0XG5jb25zdCBSRUFEX1JFU1VNRUQgICAgICAgICAgPSAwYjAwMDAwMDAwMDEwMDAwIDw8IDRcbmNvbnN0IFJFQURfUElQRV9EUkFJTkVEICAgICA9IDBiMDAwMDAwMDAxMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTkRJTkcgICAgICAgICAgID0gMGIwMDAwMDAwMTAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0VNSVRfREFUQSAgICAgICAgPSAwYjAwMDAwMDEwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRSAgICA9IDBiMDAwMDAxMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTUlUVEVEX1JFQURBQkxFID0gMGIwMDAwMTAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0RPTkUgICAgICAgICAgICAgPSAwYjAwMDEwMDAwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfTkVYVF9USUNLICAgICAgICA9IDBiMDAxMDAwMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9ORUVEU19QVVNIICAgICAgID0gMGIwMTAwMDAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX1JFQURfQUhFQUQgICAgICAgPSAwYjEwMDAwMDAwMDAwMDAwIDw8IDRcblxuLy8gQ29tYmluZWQgcmVhZCBzdGF0ZVxuY29uc3QgUkVBRF9GTE9XSU5HID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9QSVBFX0RSQUlORURcbmNvbnN0IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIID0gUkVBRF9BQ1RJVkUgfCBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUFJJTUFSWV9BTkRfQUNUSVZFID0gUkVBRF9QUklNQVJZIHwgUkVBRF9BQ1RJVkVcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRV9BTkRfUVVFVUVEID0gUkVBRF9FTUlUX1JFQURBQkxFIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfUkVTVU1FRF9SRUFEX0FIRUFEID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9SRUFEX0FIRUFEXG5cbmNvbnN0IFJFQURfTk9UX0FDVElWRSAgICAgICAgICAgICA9IE1BWCBeIFJFQURfQUNUSVZFXG5jb25zdCBSRUFEX05PTl9QUklNQVJZICAgICAgICAgICAgPSBNQVggXiBSRUFEX1BSSU1BUllcbmNvbnN0IFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRCA9IE1BWCBeIChSRUFEX1BSSU1BUlkgfCBSRUFEX05FRURTX1BVU0gpXG5jb25zdCBSRUFEX1BVU0hFRCAgICAgICAgICAgICAgICAgPSBNQVggXiBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUEFVU0VEICAgICAgICAgICAgICAgICA9IE1BWCBeIFJFQURfUkVTVU1FRFxuY29uc3QgUkVBRF9OT1RfUVVFVUVEICAgICAgICAgICAgID0gTUFYIF4gKFJFQURfUVVFVUVEIHwgUkVBRF9FTUlUVEVEX1JFQURBQkxFKVxuY29uc3QgUkVBRF9OT1RfRU5ESU5HICAgICAgICAgICAgID0gTUFYIF4gUkVBRF9FTkRJTkdcbmNvbnN0IFJFQURfUElQRV9OT1RfRFJBSU5FRCAgICAgICA9IE1BWCBeIFJFQURfRkxPV0lOR1xuY29uc3QgUkVBRF9OT1RfTkVYVF9USUNLICAgICAgICAgID0gTUFYIF4gUkVBRF9ORVhUX1RJQ0tcbmNvbnN0IFJFQURfTk9UX1VQREFUSU5HICAgICAgICAgICA9IE1BWCBeIFJFQURfVVBEQVRJTkdcbmNvbnN0IFJFQURfTk9fUkVBRF9BSEVBRCAgICAgICAgICA9IE1BWCBeIFJFQURfUkVBRF9BSEVBRFxuY29uc3QgUkVBRF9QQVVTRURfTk9fUkVBRF9BSEVBRCAgID0gTUFYIF4gUkVBRF9SRVNVTUVEX1JFQURfQUhFQURcblxuLy8gV3JpdGUgc3RhdGUgKDE4IGJpdCBvZmZzZXQsIDQgYml0IG9mZnNldCBmcm9tIHNoYXJlZCBzdGF0ZSBhbmQgMTQgZnJvbSByZWFkIHN0YXRlKVxuY29uc3QgV1JJVEVfQUNUSVZFICAgICA9IDBiMDAwMDAwMDAwMDEgPDwgMThcbmNvbnN0IFdSSVRFX1VQREFUSU5HICAgPSAwYjAwMDAwMDAwMDEwIDw8IDE4XG5jb25zdCBXUklURV9QUklNQVJZICAgID0gMGIwMDAwMDAwMDEwMCA8PCAxOFxuY29uc3QgV1JJVEVfUVVFVUVEICAgICA9IDBiMDAwMDAwMDEwMDAgPDwgMThcbmNvbnN0IFdSSVRFX1VORFJBSU5FRCAgPSAwYjAwMDAwMDEwMDAwIDw8IDE4XG5jb25zdCBXUklURV9ET05FICAgICAgID0gMGIwMDAwMDEwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRU1JVF9EUkFJTiA9IDBiMDAwMDEwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX05FWFRfVElDSyAgPSAwYjAwMDEwMDAwMDAwIDw8IDE4XG5jb25zdCBXUklURV9XUklUSU5HICAgID0gMGIwMDEwMDAwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRklOSVNISU5HICA9IDBiMDEwMDAwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX0NPUktFRCAgICAgPSAwYjEwMDAwMDAwMDAwIDw8IDE4XG5cbmNvbnN0IFdSSVRFX05PVF9BQ1RJVkUgICAgPSBNQVggXiAoV1JJVEVfQUNUSVZFIHwgV1JJVEVfV1JJVElORylcbmNvbnN0IFdSSVRFX05PTl9QUklNQVJZICAgPSBNQVggXiBXUklURV9QUklNQVJZXG5jb25zdCBXUklURV9OT1RfRklOSVNISU5HID0gTUFYIF4gKFdSSVRFX0FDVElWRSB8IFdSSVRFX0ZJTklTSElORylcbmNvbnN0IFdSSVRFX0RSQUlORUQgICAgICAgPSBNQVggXiBXUklURV9VTkRSQUlORURcbmNvbnN0IFdSSVRFX05PVF9RVUVVRUQgICAgPSBNQVggXiBXUklURV9RVUVVRURcbmNvbnN0IFdSSVRFX05PVF9ORVhUX1RJQ0sgPSBNQVggXiBXUklURV9ORVhUX1RJQ0tcbmNvbnN0IFdSSVRFX05PVF9VUERBVElORyAgPSBNQVggXiBXUklURV9VUERBVElOR1xuY29uc3QgV1JJVEVfTk9UX0NPUktFRCAgICA9IE1BWCBeIFdSSVRFX0NPUktFRFxuXG4vLyBDb21iaW5lZCBzaGFyZWQgc3RhdGVcbmNvbnN0IEFDVElWRSA9IFJFQURfQUNUSVZFIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBOT1RfQUNUSVZFID0gTUFYIF4gQUNUSVZFXG5jb25zdCBET05FID0gUkVBRF9ET05FIHwgV1JJVEVfRE9ORVxuY29uc3QgREVTVFJPWV9TVEFUVVMgPSBERVNUUk9ZSU5HIHwgREVTVFJPWUVEIHwgUFJFREVTVFJPWUlOR1xuY29uc3QgT1BFTl9TVEFUVVMgPSBERVNUUk9ZX1NUQVRVUyB8IE9QRU5JTkdcbmNvbnN0IEFVVE9fREVTVFJPWSA9IERFU1RST1lfU1RBVFVTIHwgRE9ORVxuY29uc3QgTk9OX1BSSU1BUlkgPSBXUklURV9OT05fUFJJTUFSWSAmIFJFQURfTk9OX1BSSU1BUllcbmNvbnN0IEFDVElWRV9PUl9USUNLSU5HID0gV1JJVEVfTkVYVF9USUNLIHwgUkVBRF9ORVhUX1RJQ0tcbmNvbnN0IFRJQ0tJTkcgPSBBQ1RJVkVfT1JfVElDS0lORyAmIE5PVF9BQ1RJVkVcbmNvbnN0IElTX09QRU5JTkcgPSBPUEVOX1NUQVRVUyB8IFRJQ0tJTkdcblxuLy8gQ29tYmluZWQgc2hhcmVkIHN0YXRlIGFuZCByZWFkIHN0YXRlXG5jb25zdCBSRUFEX1BSSU1BUllfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0VORElORyB8IFJFQURfRE9ORVxuY29uc3QgUkVBRF9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRE9ORSB8IFJFQURfUVVFVUVEXG5jb25zdCBSRUFEX0VORElOR19TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRU5ESU5HIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfUkVBREFCTEVfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0VNSVRfUkVBREFCTEUgfCBSRUFEX1FVRVVFRCB8IFJFQURfRU1JVFRFRF9SRUFEQUJMRVxuY29uc3QgU0hPVUxEX05PVF9SRUFEID0gT1BFTl9TVEFUVVMgfCBSRUFEX0FDVElWRSB8IFJFQURfRU5ESU5HIHwgUkVBRF9ET05FIHwgUkVBRF9ORUVEU19QVVNIIHwgUkVBRF9SRUFEX0FIRUFEXG5jb25zdCBSRUFEX0JBQ0tQUkVTU1VSRV9TVEFUVVMgPSBERVNUUk9ZX1NUQVRVUyB8IFJFQURfRU5ESU5HIHwgUkVBRF9ET05FXG5jb25zdCBSRUFEX1VQREFURV9TWU5DX1NUQVRVUyA9IFJFQURfVVBEQVRJTkcgfCBPUEVOX1NUQVRVUyB8IFJFQURfTkVYVF9USUNLIHwgUkVBRF9QUklNQVJZXG5jb25zdCBSRUFEX05FWFRfVElDS19PUl9PUEVOSU5HID0gUkVBRF9ORVhUX1RJQ0sgfCBPUEVOSU5HXG5cbi8vIENvbWJpbmVkIHdyaXRlIHN0YXRlXG5jb25zdCBXUklURV9QUklNQVJZX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfUVVFVUVEX0FORF9VTkRSQUlORUQgPSBXUklURV9RVUVVRUQgfCBXUklURV9VTkRSQUlORURcbmNvbnN0IFdSSVRFX1FVRVVFRF9BTkRfQUNUSVZFID0gV1JJVEVfUVVFVUVEIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBXUklURV9EUkFJTl9TVEFUVVMgPSBXUklURV9RVUVVRUQgfCBXUklURV9VTkRSQUlORUQgfCBPUEVOX1NUQVRVUyB8IFdSSVRFX0FDVElWRVxuY29uc3QgV1JJVEVfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBXUklURV9BQ1RJVkUgfCBXUklURV9RVUVVRUQgfCBXUklURV9DT1JLRURcbmNvbnN0IFdSSVRFX1BSSU1BUllfQU5EX0FDVElWRSA9IFdSSVRFX1BSSU1BUlkgfCBXUklURV9BQ1RJVkVcbmNvbnN0IFdSSVRFX0FDVElWRV9BTkRfV1JJVElORyA9IFdSSVRFX0FDVElWRSB8IFdSSVRFX1dSSVRJTkdcbmNvbnN0IFdSSVRFX0ZJTklTSElOR19TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX1FVRVVFRF9BTkRfQUNUSVZFIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfQkFDS1BSRVNTVVJFX1NUQVRVUyA9IFdSSVRFX1VORFJBSU5FRCB8IERFU1RST1lfU1RBVFVTIHwgV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfVVBEQVRFX1NZTkNfU1RBVFVTID0gV1JJVEVfVVBEQVRJTkcgfCBPUEVOX1NUQVRVUyB8IFdSSVRFX05FWFRfVElDSyB8IFdSSVRFX1BSSU1BUllcbmNvbnN0IFdSSVRFX0RST1BfREFUQSA9IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX0RPTkUgfCBERVNUUk9ZX1NUQVRVU1xuXG5jb25zdCBhc3luY0l0ZXJhdG9yID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgU3ltYm9sKCdhc3luY0l0ZXJhdG9yJylcblxuY2xhc3MgV3JpdGFibGVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChzdHJlYW0sIHsgaGlnaFdhdGVyTWFyayA9IDE2Mzg0LCBtYXAgPSBudWxsLCBtYXBXcml0YWJsZSwgYnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aFdyaXRhYmxlIH0gPSB7fSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBGSUZPKClcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMucGlwZWxpbmUgPSBudWxsXG4gICAgdGhpcy5kcmFpbnMgPSBudWxsIC8vIGlmIHdlIGFkZCBtb3JlIHNlbGRvbWx5IHVzZWQgaGVscGVycyB3ZSBtaWdodCB0aGVtIGludG8gYSBzdWJvYmplY3Qgc28gaXRzIGEgc2luZ2xlIHB0clxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhXcml0YWJsZSB8fCBieXRlTGVuZ3RoIHx8IGRlZmF1bHRCeXRlTGVuZ3RoXG4gICAgdGhpcy5tYXAgPSBtYXBXcml0YWJsZSB8fCBtYXBcbiAgICB0aGlzLmFmdGVyV3JpdGUgPSBhZnRlcldyaXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2sgPSB1cGRhdGVXcml0ZU5ULmJpbmQodGhpcylcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9ET05FKSAhPT0gMFxuICB9XG5cbiAgcHVzaCAoZGF0YSkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRFJPUF9EQVRBKSAhPT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSBkYXRhID0gdGhpcy5tYXAoZGF0YSlcblxuICAgIHRoaXMuYnVmZmVyZWQgKz0gdGhpcy5ieXRlTGVuZ3RoKGRhdGEpXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpXG5cbiAgICBpZiAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyaykge1xuICAgICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX1FVRVVFRFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfUVVFVUVEX0FORF9VTkRSQUlORURcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5xdWV1ZS5zaGlmdCgpXG5cbiAgICB0aGlzLmJ1ZmZlcmVkIC09IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkID09PSAwKSB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1FVRVVFRFxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGVuZCAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5zdHJlYW0ub25jZSgnZmluaXNoJywgZGF0YSlcbiAgICBlbHNlIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbCkgdGhpcy5wdXNoKGRhdGEpXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlID0gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFdSSVRFX0ZJTklTSElORykgJiBXUklURV9OT05fUFJJTUFSWVxuICB9XG5cbiAgYXV0b0JhdGNoIChkYXRhLCBjYikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfU1RBVFVTKSA9PT0gV1JJVEVfUVVFVUVEX0FORF9BQ1RJVkUpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5zaGlmdCgpKVxuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIE9QRU5fU1RBVFVTKSAhPT0gMCkgcmV0dXJuIGNiKG51bGwpXG4gICAgc3RyZWFtLl93cml0ZXYoYnVmZmVyLCBjYilcbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHdoaWxlICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1NUQVRVUykgPT09IFdSSVRFX1FVRVVFRCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5zaGlmdCgpXG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQUNUSVZFX0FORF9XUklUSU5HXG4gICAgICAgIHN0cmVhbS5fd3JpdGUoZGF0YSwgdGhpcy5hZnRlcldyaXRlKVxuICAgICAgfVxuXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1VQREFUSU5HXG4gIH1cblxuICB1cGRhdGVOb25QcmltYXJ5ICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRklOSVNISU5HX1NUQVRVUykgPT09IFdSSVRFX0ZJTklTSElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IHN0cmVhbS5fZHVwbGV4U3RhdGUgfCBXUklURV9BQ1RJVkVcbiAgICAgIHN0cmVhbS5fZmluYWwoYWZ0ZXJGaW5hbC5iaW5kKHRoaXMpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpID09PSBERVNUUk9ZSU5HKSB7XG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBQ1RJVkVfT1JfVElDS0lORykgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBBQ1RJVkVcbiAgICAgICAgc3RyZWFtLl9kZXN0cm95KGFmdGVyRGVzdHJveS5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgSVNfT1BFTklORykgPT09IE9QRU5JTkcpIHtcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IEFDVElWRSkgJiBOT1RfT1BFTklOR1xuICAgICAgc3RyZWFtLl9vcGVuKGFmdGVyT3Blbi5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIGNvbnRpbnVlVXBkYXRlICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX05FWFRfVElDSykgPT09IDApIHJldHVybiBmYWxzZVxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFURV9TWU5DX1NUQVRVUykgPT09IFdSSVRFX1BSSU1BUlkpIHRoaXMudXBkYXRlKClcbiAgICBlbHNlIHRoaXMudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfTkVYVF9USUNLKSAhPT0gMCkgcmV0dXJuXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX05FWFRfVElDS1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSBxdWV1ZVRpY2sodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG59XG5cbmNsYXNzIFJlYWRhYmxlU3RhdGUge1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtLCB7IGhpZ2hXYXRlck1hcmsgPSAxNjM4NCwgbWFwID0gbnVsbCwgbWFwUmVhZGFibGUsIGJ5dGVMZW5ndGgsIGJ5dGVMZW5ndGhSZWFkYWJsZSB9ID0ge30pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICAgIHRoaXMucXVldWUgPSBuZXcgRklGTygpXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayA9PT0gMCA/IDEgOiBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLnJlYWRBaGVhZCA9IGhpZ2hXYXRlck1hcmsgPiAwXG4gICAgdGhpcy5lcnJvciA9IG51bGxcbiAgICB0aGlzLnBpcGVsaW5lID0gbnVsbFxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhSZWFkYWJsZSB8fCBieXRlTGVuZ3RoIHx8IGRlZmF1bHRCeXRlTGVuZ3RoXG4gICAgdGhpcy5tYXAgPSBtYXBSZWFkYWJsZSB8fCBtYXBcbiAgICB0aGlzLnBpcGVUbyA9IG51bGxcbiAgICB0aGlzLmFmdGVyUmVhZCA9IGFmdGVyUmVhZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrID0gdXBkYXRlUmVhZE5ULmJpbmQodGhpcylcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpICE9PSAwXG4gIH1cblxuICBwaXBlIChwaXBlVG8sIGNiKSB7XG4gICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHBpcGUgdG8gb25lIGRlc3RpbmF0aW9uJylcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG51bGxcblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1BJUEVfRFJBSU5FRFxuICAgIHRoaXMucGlwZVRvID0gcGlwZVRvXG4gICAgdGhpcy5waXBlbGluZSA9IG5ldyBQaXBlbGluZSh0aGlzLnN0cmVhbSwgcGlwZVRvLCBjYilcblxuICAgIGlmIChjYikgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcblxuICAgIGlmIChpc1N0cmVhbXgocGlwZVRvKSkge1xuICAgICAgcGlwZVRvLl93cml0YWJsZVN0YXRlLnBpcGVsaW5lID0gdGhpcy5waXBlbGluZVxuICAgICAgaWYgKGNiKSBwaXBlVG8ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcbiAgICAgIHBpcGVUby5vbignZmluaXNoJywgdGhpcy5waXBlbGluZS5maW5pc2hlZC5iaW5kKHRoaXMucGlwZWxpbmUpKSAvLyBUT0RPOiBqdXN0IGNhbGwgZmluaXNoZWQgZnJvbSBwaXBlVG8gaXRzZWxmXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9uZXJyb3IgPSB0aGlzLnBpcGVsaW5lLmRvbmUuYmluZCh0aGlzLnBpcGVsaW5lLCBwaXBlVG8pXG4gICAgICBjb25zdCBvbmNsb3NlID0gdGhpcy5waXBlbGluZS5kb25lLmJpbmQodGhpcy5waXBlbGluZSwgcGlwZVRvLCBudWxsKSAvLyBvbmNsb3NlIGhhcyBhIHdlaXJkIGJvb2wgYXJnXG4gICAgICBwaXBlVG8ub24oJ2Vycm9yJywgb25lcnJvcilcbiAgICAgIHBpcGVUby5vbignY2xvc2UnLCBvbmNsb3NlKVxuICAgICAgcGlwZVRvLm9uKCdmaW5pc2gnLCB0aGlzLnBpcGVsaW5lLmZpbmlzaGVkLmJpbmQodGhpcy5waXBlbGluZSkpXG4gICAgfVxuXG4gICAgcGlwZVRvLm9uKCdkcmFpbicsIGFmdGVyRHJhaW4uYmluZCh0aGlzKSlcbiAgICB0aGlzLnN0cmVhbS5lbWl0KCdwaXBpbmcnLCBwaXBlVG8pXG4gICAgcGlwZVRvLmVtaXQoJ3BpcGUnLCB0aGlzLnN0cmVhbSlcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFJFQURfRU5ESU5HKSAmIFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSB7XG4gICAgICBkYXRhID0gdGhpcy5tYXAoZGF0YSlcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QVVNIRURcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWQgPCB0aGlzLmhpZ2hXYXRlck1hcmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlcmVkICs9IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9RVUVVRUQpICYgUkVBRF9QVVNIRURcblxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkIDwgdGhpcy5oaWdoV2F0ZXJNYXJrXG4gIH1cblxuICBzaGlmdCAoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucXVldWUuc2hpZnQoKVxuXG4gICAgdGhpcy5idWZmZXJlZCAtPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICBpZiAodGhpcy5idWZmZXJlZCA9PT0gMCkgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9UX1FVRVVFRFxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICB1bnNoaWZ0IChkYXRhKSB7XG4gICAgY29uc3QgcGVuZGluZyA9IFt0aGlzLm1hcCAhPT0gbnVsbCA/IHRoaXMubWFwKGRhdGEpIDogZGF0YV1cbiAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA+IDApIHBlbmRpbmcucHVzaCh0aGlzLnNoaWZ0KCkpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gcGVuZGluZ1tpXVxuICAgICAgdGhpcy5idWZmZXJlZCArPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuICAgIH1cblxuICAgIHRoaXMucHVzaChwZW5kaW5nW3BlbmRpbmcubGVuZ3RoIC0gMV0pXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hpZnQoKVxuICAgICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsICYmIHRoaXMucGlwZVRvLndyaXRlKGRhdGEpID09PSBmYWxzZSkgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX1BJUEVfTk9UX0RSQUlORURcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRU1JVF9EQVRBKSAhPT0gMCkgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkQWhlYWQgPT09IGZhbHNlKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUkVBRF9BSEVBRFxuICAgICAgdGhpcy51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGRyYWluICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRkxPV0lORykgIT09IDApIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNoaWZ0KClcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCAmJiB0aGlzLnBpcGVUby53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QSVBFX05PVF9EUkFJTkVEXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VNSVRfREFUQSkgIT09IDApIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICB1cGRhdGUgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuZHJhaW4oKVxuXG4gICAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyayAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFNIT1VMRF9OT1RfUkVBRCkgPT09IFJFQURfUkVBRF9BSEVBRCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIXG4gICAgICAgIHN0cmVhbS5fcmVhZCh0aGlzLmFmdGVyUmVhZClcbiAgICAgICAgdGhpcy5kcmFpbigpXG4gICAgICB9XG5cbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVBREFCTEVfU1RBVFVTKSA9PT0gUkVBRF9FTUlUX1JFQURBQkxFX0FORF9RVUVVRUQpIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX0VNSVRURURfUkVBREFCTEVcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIH1cblxuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfVVBEQVRJTkdcbiAgfVxuXG4gIHVwZGF0ZU5vblByaW1hcnkgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VORElOR19TVEFUVVMpID09PSBSRUFEX0VORElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9ET05FKSAmIFJFQURfTk9UX0VORElOR1xuICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBVVRPX0RFU1RST1kpID09PSBET05FKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lJTkdcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCkgdGhpcy5waXBlVG8uZW5kKClcbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IERFU1RST1lJTkcpIHtcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFDVElWRV9PUl9USUNLSU5HKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IEFDVElWRVxuICAgICAgICBzdHJlYW0uX2Rlc3Ryb3koYWZ0ZXJEZXN0cm95LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBJU19PUEVOSU5HKSA9PT0gT1BFTklORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgQUNUSVZFKSAmIE5PVF9PUEVOSU5HXG4gICAgICBzdHJlYW0uX29wZW4oYWZ0ZXJPcGVuLmJpbmQodGhpcykpXG4gICAgfVxuICB9XG5cbiAgY29udGludWVVcGRhdGUgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0spID09PSAwKSByZXR1cm4gZmFsc2VcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRFX1NZTkNfU1RBVFVTKSA9PT0gUkVBRF9QUklNQVJZKSB0aGlzLnVwZGF0ZSgpXG4gICAgZWxzZSB0aGlzLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIHVwZGF0ZU5leHRUaWNrSWZPcGVuICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfTkVYVF9USUNLX09SX09QRU5JTkcpICE9PSAwKSByZXR1cm5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9ORVhUX1RJQ0tcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRJTkcpID09PSAwKSBxdWV1ZVRpY2sodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0spICE9PSAwKSByZXR1cm5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9ORVhUX1RJQ0tcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRJTkcpID09PSAwKSBxdWV1ZVRpY2sodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybVN0YXRlIHtcbiAgY29uc3RydWN0b3IgKHN0cmVhbSkge1xuICAgIHRoaXMuZGF0YSA9IG51bGxcbiAgICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gYWZ0ZXJUcmFuc2Zvcm0uYmluZChzdHJlYW0pXG4gICAgdGhpcy5hZnRlckZpbmFsID0gbnVsbFxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZHN0LCBjYikge1xuICAgIHRoaXMuZnJvbSA9IHNyY1xuICAgIHRoaXMudG8gPSBkc3RcbiAgICB0aGlzLmFmdGVyUGlwZSA9IGNiXG4gICAgdGhpcy5lcnJvciA9IG51bGxcbiAgICB0aGlzLnBpcGVUb0ZpbmlzaGVkID0gZmFsc2VcbiAgfVxuXG4gIGZpbmlzaGVkICgpIHtcbiAgICB0aGlzLnBpcGVUb0ZpbmlzaGVkID0gdHJ1ZVxuICB9XG5cbiAgZG9uZSAoc3RyZWFtLCBlcnIpIHtcbiAgICBpZiAoZXJyKSB0aGlzLmVycm9yID0gZXJyXG5cbiAgICBpZiAoc3RyZWFtID09PSB0aGlzLnRvKSB7XG4gICAgICB0aGlzLnRvID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5mcm9tICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgodGhpcy5mcm9tLl9kdXBsZXhTdGF0ZSAmIFJFQURfRE9ORSkgPT09IDAgfHwgIXRoaXMucGlwZVRvRmluaXNoZWQpIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGVzdHJveSh0aGlzLmVycm9yIHx8IG5ldyBFcnJvcignV3JpdGFibGUgc3RyZWFtIGNsb3NlZCBwcmVtYXR1cmVseScpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJlYW0gPT09IHRoaXMuZnJvbSkge1xuICAgICAgdGhpcy5mcm9tID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy50byAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy50by5kZXN0cm95KHRoaXMuZXJyb3IgfHwgbmV3IEVycm9yKCdSZWFkYWJsZSBzdHJlYW0gY2xvc2VkIGJlZm9yZSBlbmRpbmcnKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZnRlclBpcGUgIT09IG51bGwpIHRoaXMuYWZ0ZXJQaXBlKHRoaXMuZXJyb3IpXG4gICAgdGhpcy50byA9IHRoaXMuZnJvbSA9IHRoaXMuYWZ0ZXJQaXBlID0gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyRHJhaW4gKCkge1xuICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9QSVBFX0RSQUlORURcbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyRmluYWwgKGVycikge1xuICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuICBpZiAoZXJyKSBzdHJlYW0uZGVzdHJveShlcnIpXG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSA9PT0gMCkge1xuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfRE9ORVxuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKVxuICB9XG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFVVE9fREVTVFJPWSkgPT09IERPTkUpIHtcbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lJTkdcbiAgfVxuXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0ZJTklTSElOR1xuXG4gIC8vIG5vIG5lZWQgdG8gd2FpdCB0aGUgZXh0cmEgdGljayBoZXJlLCBzbyB3ZSBzaG9ydCBjaXJjdWl0IHRoYXRcbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSB0aGlzLnVwZGF0ZSgpXG4gIGVsc2UgdGhpcy51cGRhdGVOZXh0VGljaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyRGVzdHJveSAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKCFlcnIgJiYgdGhpcy5lcnJvciAhPT0gU1RSRUFNX0RFU1RST1lFRCkgZXJyID0gdGhpcy5lcnJvclxuICBpZiAoZXJyKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gREVTVFJPWUVEXG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpXG5cbiAgY29uc3QgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcblxuICBpZiAocnMgIT09IG51bGwgJiYgcnMucGlwZWxpbmUgIT09IG51bGwpIHJzLnBpcGVsaW5lLmRvbmUoc3RyZWFtLCBlcnIpXG5cbiAgaWYgKHdzICE9PSBudWxsKSB7XG4gICAgd2hpbGUgKHdzLmRyYWlucyAhPT0gbnVsbCAmJiB3cy5kcmFpbnMubGVuZ3RoID4gMCkgd3MuZHJhaW5zLnNoaWZ0KCkucmVzb2x2ZShmYWxzZSlcbiAgICBpZiAod3MucGlwZWxpbmUgIT09IG51bGwpIHdzLnBpcGVsaW5lLmRvbmUoc3RyZWFtLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZSAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKGVycikgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9BQ1RJVkVcblxuICBpZiAodGhpcy5kcmFpbnMgIT09IG51bGwpIHRpY2tEcmFpbnModGhpcy5kcmFpbnMpXG5cbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRFJBSU5fU1RBVFVTKSA9PT0gV1JJVEVfVU5EUkFJTkVEKSB7XG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9EUkFJTkVEXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRU1JVF9EUkFJTikgPT09IFdSSVRFX0VNSVRfRFJBSU4pIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyUmVhZCAoZXJyKSB7XG4gIGlmIChlcnIpIHRoaXMuc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfQUNUSVZFXG4gIGlmICh0aGlzLnJlYWRBaGVhZCA9PT0gZmFsc2UgJiYgKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVTVU1FRCkgPT09IDApIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PX1JFQURfQUhFQURcbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWROVCAoKSB7XG4gIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9VUERBVElORykgPT09IDApIHtcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfTkVYVF9USUNLXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyaXRlTlQgKCkge1xuICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFUSU5HKSA9PT0gMCkge1xuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfTkVYVF9USUNLXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRpY2tEcmFpbnMgKGRyYWlucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYWlucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGRyYWlucy53cml0ZXMgYXJlIG1vbm90b25pYywgc28gaWYgb25lIGlzIDAgaXRzIGFsd2F5cyB0aGUgZmlyc3Qgb25lXG4gICAgaWYgKC0tZHJhaW5zW2ldLndyaXRlcyA9PT0gMCkge1xuICAgICAgZHJhaW5zLnNoaWZ0KCkucmVzb2x2ZSh0cnVlKVxuICAgICAgaS0tXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyT3BlbiAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKGVycikgc3RyZWFtLmRlc3Ryb3koZXJyKVxuXG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lJTkcpID09PSAwKSB7XG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9QUklNQVJZX1NUQVRVUykgPT09IDApIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9QUklNQVJZXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfUFJJTUFSWV9TVEFUVVMpID09PSAwKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX1BSSU1BUllcbiAgICBzdHJlYW0uZW1pdCgnb3BlbicpXG4gIH1cblxuICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IE5PVF9BQ1RJVkVcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLnVwZGF0ZUNhbGxiYWNrKClcbiAgfVxuXG4gIGlmIChzdHJlYW0uX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUudXBkYXRlQ2FsbGJhY2soKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtIChlcnIsIGRhdGEpIHtcbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB0aGlzLnB1c2goZGF0YSlcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5hZnRlcldyaXRlKGVycilcbn1cblxuZnVuY3Rpb24gbmV3TGlzdGVuZXIgKG5hbWUpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSAoUkVBRF9FTUlUX0RBVEEgfCBSRUFEX1JFU1VNRURfUkVBRF9BSEVBRClcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gUkVBRF9FTUlUX1JFQURBQkxFXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuYW1lID09PSAnZHJhaW4nKSB7XG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9FTUlUX0RSQUlOXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSA9IDBcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbnVsbFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBudWxsXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMub3BlbikgdGhpcy5fb3BlbiA9IG9wdHMub3BlblxuICAgICAgaWYgKG9wdHMuZGVzdHJveSkgdGhpcy5fZGVzdHJveSA9IG9wdHMuZGVzdHJveVxuICAgICAgaWYgKG9wdHMucHJlZGVzdHJveSkgdGhpcy5fcHJlZGVzdHJveSA9IG9wdHMucHJlZGVzdHJveVxuICAgICAgaWYgKG9wdHMuc2lnbmFsKSB7XG4gICAgICAgIG9wdHMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQuYmluZCh0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIG5ld0xpc3RlbmVyKVxuICB9XG5cbiAgX29wZW4gKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgLy8gZG9lcyBub3RoaW5nXG4gIH1cblxuICBnZXQgcmVhZGFibGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IHdyaXRhYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZRUQpICE9PSAwXG4gIH1cblxuICBnZXQgZGVzdHJveWluZyAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSAhPT0gMFxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKCh0aGlzLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSA9PT0gMCkge1xuICAgICAgaWYgKCFlcnIpIGVyciA9IFNUUkVBTV9ERVNUUk9ZRURcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlID0gKHRoaXMuX2R1cGxleFN0YXRlIHwgREVTVFJPWUlORykgJiBOT05fUFJJTUFSWVxuXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmsgPSAwXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3IgPSBlcnJcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvciA9IGVyclxuICAgICAgfVxuXG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBQUkVERVNUUk9ZSU5HXG4gICAgICB0aGlzLl9wcmVkZXN0cm95KClcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlICY9IE5PVF9QUkVERVNUUk9ZSU5HXG5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsKSB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVhZGFibGUgZXh0ZW5kcyBTdHJlYW0ge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBPUEVOSU5HIHwgV1JJVEVfRE9ORSB8IFJFQURfUkVBRF9BSEVBRFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZSh0aGlzLCBvcHRzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRBaGVhZCA9PT0gZmFsc2UpIHRoaXMuX2R1cGxleFN0YXRlICY9IFJFQURfTk9fUkVBRF9BSEVBRFxuICAgICAgaWYgKG9wdHMucmVhZCkgdGhpcy5fcmVhZCA9IG9wdHMucmVhZFxuICAgICAgaWYgKG9wdHMuZWFnZXJPcGVuKSB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICAgIGlmIChvcHRzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKG9wdHMuZW5jb2RpbmcpXG4gICAgfVxuICB9XG5cbiAgc2V0RW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgZGVjID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKVxuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUubWFwIHx8IGVjaG9cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm1hcCA9IG1hcE9yU2tpcFxuICAgIHJldHVybiB0aGlzXG5cbiAgICBmdW5jdGlvbiBtYXBPclNraXAgKGRhdGEpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBkZWMucHVzaChkYXRhKVxuICAgICAgcmV0dXJuIG5leHQgPT09ICcnICYmIChkYXRhLmJ5dGVMZW5ndGggIT09IDAgfHwgZGVjLnJlbWFpbmluZyA+IDApID8gbnVsbCA6IG1hcChuZXh0KVxuICAgIH1cbiAgfVxuXG4gIF9yZWFkIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBwaXBlIChkZXN0LCBjYikge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucGlwZShkZXN0LCBjYilcbiAgICByZXR1cm4gZGVzdFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZCgpXG4gIH1cblxuICBwdXNoIChkYXRhKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGlja0lmT3BlbigpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgdW5zaGlmdCAoZGF0YSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2tJZk9wZW4oKVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLnVuc2hpZnQoZGF0YSlcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gUkVBRF9SRVNVTUVEX1JFQURfQUhFQURcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlICY9ICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRBaGVhZCA9PT0gZmFsc2UgPyBSRUFEX1BBVVNFRF9OT19SRUFEX0FIRUFEIDogUkVBRF9QQVVTRUQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXRpYyBfZnJvbUFzeW5jSXRlcmF0b3IgKGl0ZSwgb3B0cykge1xuICAgIGxldCBkZXN0cm95XG5cbiAgICBjb25zdCBycyA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCAoY2IpIHtcbiAgICAgICAgaXRlLm5leHQoKS50aGVuKHB1c2gpLnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICB9LFxuICAgICAgcHJlZGVzdHJveSAoKSB7XG4gICAgICAgIGRlc3Ryb3kgPSBpdGUucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICBkZXN0cm95IChjYikge1xuICAgICAgICBpZiAoIWRlc3Ryb3kpIHJldHVybiBjYihudWxsKVxuICAgICAgICBkZXN0cm95LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByc1xuXG4gICAgZnVuY3Rpb24gcHVzaCAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZG9uZSkgcnMucHVzaChudWxsKVxuICAgICAgZWxzZSBycy5wdXNoKGRhdGEudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb20gKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoaXNSZWFkU3RyZWFteChkYXRhKSkgcmV0dXJuIGRhdGFcbiAgICBpZiAoZGF0YVthc3luY0l0ZXJhdG9yXSkgcmV0dXJuIHRoaXMuX2Zyb21Bc3luY0l0ZXJhdG9yKGRhdGFbYXN5bmNJdGVyYXRvcl0oKSwgb3B0cylcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyBbXSA6IFtkYXRhXVxuXG4gICAgbGV0IGkgPSAwXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCAoY2IpIHtcbiAgICAgICAgdGhpcy5wdXNoKGkgPT09IGRhdGEubGVuZ3RoID8gbnVsbCA6IGRhdGFbaSsrXSlcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGlzQmFja3ByZXNzdXJlZCAocnMpIHtcbiAgICByZXR1cm4gKHJzLl9kdXBsZXhTdGF0ZSAmIFJFQURfQkFDS1BSRVNTVVJFX1NUQVRVUykgIT09IDAgfHwgcnMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyZWQgPj0gcnMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya1xuICB9XG5cbiAgc3RhdGljIGlzUGF1c2VkIChycykge1xuICAgIHJldHVybiAocnMuX2R1cGxleFN0YXRlICYgUkVBRF9SRVNVTUVEKSA9PT0gMFxuICB9XG5cbiAgW2FzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzXG5cbiAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgbGV0IHByb21pc2VSZXNvbHZlID0gbnVsbFxuICAgIGxldCBwcm9taXNlUmVqZWN0ID0gbnVsbFxuXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7IGVycm9yID0gZXJyIH0pXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHRoaXMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIHJldHVybiB7XG4gICAgICBbYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIG5leHQgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3RcbiAgICAgICAgICBjb25zdCBkYXRhID0gc3RyZWFtLnJlYWQoKVxuICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsKSBvbmRhdGEoZGF0YSlcbiAgICAgICAgICBlbHNlIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lFRCkgIT09IDApIG9uZGF0YShudWxsKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJldHVybiAoKSB7XG4gICAgICAgIHJldHVybiBkZXN0cm95KG51bGwpXG4gICAgICB9LFxuICAgICAgdGhyb3cgKGVycikge1xuICAgICAgICByZXR1cm4gZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25yZWFkYWJsZSAoKSB7XG4gICAgICBpZiAocHJvbWlzZVJlc29sdmUgIT09IG51bGwpIG9uZGF0YShzdHJlYW0ucmVhZCgpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgICAgaWYgKHByb21pc2VSZXNvbHZlICE9PSBudWxsKSBvbmRhdGEobnVsbClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmRhdGEgKGRhdGEpIHtcbiAgICAgIGlmIChwcm9taXNlUmVqZWN0ID09PSBudWxsKSByZXR1cm5cbiAgICAgIGlmIChlcnJvcikgcHJvbWlzZVJlamVjdChlcnJvcilcbiAgICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwgJiYgKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpID09PSAwKSBwcm9taXNlUmVqZWN0KFNUUkVBTV9ERVNUUk9ZRUQpXG4gICAgICBlbHNlIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IGRhdGEsIGRvbmU6IGRhdGEgPT09IG51bGwgfSlcbiAgICAgIHByb21pc2VSZWplY3QgPSBwcm9taXNlUmVzb2x2ZSA9IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95IChlcnIpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWUVEKSByZXR1cm4gcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGFibGUgZXh0ZW5kcyBTdHJlYW0ge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBPUEVOSU5HIHwgUkVBRF9ET05FXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKHRoaXMsIG9wdHMpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMud3JpdGV2KSB0aGlzLl93cml0ZXYgPSBvcHRzLndyaXRldlxuICAgICAgaWYgKG9wdHMud3JpdGUpIHRoaXMuX3dyaXRlID0gb3B0cy53cml0ZVxuICAgICAgaWYgKG9wdHMuZmluYWwpIHRoaXMuX2ZpbmFsID0gb3B0cy5maW5hbFxuICAgICAgaWYgKG9wdHMuZWFnZXJPcGVuKSB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cblxuICBjb3JrICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9DT1JLRURcbiAgfVxuXG4gIHVuY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0NPUktFRFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgX3dyaXRldiAoYmF0Y2gsIGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmF1dG9CYXRjaChkYXRhLCBjYilcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgc3RhdGljIGlzQmFja3ByZXNzdXJlZCAod3MpIHtcbiAgICByZXR1cm4gKHdzLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0JBQ0tQUkVTU1VSRV9TVEFUVVMpICE9PSAwXG4gIH1cblxuICBzdGF0aWMgZHJhaW5lZCAod3MpIHtcbiAgICBpZiAod3MuZGVzdHJveWVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICAgIGNvbnN0IHN0YXRlID0gd3MuX3dyaXRhYmxlU3RhdGVcbiAgICBjb25zdCBwZW5kaW5nID0gKGlzV3JpdGV2KHdzKSA/IE1hdGgubWluKDEsIHN0YXRlLnF1ZXVlLmxlbmd0aCkgOiBzdGF0ZS5xdWV1ZS5sZW5ndGgpXG4gICAgY29uc3Qgd3JpdGVzID0gcGVuZGluZyArICgod3MuX2R1cGxleFN0YXRlICYgV1JJVEVfV1JJVElORykgPyAxIDogMClcbiAgICBpZiAod3JpdGVzID09PSAwKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgaWYgKHN0YXRlLmRyYWlucyA9PT0gbnVsbCkgc3RhdGUuZHJhaW5zID0gW11cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN0YXRlLmRyYWlucy5wdXNoKHsgd3JpdGVzLCByZXNvbHZlIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmQoZGF0YSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmNsYXNzIER1cGxleCBleHRlbmRzIFJlYWRhYmxlIHsgLy8gYW5kIFdyaXRhYmxlXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2R1cGxleFN0YXRlID0gT1BFTklORyB8ICh0aGlzLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVBRF9BSEVBRClcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUodGhpcywgb3B0cylcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAob3B0cy53cml0ZXYpIHRoaXMuX3dyaXRldiA9IG9wdHMud3JpdGV2XG4gICAgICBpZiAob3B0cy53cml0ZSkgdGhpcy5fd3JpdGUgPSBvcHRzLndyaXRlXG4gICAgICBpZiAob3B0cy5maW5hbCkgdGhpcy5fZmluYWwgPSBvcHRzLmZpbmFsXG4gICAgfVxuICB9XG5cbiAgY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQ09SS0VEXG4gIH1cblxuICB1bmNvcmsgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9DT1JLRURcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIF93cml0ZXYgKGJhdGNoLCBjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5hdXRvQmF0Y2goZGF0YSwgY2IpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmQoZGF0YSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLnRyYW5zZm9ybSkgdGhpcy5fdHJhbnNmb3JtID0gb3B0cy50cmFuc2Zvcm1cbiAgICAgIGlmIChvcHRzLmZsdXNoKSB0aGlzLl9mbHVzaCA9IG9wdHMuZmx1c2hcbiAgICB9XG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyZWQgPj0gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhID0gZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0oZGF0YSwgdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhXG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICAgIHRoaXMuX3RyYW5zZm9ybShkYXRhLCB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlclRyYW5zZm9ybSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBzdXBlci5kZXN0cm95KGVycilcbiAgICBpZiAodGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSA9IG51bGxcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyVHJhbnNmb3JtKClcbiAgICB9XG4gIH1cblxuICBfdHJhbnNmb3JtIChkYXRhLCBjYikge1xuICAgIGNiKG51bGwsIGRhdGEpXG4gIH1cblxuICBfZmx1c2ggKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlckZpbmFsID0gY2JcbiAgICB0aGlzLl9mbHVzaCh0cmFuc2Zvcm1BZnRlckZsdXNoLmJpbmQodGhpcykpXG4gIH1cbn1cblxuY2xhc3MgUGFzc1Rocm91Z2ggZXh0ZW5kcyBUcmFuc2Zvcm0ge31cblxuZnVuY3Rpb24gdHJhbnNmb3JtQWZ0ZXJGbHVzaCAoZXJyLCBkYXRhKSB7XG4gIGNvbnN0IGNiID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJGaW5hbFxuICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHRoaXMucHVzaChkYXRhKVxuICB0aGlzLnB1c2gobnVsbClcbiAgY2IobnVsbClcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVQcm9taXNlICguLi5zdHJlYW1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmV0dXJuIHBpcGVsaW5lKC4uLnN0cmVhbXMsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKHN0cmVhbSwgLi4uc3RyZWFtcykge1xuICBjb25zdCBhbGwgPSBBcnJheS5pc0FycmF5KHN0cmVhbSkgPyBbLi4uc3RyZWFtLCAuLi5zdHJlYW1zXSA6IFtzdHJlYW0sIC4uLnN0cmVhbXNdXG4gIGNvbnN0IGRvbmUgPSAoYWxsLmxlbmd0aCAmJiB0eXBlb2YgYWxsW2FsbC5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgPyBhbGwucG9wKCkgOiBudWxsXG5cbiAgaWYgKGFsbC5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ1BpcGVsaW5lIHJlcXVpcmVzIGF0IGxlYXN0IDIgc3RyZWFtcycpXG5cbiAgbGV0IHNyYyA9IGFsbFswXVxuICBsZXQgZGVzdCA9IG51bGxcbiAgbGV0IGVycm9yID0gbnVsbFxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdCA9IGFsbFtpXVxuXG4gICAgaWYgKGlzU3RyZWFteChzcmMpKSB7XG4gICAgICBzcmMucGlwZShkZXN0LCBvbmVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckhhbmRsZShzcmMsIHRydWUsIGkgPiAxLCBvbmVycm9yKVxuICAgICAgc3JjLnBpcGUoZGVzdClcbiAgICB9XG5cbiAgICBzcmMgPSBkZXN0XG4gIH1cblxuICBpZiAoZG9uZSkge1xuICAgIGxldCBmaW4gPSBmYWxzZVxuXG4gICAgY29uc3QgYXV0b0Rlc3Ryb3kgPSBpc1N0cmVhbXgoZGVzdCkgfHwgISEoZGVzdC5fd3JpdGFibGVTdGF0ZSAmJiBkZXN0Ll93cml0YWJsZVN0YXRlLmF1dG9EZXN0cm95KVxuXG4gICAgZGVzdC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgPT09IG51bGwpIGVycm9yID0gZXJyXG4gICAgfSlcblxuICAgIGRlc3Qub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIGZpbiA9IHRydWVcbiAgICAgIGlmICghYXV0b0Rlc3Ryb3kpIGRvbmUoZXJyb3IpXG4gICAgfSlcblxuICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgZGVzdC5vbignY2xvc2UnLCAoKSA9PiBkb25lKGVycm9yIHx8IChmaW4gPyBudWxsIDogUFJFTUFUVVJFX0NMT1NFKSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3RcblxuICBmdW5jdGlvbiBlcnJvckhhbmRsZSAocywgcmQsIHdyLCBvbmVycm9yKSB7XG4gICAgcy5vbignZXJyb3InLCBvbmVycm9yKVxuICAgIHMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgICAgaWYgKHJkICYmIHMuX3JlYWRhYmxlU3RhdGUgJiYgIXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHJldHVybiBvbmVycm9yKFBSRU1BVFVSRV9DTE9TRSlcbiAgICAgIGlmICh3ciAmJiBzLl93cml0YWJsZVN0YXRlICYmICFzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm4gb25lcnJvcihQUkVNQVRVUkVfQ0xPU0UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgaWYgKCFlcnIgfHwgZXJyb3IpIHJldHVyblxuICAgIGVycm9yID0gZXJyXG5cbiAgICBmb3IgKGNvbnN0IHMgb2YgYWxsKSB7XG4gICAgICBzLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlY2hvIChzKSB7XG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICEhc3RyZWFtLl93cml0YWJsZVN0YXRlXG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFteCAoc3RyZWFtKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyZWFtLl9kdXBsZXhTdGF0ZSA9PT0gJ251bWJlcicgJiYgaXNTdHJlYW0oc3RyZWFtKVxufVxuXG5mdW5jdGlvbiBpc0VuZGVkIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZFxufVxuXG5mdW5jdGlvbiBpc0ZpbmlzaGVkIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZFxufVxuXG5mdW5jdGlvbiBnZXRTdHJlYW1FcnJvciAoc3RyZWFtLCBvcHRzID0ge30pIHtcbiAgY29uc3QgZXJyID0gKHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZXJyb3IpIHx8IChzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yKVxuXG4gIC8vIGF2b2lkIGltcGxpY2l0IGVycm9ycyBieSBkZWZhdWx0XG4gIHJldHVybiAoIW9wdHMuYWxsICYmIGVyciA9PT0gU1RSRUFNX0RFU1RST1lFRCkgPyBudWxsIDogZXJyXG59XG5cbmZ1bmN0aW9uIGlzUmVhZFN0cmVhbXggKHN0cmVhbSkge1xuICByZXR1cm4gaXNTdHJlYW14KHN0cmVhbSkgJiYgc3RyZWFtLnJlYWRhYmxlXG59XG5cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIChzdHJlYW0uX2R1cGxleFN0YXRlICYgT1BFTklORykgIT09IE9QRU5JTkcgfHwgKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBQ1RJVkVfT1JfVElDS0lORykgIT09IDBcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5IChkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Qnl0ZUxlbmd0aCAoZGF0YSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5KGRhdGEpID8gZGF0YS5ieXRlTGVuZ3RoIDogMTAyNFxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGFib3J0ICgpIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignU3RyZWFtIGFib3J0ZWQuJykpXG59XG5cbmZ1bmN0aW9uIGlzV3JpdGV2IChzKSB7XG4gIHJldHVybiBzLl93cml0ZXYgIT09IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ICYmIHMuX3dyaXRldiAhPT0gRHVwbGV4LnByb3RvdHlwZS5fd3JpdGV2XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwaXBlbGluZSxcbiAgcGlwZWxpbmVQcm9taXNlLFxuICBpc1N0cmVhbSxcbiAgaXNTdHJlYW14LFxuICBpc0VuZGVkLFxuICBpc0ZpbmlzaGVkLFxuICBpc0Rpc3R1cmJlZCxcbiAgZ2V0U3RyZWFtRXJyb3IsXG4gIFN0cmVhbSxcbiAgV3JpdGFibGUsXG4gIFJlYWRhYmxlLFxuICBEdXBsZXgsXG4gIFRyYW5zZm9ybSxcbiAgLy8gRXhwb3J0IFBhc3NUaHJvdWdoIGZvciBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcyBjb3JlJ3Mgc3RyZWFtIG1vZHVsZVxuICBQYXNzVGhyb3VnaFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/streamx/index.js\n");

/***/ })

};
;