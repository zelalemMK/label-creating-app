"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/../node_modules/minipass/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/minipass/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21pbmlwYXNzL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsZ0NBQWE7QUFDM0Msc0NBQXNDLG1CQUFPLENBQUMsZ0NBQWE7QUFDM0QsOEJBQThCLG1CQUFPLENBQUMsZ0RBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5Q0FBeUM7QUFDakQsUUFBUSxzQ0FBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0JBQXdCO0FBQzNFO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsOEJBQThCO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWxhbGVtbWVrb25uZW4vRGVza3RvcC9QaXhlbFBlYWsvcHJvamVjdHMvbGFiZWwtY3JlYXRpbmctYXBwL2xhYmVsLWNyZWF0aW5nLWFwcC9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWluaXBhc3MgPSBleHBvcnRzLmlzV3JpdGFibGUgPSBleHBvcnRzLmlzUmVhZGFibGUgPSBleHBvcnRzLmlzU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgcHJvYyA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG4gICAgPyBwcm9jZXNzXG4gICAgOiB7XG4gICAgICAgIHN0ZG91dDogbnVsbCxcbiAgICAgICAgc3RkZXJyOiBudWxsLFxuICAgIH07XG5jb25zdCBub2RlX2V2ZW50c18xID0gcmVxdWlyZShcIm5vZGU6ZXZlbnRzXCIpO1xuY29uc3Qgbm9kZV9zdHJlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpzdHJlYW1cIikpO1xuY29uc3Qgbm9kZV9zdHJpbmdfZGVjb2Rlcl8xID0gcmVxdWlyZShcIm5vZGU6c3RyaW5nX2RlY29kZXJcIik7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIE1pbmlwYXNzIHN0cmVhbSwgTm9kZSBzdHJlYW0sIG9yIHNvbWV0aGluZ1xuICogZWxzZSB0aGF0IE1pbmlwYXNzIGNhbiBpbnRlcmFjdCB3aXRoLlxuICovXG5jb25zdCBpc1N0cmVhbSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICAocyBpbnN0YW5jZW9mIE1pbmlwYXNzIHx8XG4gICAgICAgIHMgaW5zdGFuY2VvZiBub2RlX3N0cmVhbV8xLmRlZmF1bHQgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNSZWFkYWJsZSkocykgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNXcml0YWJsZSkocykpO1xuZXhwb3J0cy5pc1N0cmVhbSA9IGlzU3RyZWFtO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCB7QGxpbmsgTWluaXBhc3MuUmVhZGFibGV9XG4gKi9cbmNvbnN0IGlzUmVhZGFibGUgPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgcyBpbnN0YW5jZW9mIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyICYmXG4gICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIC8vIG5vZGUgY29yZSBXcml0YWJsZSBzdHJlYW1zIGhhdmUgYSBwaXBlKCkgbWV0aG9kLCBidXQgaXQgdGhyb3dzXG4gICAgcy5waXBlICE9PSBub2RlX3N0cmVhbV8xLmRlZmF1bHQuV3JpdGFibGUucHJvdG90eXBlLnBpcGU7XG5leHBvcnRzLmlzUmVhZGFibGUgPSBpc1JlYWRhYmxlO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCB7QGxpbmsgTWluaXBhc3MuV3JpdGFibGV9XG4gKi9cbmNvbnN0IGlzV3JpdGFibGUgPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgcyBpbnN0YW5jZW9mIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyICYmXG4gICAgdHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygcy5lbmQgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLmlzV3JpdGFibGUgPSBpc1dyaXRhYmxlO1xuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKTtcbmNvbnN0IE1BWUJFX0VNSVRfRU5EID0gU3ltYm9sKCdtYXliZUVtaXRFbmQnKTtcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJyk7XG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJyk7XG5jb25zdCBFTUlUVEVEX0VSUk9SID0gU3ltYm9sKCdlbWl0dGVkRXJyb3InKTtcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJyk7XG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJyk7XG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKTtcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKTtcbmNvbnN0IEVOQ09ESU5HID0gU3ltYm9sKCdlbmNvZGluZycpO1xuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpO1xuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpO1xuY29uc3QgUEFVU0VEID0gU3ltYm9sKCdwYXVzZWQnKTtcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJyk7XG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgUElQRVMgPSBTeW1ib2woJ3BpcGVzJyk7XG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpO1xuY29uc3QgQlVGRkVSUFVTSCA9IFN5bWJvbCgnYnVmZmVyUHVzaCcpO1xuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0Jyk7XG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBpcyBkZXN0cm95ZWRcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBoYXMgYW4gZXJyb3JcbmNvbnN0IEVSUk9SID0gU3ltYm9sKCdlcnJvcicpO1xuY29uc3QgRU1JVERBVEEgPSBTeW1ib2woJ2VtaXREYXRhJyk7XG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJyk7XG5jb25zdCBFTUlURU5EMiA9IFN5bWJvbCgnZW1pdEVuZDInKTtcbmNvbnN0IEFTWU5DID0gU3ltYm9sKCdhc3luYycpO1xuY29uc3QgQUJPUlQgPSBTeW1ib2woJ2Fib3J0Jyk7XG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJyk7XG5jb25zdCBTSUdOQUwgPSBTeW1ib2woJ3NpZ25hbCcpO1xuY29uc3QgREFUQUxJU1RFTkVSUyA9IFN5bWJvbCgnZGF0YUxpc3RlbmVycycpO1xuY29uc3QgRElTQ0FSREVEID0gU3ltYm9sKCdkaXNjYXJkZWQnKTtcbmNvbnN0IGRlZmVyID0gKGZuKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbmNvbnN0IG5vZGVmZXIgPSAoZm4pID0+IGZuKCk7XG5jb25zdCBpc0VuZGlzaCA9IChldikgPT4gZXYgPT09ICdlbmQnIHx8IGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCc7XG5jb25zdCBpc0FycmF5QnVmZmVyTGlrZSA9IChiKSA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAoISFiICYmXG4gICAgICAgIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBiLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgICBiLmJ5dGVMZW5ndGggPj0gMCk7XG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IChiKSA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKTtcbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGlwZSB7XG4gICAgc3JjO1xuICAgIGRlc3Q7XG4gICAgb3B0cztcbiAgICBvbmRyYWluO1xuICAgIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5kZXN0ID0gZGVzdDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5vbmRyYWluID0gKCkgPT4gc3JjW1JFU1VNRV0oKTtcbiAgICAgICAgdGhpcy5kZXN0Lm9uKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIHVucGlwZSgpIHtcbiAgICAgICAgdGhpcy5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIC8vIG9ubHkgaGVyZSBmb3IgdGhlIHByb3RvdHlwZVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIHByb3h5RXJyb3JzKF9lcikgeyB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMudW5waXBlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgICAgICAgdGhpcy5kZXN0LmVuZCgpO1xuICAgIH1cbn1cbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbSB3aGVyZVxuICogZXJyb3JzIGFyZSBwcm94aWVkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQaXBlUHJveHlFcnJvcnMgZXh0ZW5kcyBQaXBlIHtcbiAgICB1bnBpcGUoKSB7XG4gICAgICAgIHRoaXMuc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpO1xuICAgICAgICBzdXBlci51bnBpcGUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHNyYywgZGVzdCwgb3B0cyk7XG4gICAgICAgIHRoaXMucHJveHlFcnJvcnMgPSBlciA9PiBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycyk7XG4gICAgfVxufVxuY29uc3QgaXNPYmplY3RNb2RlT3B0aW9ucyA9IChvKSA9PiAhIW8ub2JqZWN0TW9kZTtcbmNvbnN0IGlzRW5jb2RpbmdPcHRpb25zID0gKG8pID0+ICFvLm9iamVjdE1vZGUgJiYgISFvLmVuY29kaW5nICYmIG8uZW5jb2RpbmcgIT09ICdidWZmZXInO1xuLyoqXG4gKiBNYWluIGV4cG9ydCwgdGhlIE1pbmlwYXNzIGNsYXNzXG4gKlxuICogYFJUeXBlYCBpcyB0aGUgdHlwZSBvZiBkYXRhIGVtaXR0ZWQsIGRlZmF1bHRzIHRvIEJ1ZmZlclxuICpcbiAqIGBXVHlwZWAgaXMgdGhlIHR5cGUgb2YgZGF0YSB0byBiZSB3cml0dGVuLCBpZiBSVHlwZSBpcyBidWZmZXIgb3Igc3RyaW5nLFxuICogdGhlbiBhbnkge0BsaW5rIE1pbmlwYXNzLkNvbnRpZ3VvdXNEYXRhfSBpcyBhbGxvd2VkLlxuICpcbiAqIGBFdmVudHNgIGlzIHRoZSBzZXQgb2YgZXZlbnQgaGFuZGxlciBzaWduYXR1cmVzIHRoYXQgdGhpcyBvYmplY3RcbiAqIHdpbGwgZW1pdCwgc2VlIHtAbGluayBNaW5pcGFzcy5FdmVudHN9XG4gKi9cbmNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIFtGTE9XSU5HXSA9IGZhbHNlO1xuICAgIFtQQVVTRURdID0gZmFsc2U7XG4gICAgW1BJUEVTXSA9IFtdO1xuICAgIFtCVUZGRVJdID0gW107XG4gICAgW09CSkVDVE1PREVdO1xuICAgIFtFTkNPRElOR107XG4gICAgW0FTWU5DXTtcbiAgICBbREVDT0RFUl07XG4gICAgW0VPRl0gPSBmYWxzZTtcbiAgICBbRU1JVFRFRF9FTkRdID0gZmFsc2U7XG4gICAgW0VNSVRUSU5HX0VORF0gPSBmYWxzZTtcbiAgICBbQ0xPU0VEXSA9IGZhbHNlO1xuICAgIFtFTUlUVEVEX0VSUk9SXSA9IG51bGw7XG4gICAgW0JVRkZFUkxFTkdUSF0gPSAwO1xuICAgIFtERVNUUk9ZRURdID0gZmFsc2U7XG4gICAgW1NJR05BTF07XG4gICAgW0FCT1JURURdID0gZmFsc2U7XG4gICAgW0RBVEFMSVNURU5FUlNdID0gMDtcbiAgICBbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBjYW4gYmUgd3JpdHRlblxuICAgICAqL1xuICAgIHdyaXRhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gY2FuIGJlIHJlYWRcbiAgICAgKi9cbiAgICByZWFkYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogSWYgYFJUeXBlYCBpcyBCdWZmZXIsIHRoZW4gb3B0aW9ucyBkbyBub3QgbmVlZCB0byBiZSBwcm92aWRlZC5cbiAgICAgKiBPdGhlcndpc2UsIGFuIG9wdGlvbnMgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQgdG8gc3BlY2lmeSBlaXRoZXJcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MuU2hhcmVkT3B0aW9ucy5vYmplY3RNb2RlfSBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcy5TaGFyZWRPcHRpb25zLmVuY29kaW5nfSwgYXMgYXBwcm9wcmlhdGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3NbMF0gfHxcbiAgICAgICAgICAgIHt9KTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSAmJiB0eXBlb2Ygb3B0aW9ucy5lbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kaW5nIGFuZCBvYmplY3RNb2RlIG1heSBub3QgYmUgdXNlZCB0b2dldGhlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdE1vZGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VuY29kaW5nT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zLmVuY29kaW5nO1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQVNZTkNdID0gISFvcHRpb25zLmFzeW5jO1xuICAgICAgICB0aGlzW0RFQ09ERVJdID0gdGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gbmV3IG5vZGVfc3RyaW5nX2RlY29kZXJfMS5TdHJpbmdEZWNvZGVyKHRoaXNbRU5DT0RJTkddKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvL0B0cy1pZ25vcmUgLSBwcml2YXRlIG9wdGlvbiBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdFeHBvc2VCdWZmZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywgeyBnZXQ6ICgpID0+IHRoaXNbQlVGRkVSXSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL0B0cy1pZ25vcmUgLSBwcml2YXRlIG9wdGlvbiBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdFeHBvc2VQaXBlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwaXBlcycsIHsgZ2V0OiAoKSA9PiB0aGlzW1BJUEVTXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgdGhpc1tTSUdOQUxdID0gc2lnbmFsO1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tBQk9SVF0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXNbQUJPUlRdKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nIHRvIGJlIHJlYWQuXG4gICAgICpcbiAgICAgKiBGb3IgQnVmZmVyIHN0cmluZ3MsIHRoaXMgd2lsbCBiZSB0aGUgdG90YWwgYnl0ZSBsZW5ndGguXG4gICAgICogRm9yIHN0cmluZyBlbmNvZGluZyBzdHJlYW1zLCB0aGlzIHdpbGwgYmUgdGhlIHN0cmluZyBjaGFyYWN0ZXIgbGVuZ3RoLFxuICAgICAqIGFjY29yZGluZyB0byBKYXZhU2NyaXB0J3MgYHN0cmluZy5sZW5ndGhgIGxvZ2ljLlxuICAgICAqIEZvciBvYmplY3RNb2RlIHN0cmVhbXMsIHRoaXMgaXMgYSBjb3VudCBvZiB0aGUgaXRlbXMgd2FpdGluZyB0byBiZVxuICAgICAqIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZ2V0IGJ1ZmZlckxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBCdWZmZXJFbmNvZGluZ2AgY3VycmVudGx5IGluIHVzZSwgb3IgYG51bGxgXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tFTkNPRElOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVGhpcyBpcyBhIHJlYWQgb25seSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldCBlbmNvZGluZyhfZW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RpbmcgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gRW5jb2RpbmcgbWF5IG9ubHkgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZVxuICAgICAqL1xuICAgIHNldEVuY29kaW5nKF9lbmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIGFuIG9iamVjdE1vZGUgc3RyZWFtXG4gICAgICovXG4gICAgZ2V0IG9iamVjdE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgaXMgYSByZWFkLW9ubHkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXQgb2JqZWN0TW9kZShfb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmplY3RNb2RlIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoaXMgaXMgYW4gYXN5bmMgc3RyZWFtXG4gICAgICovXG4gICAgZ2V0IFsnYXN5bmMnXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQVNZTkNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtYWtlIHRoaXMgc3RyZWFtIGFzeW5jLlxuICAgICAqXG4gICAgICogT25jZSBzZXQsIGl0IGNhbm5vdCBiZSB1bnNldCwgYXMgdGhpcyB3b3VsZCBwb3RlbnRpYWxseSBjYXVzZSBpbmNvcnJlY3RcbiAgICAgKiBiZWhhdmlvci4gIEllLCBhIHN5bmMgc3RyZWFtIGNhbiBiZSBtYWRlIGFzeW5jLCBidXQgYW4gYXN5bmMgc3RyZWFtXG4gICAgICogY2Fubm90IGJlIHNhZmVseSBtYWRlIHN5bmMuXG4gICAgICovXG4gICAgc2V0IFsnYXN5bmMnXShhKSB7XG4gICAgICAgIHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhO1xuICAgIH1cbiAgICAvLyBkcm9wIGV2ZXJ5dGhpbmcgYW5kIGdldCBvdXQgb2YgdGhlIGZsb3cgY29tcGxldGVseVxuICAgIFtBQk9SVF0oKSB7XG4gICAgICAgIHRoaXNbQUJPUlRFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2Fib3J0JywgdGhpc1tTSUdOQUxdPy5yZWFzb24pO1xuICAgICAgICB0aGlzLmRlc3Ryb3kodGhpc1tTSUdOQUxdPy5yZWFzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQUJPUlRFRF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vLW9wIHNldHRlci4gU3RyZWFtIGFib3J0ZWQgc3RhdHVzIGlzIHNldCB2aWEgdGhlIEFib3J0U2lnbmFsIHByb3ZpZGVkXG4gICAgICogaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0IGFib3J0ZWQoXykgeyB9XG4gICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodGhpc1tBQk9SVEVEXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignQ2Fubm90IGNhbGwgd3JpdGUgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcpLCB7IGNvZGU6ICdFUlJfU1RSRUFNX0RFU1RST1lFRCcgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5jb2RpbmcpXG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogbm9kZWZlcjtcbiAgICAgICAgLy8gY29udmVydCBhcnJheSBidWZmZXJzIGFuZCB0eXBlZCBhcnJheSB2aWV3cyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgICAgIC8vIGxlYXZlIHN0cmluZ3MgYW5kIGJ1ZmZlcnMgYXMtaXNcbiAgICAgICAgLy8gYW55dGhpbmcgaXMgb25seSBhbGxvd2VkIGlmIGluIG9iamVjdCBtb2RlLCBzbyB0aHJvd1xuICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0gJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLmJ1ZmZlciwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyTGlrZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1jb250aWd1b3VzIGRhdGEgd3JpdHRlbiB0byBub24tb2JqZWN0TW9kZSBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgICAgICAvLyB0aGlzIHlpZWxkcyBiZXR0ZXIgcGVyZm9ybWFuY2UsIGZld2VyIGNoZWNrcyBsYXRlci5cbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIC8vIG1heWJlIGltcG9zc2libGU/XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzW0ZMVVNIXSh0cnVlKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuayk7XG4gICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgICAgIGlmIChjYilcbiAgICAgICAgICAgICAgICBmbihjYik7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBjaHVuayBpcyBhIGJ1ZmZlciBvciBzdHJpbmdcbiAgICAgICAgLy8gZG9uJ3QgYnVmZmVyIGl0IHVwIG9yIHNlbmQgaXQgdG8gdGhlIGRlY29kZXJcbiAgICAgICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhc3QtcGF0aCB3cml0aW5nIHN0cmluZ3Mgb2Ygc2FtZSBlbmNvZGluZyB0byBhIHN0cmVhbSB3aXRoXG4gICAgICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBzdHJpbmcgYWxyZWFkeSByZWFkeSBmb3IgdXMgdG8gdXNlXG4gICAgICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXT8ubGFzdE5lZWQpKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdlXG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdGhpc1tFTkNPRElOR10pIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgIGNodW5rID0gdGhpc1tERUNPREVSXS53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgdGhpc1tGTFVTSF0odHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIGV4cGxpY2l0IHJlYWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogSW4gb2JqZWN0TW9kZSwgdGhlIGFyZ3VtZW50IGlzIGlnbm9yZWQsIGFuZCBvbmUgaXRlbSBpcyByZXR1cm5lZCBpZlxuICAgICAqIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIGBuYCBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIChvciBpbiB0aGUgY2FzZSBvZiBlbmNvZGluZyBzdHJlYW1zLFxuICAgICAqIGNoYXJhY3RlcnMpIHRvIGNvbnN1bWUuIElmIGBuYCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGVudGlyZSBidWZmZXJcbiAgICAgKiBpcyByZXR1cm5lZCwgb3IgYG51bGxgIGlzIHJldHVybmVkIGlmIG5vIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogSWYgYG5gIGlzIGdyZWF0ZXIgdGhhdCB0aGUgYW1vdW50IG9mIGRhdGEgaW4gdGhlIGludGVybmFsIGJ1ZmZlcixcbiAgICAgKiB0aGVuIGBudWxsYCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICByZWFkKG4pIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fFxuICAgICAgICAgICAgbiA9PT0gMCB8fFxuICAgICAgICAgICAgKG4gJiYgbiA+IHRoaXNbQlVGRkVSTEVOR1RIXSkpIHtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIG4gPSBudWxsO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIC8vIG5vdCBvYmplY3QgbW9kZSwgc28gaWYgd2UgaGF2ZSBhbiBlbmNvZGluZywgdGhlbiBSVHlwZSBpcyBzdHJpbmdcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgbXVzdCBiZSBCdWZmZXJcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9IFtcbiAgICAgICAgICAgICAgICAodGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzW0JVRkZFUl0uam9pbignJylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXNbQlVGRkVSXSwgdGhpc1tCVUZGRVJMRU5HVEhdKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXNbUkVBRF0obiB8fCBudWxsLCB0aGlzW0JVRkZFUl1bMF0pO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbUkVBRF0obiwgY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUlNISUZUXSgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaHVuaztcbiAgICAgICAgICAgIGlmIChuID09PSBjLmxlbmd0aCB8fCBuID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl1bMF0gPSBjLnNsaWNlKG4pO1xuICAgICAgICAgICAgICAgIGNodW5rID0gYy5zbGljZSgwLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGMuc3ViYXJyYXkobik7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjLnN1YmFycmF5KDAsIG4pO1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgaWYgKCF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBjaHVuaztcbiAgICAgICAgICAgIGNodW5rID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYik7XG4gICAgICAgIHRoaXNbRU9GXSA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZW4ndCB3cml0dGVuIGFueXRoaW5nLCB0aGVuIGdvIGFoZWFkIGFuZCBlbWl0LFxuICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIG5vdCByZWFkaW5nLlxuICAgICAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAgICAgLy8gVGhpcyBtYWtlcyBNUCBtb3JlIHN1aXRhYmxlIHRvIHdyaXRlLW9ubHkgdXNlIGNhc2VzLlxuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGRvbid0IGxldCB0aGUgaW50ZXJuYWwgcmVzdW1lIGJlIG92ZXJ3cml0dGVuXG4gICAgW1JFU1VNRV0oKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpc1tEQVRBTElTVEVORVJTXSAmJiAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzW0ZMVVNIXSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgc3RyZWFtIGlmIGl0IGlzIGN1cnJlbnRseSBpbiBhIHBhdXNlZCBzdGF0ZVxuICAgICAqXG4gICAgICogSWYgY2FsbGVkIHdoZW4gdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zIG9yIGBkYXRhYCBldmVudCBsaXN0ZW5lcnMsXG4gICAgICogdGhpcyB3aWxsIHBsYWNlIHRoZSBzdHJlYW0gaW4gYSBcImRpc2NhcmRlZFwiIHN0YXRlLCB3aGVyZSBhbGwgZGF0YSB3aWxsXG4gICAgICogYmUgdGhyb3duIGF3YXkuIFRoZSBkaXNjYXJkZWQgc3RhdGUgaXMgcmVtb3ZlZCBpZiBhIHBpcGUgZGVzdGluYXRpb24gb3JcbiAgICAgKiBkYXRhIGhhbmRsZXIgaXMgYWRkZWQsIGlmIHBhdXNlKCkgaXMgY2FsbGVkLCBvciBpZiBhbnkgc3luY2hyb25vdXMgb3JcbiAgICAgKiBhc3luY2hyb25vdXMgaXRlcmF0aW9uIGlzIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tSRVNVTUVdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW1BBVVNFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGZvcmNpYmx5IGRlc3Ryb3llZFxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0RFU1RST1lFRF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgaW4gYSBmbG93aW5nIHN0YXRlLCBtZWFuaW5nIHRoYXRcbiAgICAgKiBhbnkgd3JpdGVzIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBnZXQgZmxvd2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgaW4gYSBwYXVzZWQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tQQVVTRURdO1xuICAgIH1cbiAgICBbQlVGRkVSUFVTSF0oY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpc1tCVUZGRVJdLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBbQlVGRkVSU0hJRlRdKCkge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gdGhpc1tCVUZGRVJdWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXNbQlVGRkVSXS5zaGlmdCgpO1xuICAgIH1cbiAgICBbRkxVU0hdKG5vRHJhaW4gPSBmYWxzZSkge1xuICAgICAgICBkbyB7IH0gd2hpbGUgKHRoaXNbRkxVU0hDSFVOS10odGhpc1tCVUZGRVJTSElGVF0oKSkgJiZcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGgpO1xuICAgICAgICBpZiAoIW5vRHJhaW4gJiYgIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gICAgW0ZMVVNIQ0hVTktdKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpcGUgYWxsIGRhdGEgZW1pdHRlZCBieSB0aGlzIHN0cmVhbSBpbnRvIHRoZSBkZXN0aW5hdGlvbiBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIHRoZSBmbG93IG9mIGRhdGEuXG4gICAgICovXG4gICAgcGlwZShkZXN0LCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVuZGVkID0gdGhpc1tFTUlUVEVEX0VORF07XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICAgICAgICBvcHRzLmVuZCA9IGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRzLmVuZCA9IG9wdHMuZW5kICE9PSBmYWxzZTtcbiAgICAgICAgb3B0cy5wcm94eUVycm9ycyA9ICEhb3B0cy5wcm94eUVycm9ycztcbiAgICAgICAgLy8gcGlwaW5nIGFuIGVuZGVkIHN0cmVhbSBlbmRzIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZW5kKVxuICAgICAgICAgICAgICAgIGRlc3QuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBcImFzXCIgaGVyZSBqdXN0IGlnbm9yZXMgdGhlIFdUeXBlLCB3aGljaCBwaXBlcyBkb24ndCBjYXJlIGFib3V0LFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSdyZSBvbmx5IGNvbnN1bWluZyBmcm9tIHVzLCBhbmQgd3JpdGluZyB0byB0aGUgZGVzdFxuICAgICAgICAgICAgdGhpc1tQSVBFU10ucHVzaCghb3B0cy5wcm94eUVycm9yc1xuICAgICAgICAgICAgICAgID8gbmV3IFBpcGUodGhpcywgZGVzdCwgb3B0cylcbiAgICAgICAgICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpO1xuICAgICAgICAgICAgaWYgKHRoaXNbQVNZTkNdKVxuICAgICAgICAgICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW1JFU1VNRV0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVsbHkgdW5ob29rIGEgcGlwZWQgZGVzdGluYXRpb24gc3RyZWFtLlxuICAgICAqXG4gICAgICogSWYgdGhlIGRlc3RpbmF0aW9uIHN0cmVhbSB3YXMgdGhlIG9ubHkgY29uc3VtZXIgb2YgdGhpcyBzdHJlYW0gKGllLFxuICAgICAqIHRoZXJlIGFyZSBubyBvdGhlciBwaXBlZCBkZXN0aW5hdGlvbnMgb3IgYCdkYXRhJ2AgZXZlbnQgbGlzdGVuZXJzKVxuICAgICAqIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3AgdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqL1xuICAgIHVucGlwZShkZXN0KSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzW1BJUEVTXS5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmICh0aGlzW1BJUEVTXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0RBVEFMSVNURU5FUlNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1tQSVBFU10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW1BJUEVTXS5zcGxpY2UodGhpc1tQSVBFU10uaW5kZXhPZihwKSwgMSk7XG4gICAgICAgICAgICBwLnVucGlwZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgTWluaXBhc3Mjb259XG4gICAgICovXG4gICAgYWRkTGlzdGVuZXIoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXYsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIub25gLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBiZWhhdmlvciBkaWZmZXJlbmNlcyB0byBwcmV2ZW50IGRhdGEgbG9zcyBhbmQgdW5uZWNlc3NhcnkgaGFuZ3M6XG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhICdkYXRhJyBldmVudCBoYW5kbGVyIHdpbGwgdHJpZ2dlciB0aGUgZmxvdyBvZiBkYXRhXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhICdyZWFkYWJsZScgZXZlbnQgaGFuZGxlciB3aGVuIHRoZXJlIGlzIGRhdGEgd2FpdGluZyB0byBiZSByZWFkXG4gICAgICogICB3aWxsIGNhdXNlICdyZWFkYWJsZScgdG8gYmUgZW1pdHRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGFuICdlbmRpc2gnIGV2ZW50IGhhbmRsZXIgKCdlbmQnLCAnZmluaXNoJywgZXRjLikgd2hpY2ggaGFzXG4gICAgICogICBhbHJlYWR5IHBhc3NlZCB3aWxsIGNhdXNlIHRoZSBldmVudCB0byBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5IGFuZCBhbGxcbiAgICAgKiAgIGhhbmRsZXJzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhbiAnZXJyb3InIGV2ZW50IGhhbmRsZXIgYWZ0ZXIgYW4gZXJyb3IgaGFzIGJlZW4gZW1pdHRlZCB3aWxsXG4gICAgICogICBjYXVzZSB0aGUgZXZlbnQgdG8gYmUgcmUtZW1pdHRlZCBpbW1lZGlhdGVseSB3aXRoIHRoZSBlcnJvciBwcmV2aW91c2x5XG4gICAgICogICByYWlzZWQuXG4gICAgICovXG4gICAgb24oZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIub24oZXYsIGhhbmRsZXIpO1xuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdKys7XG4gICAgICAgICAgICBpZiAoIXRoaXNbUElQRVNdLmxlbmd0aCAmJiAhdGhpc1tGTE9XSU5HXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbUkVTVU1FXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkge1xuICAgICAgICAgICAgc3VwZXIuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoZXYpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBoYW5kbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXNbQVNZTkNdKVxuICAgICAgICAgICAgICAgIGRlZmVyKCgpID0+IGguY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaC5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgTWluaXBhc3Mjb2ZmfVxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5vZmZgXG4gICAgICpcbiAgICAgKiBJZiBhICdkYXRhJyBldmVudCBoYW5kbGVyIGlzIHJlbW92ZWQsIGFuZCBpdCB3YXMgdGhlIGxhc3QgY29uc3VtZXJcbiAgICAgKiAoaWUsIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyBvciBvdGhlciAnZGF0YScgZXZlbnQgbGlzdGVuZXJzKSxcbiAgICAgKiB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKi9cbiAgICBvZmYoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIub2ZmKGV2LCBoYW5kbGVyKTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgbGlzdGVuZXJzLCBhbmQgbm93IHdlIGRvbid0LCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgLy8gaGF2ZSBhbnkgcGlwZXMsIHRoZW4gc3RvcCB0aGUgZmxvdywgdW5sZXNzIGl0J3MgYmVlbiBleHBsaWNpdGx5XG4gICAgICAgIC8vIHB1dCBpbiBhIGRpc2NhcmRlZCBmbG93aW5nIHN0YXRlIHZpYSBzdHJlYW0ucmVzdW1lKCkuXG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdID0gdGhpcy5saXN0ZW5lcnMoJ2RhdGEnKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpc1tEQVRBTElTVEVORVJTXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICF0aGlzW0RJU0NBUkRFRF0gJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnNgXG4gICAgICpcbiAgICAgKiBJZiBhbGwgJ2RhdGEnIGV2ZW50IGhhbmRsZXJzIGFyZSByZW1vdmVkLCBhbmQgdGhleSB3ZXJlIHRoZSBsYXN0IGNvbnN1bWVyXG4gICAgICogKGllLCB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMpLCB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wXG4gICAgICogdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvciB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5XG4gICAgICogY2FsbGVkLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdID0gMDtcbiAgICAgICAgICAgIGlmICghdGhpc1tESVNDQVJERURdICYmICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgJ2VuZCcgZXZlbnQgaGFzIGJlZW4gZW1pdHRlZFxuICAgICAqL1xuICAgIGdldCBlbWl0dGVkRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tFTUlUVEVEX0VORF07XG4gICAgfVxuICAgIFtNQVlCRV9FTUlUX0VORF0oKSB7XG4gICAgICAgIGlmICghdGhpc1tFTUlUVElOR19FTkRdICYmXG4gICAgICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0RFU1RST1lFRF0gJiZcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXNbRU9GXSkge1xuICAgICAgICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0NMT1NFRF0pXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLmVtaXRgLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBiZWhhdmlvciBkaWZmZXJlbmNlcyB0byBwcmV2ZW50IGRhdGEgbG9zcyBhbmQgdW5uZWNlc3NhcnkgaGFuZ3M6XG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGRlc3Ryb3llZCwgYW5kIHRoZSBldmVudCBpcyBzb21ldGhpbmcgb3RoZXJcbiAgICAgKiB0aGFuICdjbG9zZScgb3IgJ2Vycm9yJywgdGhlbiBgZmFsc2VgIGlzIHJldHVybmVkIGFuZCBubyBoYW5kbGVyc1xuICAgICAqIGFyZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2VuZCcsIGFuZCBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWQsIHRoZW4gdGhlIGV2ZW50XG4gICAgICogaXMgaWdub3JlZC4gSWYgdGhlIHN0cmVhbSBpcyBpbiBhIHBhdXNlZCBvciBub24tZmxvd2luZyBzdGF0ZSwgdGhlblxuICAgICAqIHRoZSBldmVudCB3aWxsIGJlIGRlZmVycmVkIHVudGlsIGRhdGEgZmxvdyByZXN1bWVzLiBJZiB0aGUgc3RyZWFtIGlzXG4gICAgICogYXN5bmMsIHRoZW4gaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGljayByYXRoZXIgdGhhblxuICAgICAqIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdjbG9zZScsIGFuZCAnZW5kJyBoYXMgbm90IHlldCBiZWVuIGVtaXR0ZWQsIHRoZW5cbiAgICAgKiB0aGUgZXZlbnQgd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCBhZnRlciAnZW5kJyBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdlcnJvcicsIGFuZCBhbiBBYm9ydFNpZ25hbCB3YXMgcHJvdmlkZWQgZm9yIHRoZSBzdHJlYW0sXG4gICAgICogYW5kIHRoZXJlIGFyZSBubyBsaXN0ZW5lcnMsIHRoZW4gdGhlIGV2ZW50IGlzIGlnbm9yZWQsIG1hdGNoaW5nIHRoZVxuICAgICAqIGJlaGF2aW9yIG9mIG5vZGUgY29yZSBzdHJlYW1zIGluIHRoZSBwcmVzZW5zZSBvZiBhbiBBYm9ydFNpZ25hbC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZmluaXNoJyBvciAncHJlZmluaXNoJywgdGhlbiBhbGwgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudCwgdG8gcHJldmVudCBkb3VibGUtZmlyaW5nLlxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFyZ3NbMF07XG4gICAgICAgIC8vIGVycm9yIGFuZCBjbG9zZSBhcmUgb25seSBldmVudHMgYWxsb3dlZCBhZnRlciBjYWxsaW5nIGRlc3Ryb3koKVxuICAgICAgICBpZiAoZXYgIT09ICdlcnJvcicgJiZcbiAgICAgICAgICAgIGV2ICE9PSAnY2xvc2UnICYmXG4gICAgICAgICAgICBldiAhPT0gREVTVFJPWUVEICYmXG4gICAgICAgICAgICB0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXNbT0JKRUNUTU9ERV0gJiYgIWRhdGFcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzW0FTWU5DXVxuICAgICAgICAgICAgICAgICAgICA/IChkZWZlcigoKSA9PiB0aGlzW0VNSVREQVRBXShkYXRhKSksIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpc1tFTUlUREFUQV0oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tFTUlURU5EXSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gZG9uJ3QgZW1pdCBjbG9zZSBiZWZvcmUgJ2VuZCcgYW5kICdmaW5pc2gnXG4gICAgICAgICAgICBpZiAoIXRoaXNbRU1JVFRFRF9FTkRdICYmICF0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IGRhdGE7XG4gICAgICAgICAgICBzdXBlci5lbWl0KEVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9ICF0aGlzW1NJR05BTF0gfHwgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAncmVzdW1lJykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgncmVzdW1lJyk7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbRU1JVERBVEFdKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICBpZiAocC5kZXN0LndyaXRlKGRhdGEpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tESVNDQVJERURdID8gZmFsc2UgOiBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlURU5EXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbRU1JVFRFRF9FTkRdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzW0VNSVRURURfRU5EXSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXNbQVNZTkNdXG4gICAgICAgICAgICA/IChkZWZlcigoKSA9PiB0aGlzW0VNSVRFTkQyXSgpKSwgdHJ1ZSlcbiAgICAgICAgICAgIDogdGhpc1tFTUlURU5EMl0oKTtcbiAgICB9XG4gICAgW0VNSVRFTkQyXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5kZXN0LndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbRElTQ0FSREVEXSlcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgcC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlbmQnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYWxsIGVtaXR0ZWQgZGF0YSBvbmNlXG4gICAgICogdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbGxlY3QoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IE9iamVjdC5hc3NpZ24oW10sIHtcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICBidWYuZGF0YUxlbmd0aCA9IDA7XG4gICAgICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAgICAgLy8gYnkgdHJpZ2dlcmluZyB0aGUgZmxvdyBoZXJlLlxuICAgICAgICBjb25zdCBwID0gdGhpcy5wcm9taXNlKCk7XG4gICAgICAgIHRoaXMub24oJ2RhdGEnLCBjID0+IHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgICAgIGJ1Zi5kYXRhTGVuZ3RoICs9IGMubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcDtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBlbWl0dGVkIGRhdGFcbiAgICAgKiBvbmNlIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKlxuICAgICAqIE5vdCBhbGxvd2VkIG9uIG9iamVjdE1vZGUgc3RyZWFtcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25jYXQoKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuY29sbGVjdCgpO1xuICAgICAgICByZXR1cm4gKHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICA/IGJ1Zi5qb2luKCcnKVxuICAgICAgICAgICAgOiBCdWZmZXIuY29uY2F0KGJ1ZiwgYnVmLmRhdGFMZW5ndGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdm9pZCBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2Vycm9yJywgZXIgPT4gcmVqZWN0KGVyKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIGBmb3IgYXdhaXQgb2ZgIGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBjb250aW51ZSBlbWl0dGluZyBhbGwgY2h1bmtzIHVudGlsIHRoZSBzdHJlYW0gdGVybWluYXRlcy5cbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAvLyBzZXQgdGhpcyB1cCBmcm9udCwgaW4gY2FzZSB0aGUgY29uc3VtZXIgZG9lc24ndCBjYWxsIG5leHQoKVxuICAgICAgICAvLyByaWdodCBhd2F5LlxuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSk7XG4gICAgICAgICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgIGxldCByZWplY3Q7XG4gICAgICAgICAgICBjb25zdCBvbmVyciA9IChlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmRhdGEgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZGVzdHJveSA9ICgpID0+IG9uZXJyKG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIHRocm93OiBzdG9wLFxuICAgICAgICAgICAgcmV0dXJuOiBzdG9wLFxuICAgICAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIGBmb3Igb2ZgIGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRpb24gd2lsbCB0ZXJtaW5hdGUgd2hlbiB0aGUgaW50ZXJuYWwgYnVmZmVyIHJ1bnMgb3V0LCBldmVuXG4gICAgICogaWYgdGhlIHN0cmVhbSBoYXMgbm90IHlldCB0ZXJtaW5hdGVkLlxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAvLyBzZXQgdGhpcyB1cCBmcm9udCwgaW4gY2FzZSB0aGUgY29uc3VtZXIgZG9lc24ndCBjYWxsIG5leHQoKVxuICAgICAgICAvLyByaWdodCBhd2F5LlxuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKEVSUk9SLCBzdG9wKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgc3RvcCk7XG4gICAgICAgICAgICB0aGlzLm9mZignZW5kJywgc3RvcCk7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gc3RvcCgpIDogeyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBzdG9wKTtcbiAgICAgICAgdGhpcy5vbmNlKEVSUk9SLCBzdG9wKTtcbiAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgc3RvcCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICAgICAgICByZXR1cm46IHN0b3AsXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYSBzdHJlYW0sIHByZXZlbnRpbmcgaXQgZnJvbSBiZWluZyB1c2VkIGZvciBhbnkgZnVydGhlciBwdXJwb3NlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHN0cmVhbSBoYXMgYSBgY2xvc2UoKWAgbWV0aG9kLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIG9uXG4gICAgICogZGVzdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBBZnRlciBkZXN0cnVjdGlvbiwgYW55IGF0dGVtcHQgdG8gd3JpdGUgZGF0YSwgcmVhZCBkYXRhLCBvciBlbWl0IG1vc3RcbiAgICAgKiBldmVudHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogSWYgYW4gZXJyb3IgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBlbWl0dGVkIGluIGFuXG4gICAgICogJ2Vycm9yJyBldmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KGVyKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwO1xuICAgICAgICBjb25zdCB3YyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2MuY2xvc2UgPT09ICdmdW5jdGlvbicgJiYgIXRoaXNbQ0xPU0VEXSlcbiAgICAgICAgICAgIHdjLmNsb3NlKCk7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIC8vIGlmIG5vIGVycm9yIHRvIGVtaXQsIHN0aWxsIHJlamVjdCBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBpc1N0cmVhbX1cbiAgICAgKlxuICAgICAqIEZvcm1lciBleHBvcnQgbG9jYXRpb24sIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGlzU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5pc1N0cmVhbTtcbiAgICB9XG59XG5leHBvcnRzLk1pbmlwYXNzID0gTWluaXBhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/minipass/dist/commonjs/index.js\n");

/***/ })

};
;